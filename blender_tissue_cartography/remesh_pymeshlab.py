# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05b_remeshing_pymeshlab.ipynb.

# %% auto 0
__all__ = ['subdivide_pymeshlab', 'simplify_pymeshlab', 'remesh_pymeshlab']

# %% ../nbs/05b_remeshing_pymeshlab.ipynb 4
from . import io as tcio
from . import interface_pymeshlab as intmsl

import numpy as np
import igl

import warnings
import os
import pymeshlab

# %% ../nbs/05b_remeshing_pymeshlab.ipynb 7
def subdivide_pymeshlab(mesh, threshold=1, iterations=3, reglue=True, decimals=None):
    """
    Refine mesh by edge subdivision using pymeshlab.
    
    Subdivides all edges by placing new vertices at edge midpoints. Preserves UV information,
    by cuts the mesh along seams and (optionally) glueing back after. New texture vertices
    are also placed at texture-edge midpoints. 
    
    In contrast to remeshing_igl.subdivide_igl, you can choose to subdivide long edges only,
    which is very useful to increase mesh resolution only where necessary.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    threshold : float
        All the edges longer than this threshold will be refined. In percent?
        Lower values mean more subdivision.  Setting this value to zero will
        force an uniform refinement.
    iterations : int
        Filter iterations
    reglue : bool
        Glue back after cutting
    decimals : int or None
        Decimal precision for merging vertices when regluing. If None, estimated from average
        edge mesh length as -4*log_10(avg length)

    Returns
    -------
    mesh_subdiv : ObjMesh
        Subdivided mesh.
    
    """
    mesh_cut = mesh.cut_along_seams()
    mesh_pymeshlab = intmsl.convert_to_pymeshlab(mesh_cut)
    ms = pymeshlab.MeshSet()
    ms.add_mesh(mesh_pymeshlab)
    ms.meshing_surface_subdivision_midpoint(threshold=pymeshlab.PercentageValue(threshold))
    mesh_subdiv = intmsl.convert_from_pymeshlab(ms.current_mesh(), reconstruct_texture_from_faces=False)
    if reglue:
        mesh_subdiv = tcio.glue_seams(mesh_subdiv, decimals=decimals)

    return mesh_subdiv

# %% ../nbs/05b_remeshing_pymeshlab.ipynb 13
@tcio.deprecated
def simplify_pymeshlab(mesh, targetfacenum, qualitythr=0.3, tempfilename="temp.obj", reglue=False, decimals=None):
    """
    Simplify mesh using pymeshlab, removing small triangles.
    
    Use meshing_decimation_quadric_edge_collapse_with_texture filter.
    Due to a bug in pymeshlab, we need to temporarily write some files to disk.
    Cuts mesh along UV seams so it can preserve UV texture info, optionally regluing.
    
    Note: this function _will_ degrade the UV quality.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    targetfacenum : int
        Target number of faces
    qualitythr : float from 0-1
        0 accepts any face, penalizes bad shapes. If >0, may cause problems with reglueing.
    tempfilename : str
        Temporary file written for pymeshlab interfacing. This file will be deleted after!
    reglue : bool
        Glue back after cutting
    decimals : int or None
        Decimal precision for merging vertices when regluing. If None, estimated from average
        edge mesh length as -4*log_10(avg length)

    Returns
    -------
    mesh_simplified : ObjMesh
        Simplified mesh.
    
    """
    mesh.cut_along_seams().write_obj(tempfilename)
    ms = pymeshlab.MeshSet()
    ms.load_new_mesh(tempfilename)
    ms.meshing_decimation_quadric_edge_collapse_with_texture(targetfacenum=targetfacenum, qualitythr=qualitythr,
                                                             preserveboundary=True, preservenormal=True, 
                                                             extratcoordw=0, planarquadric=True)
    mesh_simplified = intmsl.convert_from_pymeshlab(ms.current_mesh(), reconstruct_texture_from_faces=False)
    
    if reglue:
        mesh_simplified = tcio.glue_seams(mesh_simplified, decimals=decimals)
    return mesh_simplified

# %% ../nbs/05b_remeshing_pymeshlab.ipynb 23
def remesh_pymeshlab(mesh, targetlen=1, iterations=10):
    """
    Remesh mesh using pymeshlab.
    
    This creates a triangulation of triangles which are close to equilateral and
    everywhere the same shape. Very useful to improve the output of
    marching cubes. Uses the meshing_isotropic_explicit_remeshing filter.
    
    This function erases UV information!
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    targetlen : float
        Percent value for target edge length.
    iterations : int
        Number of iterations.

    Returns
    -------
    mesh_remeshed : ObjMesh
        Simplified mesh.
    
    """
    mesh_pymeshlab = intmsl.convert_to_pymeshlab(mesh, add_texture_info=False)
    ms = pymeshlab.MeshSet()
    ms.add_mesh(mesh_pymeshlab)
    ms.meshing_isotropic_explicit_remeshing(iterations=iterations, targetlen=pymeshlab.PercentageValue(targetlen),
                                            splitflag=True, collapseflag=True, swapflag=True,
                                            smoothflag=True, reprojectflag=True, adaptive=False)
    mesh_pymeshlab_remeshed = ms.current_mesh()
    mesh_remeshed = intmsl.convert_from_pymeshlab(mesh_pymeshlab_remeshed, reconstruct_texture_from_faces=False)    
    return mesh_remeshed

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/04b_remeshing_pymeshlab.ipynb.

# %% auto 0
__all__ = ['reconstruct_poisson', 'subdivide_pymeshlab', 'remesh_pymeshlab']

# %% ../nbs/Python library/04b_remeshing_pymeshlab.ipynb 3
from . import mesh as tcmesh
from . import io as tcio

from . import interface_pymeshlab as intmsl

import numpy as np
import igl

import warnings
import os
import pymeshlab

# %% ../nbs/Python library/04b_remeshing_pymeshlab.ipynb 11
def reconstruct_poisson(points, samplenum=1000, k_neighbor_normals=10, reconstruc_args=None):
    """
    Reconstruct triangular mesh from a point cloud.
    
    Recommended to use isotropic remeshing after to improve mesh quality (remesh_pymeshlab).
    Wrapper of pymeshlab filter generate_surface_reconstruction_screened_poisson
    See pymeshlab.readthedocs.io/en/latest/filter_list.html for its arguments.
    
    Parameters
    ----------
    points : np.array of shape (n_points, 3)
        Point cloud.
    samplenum : int
        Sample number for point cloud simplification. Smaller values
        lead to more simplification of the point cloud and faster processing
    k_neighbor_normals : int
        Nearest neighbors for constructing normal vectors to point cloud
    reglue : bool
        Glue back after cutting
    reconstruc_args : dict or None
        Arguments to surface reconstruction algorithm/

    Returns
    -------
    tcmehs.ObjMesh
        Reconstructed surface.

    """
    if reconstruc_args is None:
        reconstruc_args = dict()
    point_cloud = tcmesh.ObjMesh(vertices=points, faces=[])
    point_cloud_pymeshlab = intmsl.convert_to_pymeshlab(point_cloud)
    ms = pymeshlab.MeshSet()
    ms.add_mesh(point_cloud_pymeshlab)
    ms.generate_simplified_point_cloud(samplenum=samplenum)
    ms.compute_normal_for_point_clouds(k=k_neighbor_normals, smoothiter=2)
    ms.generate_surface_reconstruction_screened_poisson(**reconstruc_args)
    return intmsl.convert_from_pymeshlab(ms.current_mesh())

# %% ../nbs/Python library/04b_remeshing_pymeshlab.ipynb 14
def subdivide_pymeshlab(mesh, threshold=1, iterations=3, reglue=True, decimals=None):
    """
    Refine mesh by edge subdivision using pymeshlab.
    
    Subdivides all edges by placing new vertices at edge midpoints. Preserves UV information,
    by cutting the mesh along seams and (optionally) gluing back after. New texture vertices
    are also placed at texture-edge midpoints. 
    
    In contrast to remeshing_igl.subdivide_igl, you can choose to subdivide long edges only,
    which is very useful to increase mesh resolution only where necessary.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    threshold : float
        All the edges longer than this threshold will be refined. In percent?
        Lower values mean more subdivision.  Setting this value to zero will
        force an uniform refinement.
    iterations : int
        Filter iterations
    reglue : bool
        Glue back after cutting
    decimals : int or None
        Decimal precision for merging vertices when regluing. If None, estimate from the average
        edge mesh length as -4*log_10(avg length)

    Returns
    -------
    mesh_subdiv : ObjMesh
        Subdivided mesh.
    
    """
    mesh_cut = mesh.cut_along_seams()
    mesh_pymeshlab = intmsl.convert_to_pymeshlab(mesh_cut)
    ms = pymeshlab.MeshSet()
    ms.add_mesh(mesh_pymeshlab)
    ms.meshing_surface_subdivision_midpoint(threshold=pymeshlab.PercentageValue(threshold))
    mesh_subdiv = intmsl.convert_from_pymeshlab(ms.current_mesh(), reconstruct_texture_from_faces=False)
    if reglue:
        mesh_subdiv = tcmesh.glue_seams(mesh_subdiv, decimals=decimals)

    return mesh_subdiv

# %% ../nbs/Python library/04b_remeshing_pymeshlab.ipynb 19
def remesh_pymeshlab(mesh, targetlen=1, iterations=10):
    """
    Remesh mesh using pymeshlab.
    
    This creates a triangulation where triangles are close to equilateral and
    everywhere the same size. Very useful to improve the output of
    marching cubes. Uses the meshing_isotropic_explicit_remeshing filter.
    
    This function erases UV information!
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    targetlen : float
        Percent value for target edge length.
    iterations : int
        Number of iterations.

    Returns
    -------
    mesh_remeshed : ObjMesh
        Simplified mesh.
    
    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    if not mesh.only_vertices:
        warnings.warn(f"Warning: texture information will be discarded", RuntimeWarning)
    
    mesh_pymeshlab = intmsl.convert_to_pymeshlab(mesh, add_texture_info=False)
    ms = pymeshlab.MeshSet()
    ms.add_mesh(mesh_pymeshlab)
    ms.meshing_isotropic_explicit_remeshing(iterations=iterations, targetlen=pymeshlab.PercentageValue(targetlen),
                                            splitflag=True, collapseflag=True, swapflag=True,
                                            smoothflag=True, reprojectflag=True, adaptive=False)
    mesh_pymeshlab_remeshed = ms.current_mesh()
    mesh_remeshed = intmsl.convert_from_pymeshlab(mesh_pymeshlab_remeshed, reconstruct_texture_from_faces=False)    
    return mesh_remeshed

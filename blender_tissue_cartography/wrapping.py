# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03b_wrapping.ipynb.

# %% auto 0
__all__ = ['get_uniform_laplacian', 'smooth_laplacian', 'smooth_laplacian_texture', 'smooth_taubin', 'shrinkwrap_igl',
           'smooth_laplacian_on_surface', 'transfer_per_vertex_attribute']

# %% ../nbs/03b_wrapping.ipynb 1
from . import io as tcio
from . import registration as tcreg

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import sparse

# %% ../nbs/03b_wrapping.ipynb 17
def get_uniform_laplacian(tris, normalize=True):
    """
    Get uniform Laplacian (purely connectivity based) as sparse matrix.
    
    If normalize, the diagonal = -1. Else, diagonal equals number of neighbors.
    """
    a = igl.adjacency_matrix(tris)
    a_sum = np.squeeze(np.asarray(a.sum(axis=1)))
    a_diag = sparse.diags(a_sum)
    if normalize:
        return sparse.diags(1/a_sum)@(a - a_diag)
    return (a - a_diag)

# %% ../nbs/03b_wrapping.ipynb 18
def smooth_laplacian(mesh: tcio.ObjMesh, lamb=0.5, n_iter=10, method="explicit") -> tcio.ObjMesh:
    """
    Smooth mesh vertex positions using Laplacian filter.
    
    Assumes mesh is triangular.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    lamb : float, default 0.5
        Filter strength. Higher = more smoothing.
    n_iter : int
        Filter iterations
    method : str, default "explicit"
        Can use explicit (fast, simple) or implicit (slow, more accurate) method.

    Returns
    -------
    mesh_smoothed : ObjMesh
        Smoothed mesh.

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    v_smoothed = np.copy(mesh.vertices)
    f = mesh.tris
    if method == "implicit":
        laplacian = igl.cotmatrix(v_smoothed, f)
        for _ in range(n_iter):
            mass = igl.massmatrix(v_smoothed, f, igl.MASSMATRIX_TYPE_BARYCENTRIC)
            v_smoothed = sparse.linalg.spsolve(mass - lamb * laplacian, mass.dot(v_smoothed))
    elif method == "explicit":
        laplacian_uniform = get_uniform_laplacian(f)
        for _ in range(n_iter):
            v_smoothed += lamb*laplacian_uniform.dot(v_smoothed)
    mesh_smoothed = tcio.ObjMesh(v_smoothed, mesh.faces, texture_vertices=mesh.texture_vertices,
                                 normals=None, name=mesh.name)
    mesh_smoothed.set_normals()
    return mesh_smoothed

# %% ../nbs/03b_wrapping.ipynb 19
def smooth_laplacian_texture(mesh: tcio.ObjMesh, lamb=0.5, n_iter=10,) -> tcio.ObjMesh:
    """
    Smooth mesh texture positions using Laplacian filter.
    
    Assumes mesh is triangular.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    lamb : float, default 0.5
        Filter strength. Higher = more smoothing.
    n_iter : int
        Filter iterations

    Returns
    -------
    mesh_smoothed : ObjMesh
        Smoothed mesh.

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    v_smoothed = np.copy(mesh.texture_vertices)
    f = mesh.texture_tris
    laplacian_uniform = get_uniform_laplacian(f)
    for _ in range(n_iter):
        v_smoothed += lamb*laplacian_uniform.dot(v_smoothed)
    mesh_smoothed = tcio.ObjMesh(mesh.vertices, mesh.faces, texture_vertices=v_smoothed,
                                 normals=mesh.normals, name=mesh.name)
    return mesh_smoothed

# %% ../nbs/03b_wrapping.ipynb 22
def smooth_taubin(mesh: tcio.ObjMesh, lamb=0.5, nu=0.53, n_iter=10,) -> tcio.ObjMesh:
    """
    Smooth using Taubin filter (like Laplacian, but avoids shrinkage).
    
    Assumes mesh is triangular. See   "Improved Laplacian Smoothing of Noisy Surface Meshes"
    J. Vollmer, R. Mencl, and H. Muller.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    lamb : float, default 0.5
        Filter strength. Higher = more smoothing.
    nu : float, default 0.53
        Counteract shrinkage. Higher = more dilation.
    n_iter : int
        Filter iterations

    Returns
    -------
    mesh_smoothed : ObjMesh
        Smoothed mesh.

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    v_smoothed = np.copy(mesh.vertices)
    laplacian_uniform = get_uniform_laplacian(mesh.tris)
    for _ in range(n_iter):
        v_smoothed += lamb*laplacian_uniform.dot(v_smoothed)
        v_smoothed -= nu*laplacian_uniform.dot(v_smoothed)
    mesh_smoothed = tcio.ObjMesh(v_smoothed, mesh.faces, texture_vertices=mesh.texture_vertices,
                                 normals=None, name=mesh.name)
    mesh_smoothed.set_normals()
    return mesh_smoothed

# %% ../nbs/03b_wrapping.ipynb 32
def shrinkwrap_igl(mesh_source, mesh_target, n_iter_smooth_target=10, n_iter_smooth_wrapped=10):
    """
    Shrink-wrap the source mesh onto the target mesh using trimesh.
    
    Sets the vertex positions of mesh_source to the closes point on the surface of mesh_target (not necessarily
    a vertex). Optionally, smoothes the target mesh and the wrapped mesh for smoother results using a Taubin
    filter (recommended). Gives out a warning if the shrink-wrapping flips any vertex normals, which can
    indicate problems.
    
    The shrinkwrapped mesh still has the UV maps of the source mesh, and so can be used to compute
    cartographic projections. Assumes mesh is triangular.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh to be deformed
    mesh_target : tcio.ObjMesh
        Mesh with target shape
    n_iter_smooth_target : int, default 10
        Taubin smoothing iterations for target
    n_iter_smooth_wrapped : int, default 10
        Taubin smoothing iterations for shrinkwrapped mesh, after shrinkwrapping

    Returns
    -------
    mesh_wrapped : tcio.ObjMesh

    """
    if not mesh_target.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    # smooth if necessary
    if n_iter_smooth_target > 0:
        target_verts = smooth_taubin(mesh_target, n_iter=n_iter_smooth_target).vertices
    else:
        target_verts = mesh_target.vertices
    # compute closest point on target mesh for each source vertex
    distances, indices, points = igl.point_mesh_squared_distance(mesh_source.vertices,
                                                                 target_verts, mesh_target.tris)
    # create wrapped mesh
    mesh_wrapped = tcio.ObjMesh(points, mesh_source.faces, texture_vertices=mesh_source.texture_vertices,
                                normals=None, name=mesh_source.name)
    mesh_wrapped.set_normals()
    if n_iter_smooth_wrapped > 0:
        mesh_wrapped = smooth_taubin(mesh_wrapped, n_iter=n_iter_smooth_wrapped)
    # check if any normals were flipped
    dots = np.einsum("vi,vi->v", mesh_source.normals, mesh_wrapped.normals)
    if np.sum(dots < 0) > 0:
        warnings.warn(f"Warning: {np.sum(dots<0)} normal(s) flipped during shrink-wrapping", RuntimeWarning)
    return mesh_wrapped

# %% ../nbs/03b_wrapping.ipynb 36
def smooth_laplacian_on_surface(mesh: tcio.ObjMesh, n_iter=10, lamb=0.5, n_iter_laplace=10) -> tcio.ObjMesh:
    """
    Smooth mesh vertex positions using Laplacian filter and project vertices back to original surface.
    
    Alternates between Laplacian smoothing and projecting back to original surface. Uses
    explicit method for Laplactian smoothing
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    n_iter : int
        Number of iterations at each step
    lamb : float, default 0.5
        Filter strength. Higher = more smoothing.
    n_iter_laplace : int
        Laplace filter iterations. If reprojection messes upt your mesh, decrease this number.

    Returns
    -------
    mesh_smoothed : ObjMesh
        Smoothed mesh.

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular - result may be incorrect", RuntimeWarning)
    mesh_reference = deepcopy(mesh)
    mesh_smoothed = deepcopy(mesh)
    for _ in range(n_iter):
        mesh_smoothed = smooth_laplacian(mesh_smoothed, lamb=lamb, n_iter=n_iter_laplace, method="explicit")
        mesh_smoothed = shrinkwrap_igl(mesh_smoothed, mesh_reference,
                                       n_iter_smooth_target=0, n_iter_smooth_wrapped=0)
        mesh_reference = mesh_smoothed
    mesh_smoothed.set_normals()
    return mesh_smoothed

# %% ../nbs/03b_wrapping.ipynb 41
def transfer_per_vertex_attribute(source_vertices, target_vertices, target_faces, attribute):
    """
    Transfer a per-vertex attribute from one mesh to another via barycentric interpolation.
    
    For each point among the source vertices, find the closest point on the target mesh
    (not necessarily a target vertex!), and find the value of the per-target-vertex
    attribute "attribute" via barycentric interpolation.
    
    This can be used to copy e.g. 3d coordinates from one mesh to another given 
    a common paramatrization (e.g. to disk or sphere).
    
    Parameters
    ----------
    source_vertices : np.array of shape (..., 3)
        Vertices onto which to transfer the attribute
    target_vertices : np.array of shape (..., 3)
        Vertices on which the attribute is defined
    target_faces : np.arraay of shape (..., 3)
        Triangular faces of target mesh, indices into the target_vertices array
    attribute : np.array
        Must have same length of axis 0 as target_vertices
        
    Returns
    -------
    transfered_attribute : np.array
        Same length of axis 0 as source_vertices.
    
    """
    distances, indices, points = igl.point_mesh_squared_distance(source_vertices, target_vertices, target_faces)
    hit_tris = target_faces[indices]
    # barycentric coordinates of the hit points. need small hack for data type issue 
    barycentric = igl.barycentric_coordinates_tri(np.array(points, order="C"),
                                                 *np.array(target_vertices[hit_tris].transpose((1,0,2)), order='C'))
    interpolated = np.einsum('vt,vt...->v...', barycentric, attribute[hit_tris])
    return interpolated

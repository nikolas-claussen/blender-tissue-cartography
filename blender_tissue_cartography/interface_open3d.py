# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01c_interface_open3d.ipynb.

# %% auto 0
__all__ = ['convert_to_open3d', 'convert_from_open3d']

# %% ../nbs/01c_interface_open3d.ipynb 1
from . import io as tcio
import numpy as np
import open3d as o3d
import warnings

# %% ../nbs/01c_interface_open3d.ipynb 5
def convert_to_open3d(mesh: tcio.ObjMesh, add_texture_info=None) -> o3d.t.geometry.TriangleMesh:
    """
    Convert tcio.ObjMesh to open3d.t.geometry.TriangleMesh.
    
    See https://www.open3d.org/docs/latest/python_api/open3d.t.geometry.TriangleMesh.html
    Note: open3d stores its texture coordinates generally as face attributes.
    The returned mesh has a face attribute mesh_o3d.triangle.texture_uvs if 
    texture info is provided. Normals are recomputed by open3d.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Input mesh
    add_texture_info : None or bool
        Whether to add texture info. If None, texture is added if available
        for all vertices. If True, missing texture info is set to np.nan
    Returns
    -------
    mesh_o3d: o3d.t.geometry.TriangleMesh

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular. discarding non-triangular faces")
    add_texture_info = (not np.isnan(mesh.vertex_textures).any()
                        if add_texture_info is None else add_texture_info)
    
    dtype_f = o3d.core.float32
    dtype_i = o3d.core.int32
    mesh_o3d = o3d.t.geometry.TriangleMesh()
    
    mesh_o3d.triangle.indices = o3d.core.Tensor(mesh.tris, dtype_i)
    mesh_o3d.vertex.positions = o3d.core.Tensor(mesh.vertices, dtype_f)
    if add_texture_info:
        mesh_o3d.triangle.texture_uvs = o3d.core.Tensor(tcio.index_else_nan(mesh.texture_vertices,
                                                                            mesh.texture_tris), dtype_f)
    return mesh_o3d

# %% ../nbs/01c_interface_open3d.ipynb 16
def convert_from_open3d(mesh: o3d.t.geometry.TriangleMesh, reconstruct_texture_from_faces=None,
                        texture_vertex_decimals=10) -> tcio.ObjMesh:
    """
    Convert open3d mesh to ObjMesh.
    
    Automatically recomputes vertex normals.
    
    Parameters
    ----------
    mesh : o3d.t.geometry.TriangleMesh
        Input mesh
    reconstruct_texture_from_faces : None or bool
        Whether to reconstruct the texture info
    texture_vertex_decimals : int, default 10
        Decimals UV vertices are rounded to. Needed to merge potential duplicate vertices
        for an economic representation.
    
    Returns
    -------
    tcio.ObjMesh

    """
    if isinstance(mesh, o3d.geometry.TriangleMesh): # legacy ...
        vertices = np.asarray(mesh.vertices)
        mesh.compute_vertex_normals()
        normals = np.asarray(mesh.vertex_normals)
        normals = (normals.T / np.linalg.norm(normals, axis=-1)).T
        face_matrix = np.asarray(mesh.triangles)
        if reconstruct_texture_from_faces is None:
            reconstruct_texture_from_faces = hasattr(mesh, 'triangle_uvs')
        if not reconstruct_texture_from_faces:
            faces = [[3*[v,] for v in f] for f in face_matrix]
            return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals)
        texture_vertices = np.asarray(mesh.triangle_uvs).reshape(-1,3,2).reshape(-1, 2, order='F')
        texture_vertices = np.round(texture_vertices, decimals=texture_vertex_decimals)
        texture_vertices_unique, inverse_index = np.unique(texture_vertices, axis=0, return_inverse=True)

        n_faces = face_matrix.shape[0]
        faces = [[[v, inverse_index[ifc+iv*n_faces], v] for iv, v in enumerate(fc)]
                 for ifc, fc in enumerate(face_matrix)]

        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals,
                            texture_vertices=texture_vertices_unique)
    else:    
        vertices = mesh.vertex.positions.numpy()
        mesh.compute_vertex_normals()
        normals = mesh.vertex.normals.numpy()
        normals = (normals.T / np.linalg.norm(normals, axis=-1)).T
        face_matrix = mesh.triangle.indices.numpy()
        if reconstruct_texture_from_faces is None:
            reconstruct_texture_from_faces = "texture_uvs" in mesh.triangle

        if not reconstruct_texture_from_faces:
            faces = [[3*[v,] for v in f] for f in face_matrix]
            return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals)

        # reconstruct texture vertices - big pain.
        texture_vertices = mesh.triangle.texture_uvs.numpy().reshape(-1, 2, order='F')
        texture_vertices = np.round(texture_vertices, decimals=texture_vertex_decimals)
        texture_vertices_unique, inverse_index = np.unique(texture_vertices, axis=0, return_inverse=True)

        n_faces = face_matrix.shape[0]
        faces = [[[v, inverse_index[ifc+iv*n_faces], v] for iv, v in enumerate(fc)]
                 for ifc, fc in enumerate(face_matrix)]

        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals,
                            texture_vertices=texture_vertices_unique)

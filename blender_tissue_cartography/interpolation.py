# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_cartographic_interpolation.ipynb.

# %% auto 0
__all__ = ['get_cross_section_vertices_normals', 'get_uv_layout_mask_mask', 'interpolate_per_vertex_field_to_UV',
           'get_triangle_areas_in_UV', 'interpolate_3d_to_uv', 'interpolate_volumetric_data_to_uv',
           'interpolate_volumetric_data_to_uv_multilayer', 'create_cartographic_projections']

# %% ../nbs/02_cartographic_interpolation.ipynb 1
import numpy as np
from skimage import transform
from scipy import interpolate
import matplotlib as mpl
import matplotlib.pyplot as plt
from . import io as tcio
import warnings
import igl

# %% ../nbs/02_cartographic_interpolation.ipynb 23
def get_cross_section_vertices_normals(slice_axis, slice_index, image, mesh, resolution,
                                       get_normals=True, width=3):
    """
    Get mesh vertices and normals for diagnostic cross-section overlay plot.
    
    Usage example:
        slice_image, slice_vertices, slice_normals = get_cross_section_vertices_normals(1, 100,
                                    image, mesh, metadata_dict["resolution_in_microns"])
        plt.scatter(*slice_vertices.T, s=5, c="tab:red")
        plt.quiver(*slice_vertices.T, *slice_normals.T, color="tab:red")
        plt.imshow(slice_image[0], vmax=10000, origin="lower")
    
    Note: `origin="lower"` in plt.imshow() is essential for a correctly oriented plot in python!!
        
    Parameters
    ----------
    image : 4d np.ndarray of shape (channels, n_x, n_y, n_z)
        Image. Axis 0 is channel
    mesh : tcio.ObjMesh
        Mesh
    resolution : int, default 256
        Resolution in pixels/micron.
    slice_index : int
        Index along sliced axis
    slice_axis : int, 0,1,2
        Axis along which to slice image array
    get_normals : bool, default True
        Whether to return normals also
    width : float
        Width of slice for vertex selection, in micron
    
    Returns
    -------
    slice_image : 3d np.array 
        Slice of image. Axis 0 is channel
    slice_vertices : 2d  np.array
        Projected vertices in slice. Second axis is the coordinate one.
    slice_normals : 2d  np.array (..., 2)
        Projected normals in slice. Second axis is the coordinate one.

    """
    slice_image = image.take(indices=slice_index, axis=slice_axis+1).transpose((0,2,1))
    slice_coordinate = slice_index*resolution[slice_axis]
    if get_normals:
        slice_mask = np.abs(mesh.vertices[:,slice_axis]-slice_coordinate) < width
        slice_vertices = mesh.vertices[slice_mask] / resolution
        slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        slice_normals = mesh.normals[slice_mask] / resolution
        slice_normals = slice_normals.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        return slice_image, slice_vertices, slice_normals
    slice_mask = np.abs(mesh.vertices[:,slice_axis]-slice_coordinate) < width
    slice_vertices = mesh.vertices[slice_mask] / resolution
    slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
    return slice_image, slice_vertices

# %% ../nbs/02_cartographic_interpolation.ipynb 35
def get_uv_layout_mask_mask(mesh: tcio.ObjMesh, uv_grid_steps=256):
    """
    Get a layout mask of the UV square: 1 where the UV square is covered by the unwrapped mesh, 0 outside.
    
    Based on matplotlib hack.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh with texture_vertices
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    
    Returns
    -------
    uv_mask : np.array of shape (uv_grid_steps, uv_grid_steps)
        Mask of the part of the UV square covered by the unwrapped mesh
    """
    assert mesh.texture_vertices is not None, "mesh must have texture vertices"
    fig = plt.figure(figsize=(1,1), dpi=uv_grid_steps, frameon=False)
    ax = plt.gca()
    if not mesh.is_triangular:
        valid_faces = [[v[1] for v in fc] for fc in mesh.faces if not np.isnan(list(tcio.flatten(fc))).any()]
        polygons = mpl.collections.PatchCollection([mpl.patches.Polygon([mesh.texture_vertices[v] for v in fc])
                                                    for fc in valid_faces], color="black")
        ax.add_collection(polygons)
    else:
        ax.tripcolor(*mesh.texture_vertices.T, mesh.texture_tris, np.ones((mesh.texture_vertices.shape[0],)),
                      cmap="binary", vmin=0, vmax=1)
    ax.set_xlim([0,1])
    ax.set_ylim([0,1])
    ax.set_axis_off()
    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    fig.canvas.draw()
    uv_mask = np.frombuffer(fig.canvas.buffer_rgba(), dtype=np.uint8).astype(float)
    uv_mask = 1-(uv_mask.reshape(fig.canvas.get_width_height()[::-1] + (4,))[...,0] > 0)
    plt.close()
    
    return uv_mask.astype(bool)

# %% ../nbs/02_cartographic_interpolation.ipynb 39
def interpolate_per_vertex_field_to_UV(mesh, field, domain="per-vertex", uv_grid_steps=256, map_back=True,
                                       use_mesh_triangulation=True):
    """
    Interpolate a field defined per-vertex into the UV square.
    
    The field can be defined per texture-vertex or per 3d-vertex. Make sure you use the right option!
    field[mesh.get_uv_matched_vertex_indices()]
    
    Assumes the map $x,y,z \mapsto u,v$ to be invertible. This is not guaranteed - you can create overlapping UV 
    coordinates in blender. The provided UV coordinates will be mapped back to [0, 1]^2 if map_back is True.
    Else, coordinates outside [0,1] are ignored.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Input mesh with UV coordinates.
    field : np.array of shape (mesh.texture_vertices.shape[0],...)
        Input field. Can be an array with one or two axes (i.e. scalar or vector field).
    domain : "per-vertex" or "per-texture-vertex"
        Whether the field is defined per-vertex or per texture vertex.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.
    use_mesh_triangulation : bool
        Use the mesh triangulation to carry out interpolation. If False, a new Delaunay triangulation
        is computed for interpolation. This can be useful if there are flipped triangles in the UV map.

    Returns
    -------
    interpolated : np.array of shape (uv_grid_steps, uv_grid_steps)
        Field across [0,1]^2 UV grid, with uniform step size. UV positions that don't
        correspond to any value are set to np.nan.
        
    """
    if domain == "per-vertex":
        field = field[mesh.get_uv_matched_vertex_indices()]
    texture_vertices = np.copy(mesh.texture_vertices)
    if map_back:
        outside = (texture_vertices<0) | (texture_vertices > 1)
        texture_vertices[outside] = (texture_vertices[outside] % 1)
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    if use_mesh_triangulation:
        try:
            triangulation = mpl.tri.Triangulation(*texture_vertices.T, mesh.texture_tris)
            if len(field.shape) == 1:
                interpolated = mpl.tri.LinearTriInterpolator(triangulation, field)(U,V).data[::-1]
            elif len(field.shape) == 2:
                interpolated = np.stack([mpl.tri.LinearTriInterpolator(triangulation, x)(U,V).data[::-1]
                                         for x in field.T], axis=-1)
            else:
                raise NotImplementedError("Interpolation for arrays with more than 2 axes not defined")
            return interpolated
        except RuntimeError:
            warnings.warn(f"Invalid triangulation - trying alternate interpolation method.\
            If results look bad, your mesh may be broken", RuntimeWarning)
    if len(field.shape) == 1: 
        print(texture_vertices.shape)
        interpolated = interpolate.griddata(texture_vertices, field, (U, V), method='linear')[::-1]
    elif len(scalar.shape) == 2:
        interpolated = np.stack([interpolate.griddata(texture_vertices, x, (U, V), method='linear')[::-1]
                                 for x in field.T], axis=-1)
    else:
        raise NotImplementedError("Interpolation for arrays with more than 2 axes not defined")
    uv_mask = get_uv_layout_mask_mask(mesh, uv_grid_steps=uv_grid_steps)
    interpolated[~uv_mask] = np.nan
    return interpolated

# %% ../nbs/02_cartographic_interpolation.ipynb 42
def get_triangle_areas_in_UV(mesh, which_area="ratio", uv_grid_steps=256, map_back=True):
    """
    Interpolate mesh area into the UV square.
    
    Used to measure area distortion of your cartographic mapping.
    
    Assumes the map $x,y,z \mapsto u,v$ to be invertible. This is not guaranteed
    - you can create overlapping UV coordinates in blender. The provided UV coordinates
    will be mapped back to [0, 1]^2 if map_back is True. Else, coordinates  outside [0,1] are ignored.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Input mesh with UV coordinates.
    which_area : str, "3d", "UV", or "ratio"
        Which triangle areas to compute (in 3d, UV, or the ratio 3d/UV). "ratio" option is
        useful for computing conformal map distortion.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.

    Returns
    -------
    areas_interpolated : np.array of shape (uv_grid_steps, uv_grid_steps)
        Area across [0,1]^2 UV grid, with uniform step size. UV positions that don't
        correspond to any value are set to np.nan.
        
    """
    if which_area == "3d":
        areas = igl.doublearea(mesh.vertices, mesh.tris)
    elif which_area == "UV":
        areas = igl.doublearea(mesh.texture_vertices, mesh.texture_tris)
    elif which_area == "ration":
        areas = igl.doublearea(mesh.vertices, mesh.tris)/igl.doublearea(mesh.texture_vertices, mesh.texture_tris)
    areas = igl.average_onto_vertices(mesh.texture_vertices, mesh.texture_tris, np.stack(2*[areas]).T)[:,0]
    areas_interpolated = interpolate_per_vertex_field_to_UV(mesh, areas, uv_grid_steps=uv_grid_steps,
                                                            map_back=map_back)
    return areas_interpolated

# %% ../nbs/02_cartographic_interpolation.ipynb 43
def interpolate_3d_to_uv(matched_texture_vertices, matched_vertices_or_normals,
                         mesh_triangles=None, uv_grid_steps=256, map_back=True):
    """
    Interpolate 3d mesh coordinates or mesh normals onto UV square.
    
    Assumes the map $x,y,z \mapsto u,v$ to be invertible. This is not guaranteed - you can create overlapping UV 
    coordinates in blender.
    
    The provided UV coordinates will be mapped back to [0, 1]^2 if map_back is True. Else, coordinates
    outside [0,1] are ignored.
    
    Parameters
    ----------
    matched_vertices_or_normals : np.array of shape (n_matched, 3)
        Vertex 3d coordinates or normals, matched to UV coordinates
    matched_texture_vertices : np.array of shape (n_matched, 2)
        Matched texture vertices.
    mesh_triangles : np.array of shape (n_matched, 3) or None
        Mesh faces to set up interpolator. Only works if mesh is triangular. If None,
        triangulation for interpolation is constructed automatically.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.

    Returns
    -------
    interpolated_3d : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions or normals across [0,1]^2 UV grid, with uniform step size. UV positions that don't
        correspond to any value are set to np.nan.
        
    """
    if map_back:
        outside = (matched_texture_vertices<0) | (matched_texture_vertices > 1)
        matched_texture_vertices[outside] = (matched_texture_vertices[outside] % 1)
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    if mesh_triangles is not None:
        try:
            triangulation = mpl.tri.Triangulation(*matched_texture_vertices.T, mesh_triangles)
            interpolators = [mpl.tri.LinearTriInterpolator(triangulation, x) for x in matched_vertices_or_normals.T]
            interpolated_3d = np.stack([interpolator(U,V) for interpolator in interpolators], axis=-1)[::-1]
            return interpolated_3d
        except RuntimeError:
            warnings.warn(f"Invalid triangulation - trying alternate interpolation method.\
            If results look bad, your mesh may be broken", RuntimeWarning)
    interpolated_3d = np.stack([interpolate.griddata(matched_texture_vertices, x, (U, V), method='linear')
                                for x in matched_vertices_or_normals.T], axis=-1)
    interpolated_3d = interpolated_3d[::-1] # stupid axis convention issue!!
    uv_mask = get_uv_layout_mask_mask(mesh, uv_grid_steps=uv_grid_steps)
    interpolated_3d[~uv_mask,:] = np.nan
    return interpolated_3d

# %% ../nbs/02_cartographic_interpolation.ipynb 44
def interpolate_volumetric_data_to_uv(image, interpolated_3d_positions, resolution):
    """ 
    Interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_3d_to_uv.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
        
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, uv_grid_steps, uv_grid_steps)
        3d volumetric data interpolated onto UV grid.
    
    """
    x, y, z = [np.arange(ni) for ni in image.shape[1:]]
    interpolated_data = np.stack([interpolate.interpn((x, y, z), channel, interpolated_3d_positions/resolution,
                                  method="linear", bounds_error=False) for channel in image])
    
    return interpolated_data

# %% ../nbs/02_cartographic_interpolation.ipynb 50
def interpolate_volumetric_data_to_uv_multilayer(image, interpolated_3d_positions, interpolated_normals,
                                                 normal_offsets, resolution):
    """ 
    Multilayer-interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_3d_to_uv.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Generates multiple "layers" by shifting surface along its normals.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d normals across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan. Normal vectors will be automatically normalized.
    normal_offsets : np.array of shape (n_layers,)
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
    
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
        3d volumetric data multulayer-interpolated onto UV grid.
    
    """
    interpolated_normals = (interpolated_normals.T / np.linalg.norm(interpolated_normals, axis=-1).T).T
    interpolated_data = np.stack([interpolate_volumetric_data_to_uv(image,
                                  interpolated_3d_positions+o*interpolated_normals, resolution,)
                                  for o in normal_offsets], axis=1)
    return interpolated_data

# %% ../nbs/02_cartographic_interpolation.ipynb 56
def create_cartographic_projections(image, mesh, resolution, normal_offsets=(0,), uv_grid_steps=256,
                                    map_back=True):
    """
    Create multilayer cartographic projections of image using mesh.
    
    Computes multiple layers along surface normal, with given normal offset (in microns). 0 offset
    corresponds to no shift away from the mesh. Also computes 3d positions (in microns)
    and surface normals interpolated onto the UV grid.
    
    UV positions that don't correspond to any 3d position are set to np.nan.
    
    Parameters
    ----------
    image : str or 4d np.array
        Image, either as path to file, or as array. If array, axis 0  is assumed to be the channel axis
    mesh : str or tcio.ObjMesh
        Mesh, either as path to file, or as ObjMesh object.
    resolution : np.array of shape (3,)
        Image resolution in pixels/micron for the three spatial axes
    normal_offsets : np.array of float, optional
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.
    
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
        3d volumetric data multulayer-interpolated across [0,1]^2 UV grid, with uniform step size.
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. 
    interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        Normals across [0,1]^2 UV grid, with uniform step size.
    """
    if isinstance(image, str):
        image = tcio.adjust_axis_order(tcio.imread(image))
    if isinstance(mesh, str):
        mesh = tcio.ObjMesh.read_obj(mesh)
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    interpolated_3d_positions = interpolate_per_vertex_field_to_UV(mesh, mesh.vertices, domain="per-vertex",
                                                                   uv_grid_steps=uv_grid_steps,
                                                                   map_back=map_back,
                                                                   use_mesh_triangulation=mesh.is_triangular)
    interpolated_normals = interpolate_per_vertex_field_to_UV(mesh, mesh.normals, domain="per-vertex",
                                                              uv_grid_steps=uv_grid_steps,
                                                              map_back=map_back,
                                                              use_mesh_triangulation=mesh.is_triangular)
    interpolated_data = interpolate_volumetric_data_to_uv_multilayer(image,
                                                                     interpolated_3d_positions,
                                                                     interpolated_normals, normal_offsets,
                                                                     resolution)
    return interpolated_data, interpolated_3d_positions, interpolated_normals 

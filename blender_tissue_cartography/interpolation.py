# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_cartographic_interpolation.ipynb.

# %% auto 0
__all__ = ['get_cross_section_vertices_normals', 'get_uv_layout_mask_mask', 'interpolate_3d_to_uv',
           'interpolate_volumetric_data_to_uv', 'interpolate_volumetric_data_to_uv_multilayer',
           'create_cartographic_projections']

# %% ../nbs/02_cartographic_interpolation.ipynb 1
import numpy as np
from skimage import transform
from scipy import interpolate
import matplotlib as mpl
import matplotlib.pyplot as plt
from . import io as tcio
import warnings

# %% ../nbs/02_cartographic_interpolation.ipynb 19
def get_cross_section_vertices_normals(slice_axis, slice_index, image, mesh, resolution,
                                       get_normals=True, width=3):
    """
    Get mesh vertices and normals for diagnostic cross-section overlay plot.
    
    Usage example:
        slice_image, slice_vertices, slice_normals = get_cross_section_vertices_normals(1, 100,
                                    image, mesh, metadata_dict["resolution_in_microns"])
        plt.scatter(*slice_vertices.T, s=5, c="tab:red")
        plt.quiver(*slice_vertices.T, *slice_normals.T, color="tab:red")
        plt.imshow(slice_image[0], vmax=10000, origin="lower")
    
    Note: `origin="lower"` in plt.imshow() is essential for a correctly oriented plot in python!!
        
    Parameters
    ----------
    image : 4d np.ndarray of shape (channels, n_x, n_y, n_z)
        Image. Axis 0 is channel
    mesh : tcio.ObjMesh
        Mesh
    resolution : int, default 256
        Resolution in pixels/micron.
    slice_index : int
        Index along sliced axis
    slice_axis : int, 0,1,2
        Axis along which to slice image array
    get_normals : bool, default True
        Whether to return normals also
    width : float
        Width of slice for vertex selection, in micron
    
    Returns
    -------
    slice_image : 3d np.array 
        Slice of image. Axis 0 is channel
    slice_vertices : 2d  np.array
        Projected vertices in slice. Second axis is the coordinate one.
    slice_normals : 2d  np.array (..., 2)
        Projected normals in slice. Second axis is the coordinate one.

    """
    slice_image = image.take(indices=slice_index, axis=slice_axis+1).transpose((0,2,1))
    slice_coordinate = slice_index*resolution[slice_axis]
    if get_normals:
        mesh.match_vertex_info()
        slice_mask = np.abs(mesh.matched_vertices[:,slice_axis]-slice_coordinate) < width
        slice_vertices = mesh.matched_vertices[slice_mask] / resolution
        slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        slice_normals = mesh.matched_normals[slice_mask] / resolution
        slice_normals = slice_normals.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        return slice_image, slice_vertices, slice_normals
    slice_mask = np.abs(mesh.vertices[:,slice_axis]-slice_coordinate) < width
    slice_vertices = mesh.vertices[slice_mask] / resolution
    slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
    return slice_image, slice_vertices

# %% ../nbs/02_cartographic_interpolation.ipynb 31
def get_uv_layout_mask_mask(mesh: tcio.ObjMesh, uv_grid_steps=256):
    """
    Get a layout mask of the UV square: 1 where the UV square is covered by the unwrapped mesh, 0 outside.
    
    Based on matplotlib hack.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh with texture_vertices
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    
    Returns
    -------
    uv_mask : np.array of shape (uv_grid_steps, uv_grid_steps)
        Mask of the part of the UV square covered by the unwrapped mesh
    """
    assert mesh.texture_vertices is not None, "mesh must have texture vertices"
    fig = plt.figure(figsize=(1,1), dpi=uv_grid_steps, frameon=False)
    ax = plt.gca()
    if not mesh.is_triangular:
        valid_faces = [[v[1] for v in fc] for fc in mesh.faces if not np.isnan(list(tcio.flatten(fc))).any()]
        polygons = mpl.collections.PatchCollection([mpl.patches.Polygon([mesh.texture_vertices[v] for v in fc])
                                                    for fc in valid_faces], color="black")
        ax.add_collection(polygons)
    else:
        ax.tripcolor(*mesh.texture_vertices.T, mesh.texture_tris, np.ones((mesh.texture_vertices.shape[0],)),
                      cmap="binary", vmin=0, vmax=1)
    ax.set_xlim([0,1])
    ax.set_ylim([0,1])
    ax.set_axis_off()
    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    fig.canvas.draw()
    uv_mask = np.frombuffer(fig.canvas.buffer_rgba(), dtype=np.uint8).astype(float)
    uv_mask = 1-(uv_mask.reshape(fig.canvas.get_width_height()[::-1] + (4,))[...,0] > 0)
    plt.close()
    
    return uv_mask.astype(bool)

# %% ../nbs/02_cartographic_interpolation.ipynb 35
def interpolate_3d_to_uv(matched_texture_vertices, matched_vertices_or_normals,
                         mesh_triangles=None, uv_mask=None, uv_grid_steps=256, map_back=True):
    """
    Interpolate 3d mesh coordinates or mesh normals onto UV square.
    
    Assumes the map $x,y,z \mapsto u,v$ to be invertible. This is not guaranteed - you can create overlapping UV 
    coordinates in blender.
    
    The provided UV coordinates will be mapped back to [0, 1]^2 if map_back is True. Else, coordinates
    outside [0,1] are ignored.
    
    Parameters
    ----------
    matched_vertices_or_normals : np.array of shape (n_matched, 3)
        Vertex 3d coordinates or normals, matched to UV coordinates
    matched_texture_vertices : np.array of shape (n_matched, 2)
        Matched texture vertices.
    mesh_triangles : np.array of shape (n_matched, 3) or None
        Mesh faces to set up interpolator. Only works if mesh is triangular. If None,
        triangulation for interpolation is constructed automatically.
    uv_mask : None or np.array of shape (uv_grid_steps, uv_grid_steps) of dtype bool
        Used if mesh_triangles is None - mask of covered part of the UV square. If provided,
        interpolation results are set to np.nan outside the covered region. If None, no masking
        takes place. No masking may result in spurious results in the part of the UV square not
        covered by the unwrapped mesh. If mesh_triangles is provided, masking happens automatically.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.

    Returns
    -------
    interpolated_3d : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions or normals across [0,1]^2 UV grid, with uniform step size. UV positions that don't
        correspond to any value are set to np.nan.
        
    """
    if map_back:
        outside = (matched_texture_vertices<0) | (matched_texture_vertices > 1)
        matched_texture_vertices[outside] = (matched_texture_vertices[outside] % 1)
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    if mesh_triangles is not None:
        try:
            triangulation = mpl.tri.Triangulation(*matched_texture_vertices.T, mesh_triangles)
            interpolators = [mpl.tri.LinearTriInterpolator(triangulation, x) for x in matched_vertices_or_normals.T]
            interpolated_3d = np.stack([interpolator(U,V) for interpolator in interpolators], axis=-1)[::-1]
            return interpolated_3d
        except RuntimeError:
            warnings.warn(f"Invalid triangulation - trying alternate interpolation method.\
            If results look bad, your mesh may be broken", RuntimeWarning)
    interpolated_3d = np.stack([interpolate.griddata(matched_texture_vertices, x, (U, V), method='linear')
                                for x in matched_vertices_or_normals.T], axis=-1)
    interpolated_3d = interpolated_3d[::-1] # stupid axis convention issue!!
    if uv_mask is not None:
        interpolated_3d[~uv_mask,:] = np.nan
    return interpolated_3d

# %% ../nbs/02_cartographic_interpolation.ipynb 36
def interpolate_volumetric_data_to_uv(image, interpolated_3d_positions, resolution, uv_mask=None):
    """ 
    Interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_3d_to_uv.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
    uv_mask : None or np.array of shape (uv_grid_steps, uv_grid_steps) of dtype bool
        Used only for non-triangular meshes -mask of covered part of the UV square. If provided,
        interpolation results are set to np.nan outside the covered region. If None, no masking
        takes place. No masking may result in spurious results in the part of the UV square not
        covered by the unwrapped mesh. For triangular mesh, masking happens automatically.
        
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, uv_grid_steps, uv_grid_steps)
        3d volumetric data interpolated onto UV grid.
    
    """
    x, y, z = [np.arange(ni) for ni in image.shape[1:]]
    interpolated_data = np.stack([interpolate.interpn((x, y, z), channel, interpolated_3d_positions/resolution,
                                  method="linear", bounds_error=False) for channel in image])
    if uv_mask is not None:
        interpolated_data[:,~uv_mask] = np.nan
    
    return interpolated_data

# %% ../nbs/02_cartographic_interpolation.ipynb 44
def interpolate_volumetric_data_to_uv_multilayer(image, interpolated_3d_positions, interpolated_normals,
                                                 normal_offsets, resolution, uv_mask=None):
    """ 
    Multilayer-interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_3d_to_uv.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Generates multiple "layers" by shifting surface along its normals.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d normals across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan. Normal vectors will be automatically normalized.
    normal_offsets : np.array of shape (n_layers,)
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
    uv_mask : None or np.array of shape (uv_grid_steps, uv_grid_steps) of dtype bool
        Used only for non-triangular meshes -mask of covered part of the UV square. If provided,
        interpolation results are set to np.nan outside the covered region. If None, no masking
        takes place. No masking may result in spurious results in the part of the UV square not
        covered by the unwrapped mesh. For triangular mesh, masking happens automatically.
    
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
        3d volumetric data multulayer-interpolated onto UV grid.
    
    """
    interpolated_normals = (interpolated_normals.T / np.linalg.norm(interpolated_normals, axis=-1).T).T
    interpolated_data = np.stack([interpolate_volumetric_data_to_uv(image,
                                  interpolated_3d_positions+o*interpolated_normals, resolution, uv_mask=uv_mask)
                                  for o in normal_offsets], axis=1)
    return interpolated_data

# %% ../nbs/02_cartographic_interpolation.ipynb 50
def create_cartographic_projections(image, mesh, resolution, normal_offsets=(0,), uv_grid_steps=256,
                                    uv_mask='auto', map_back=True):
    """
    Create multilayer cartographic projections of image using mesh.
    
    Computes multiple layers along surface normal, with given normal offset (in microns). 0 offset
    corresponds to no shift away from the mesh. Also computes 3d positions (in microns)
    and surface normals interpolated onto the UV grid.
    
    UV positions that don't correspond to any 3d position are set to np.nan.
    
    Parameters
    ----------
    image : str or 4d np.array
        Image, either as path to file, or as array. If array, axis 0  is assumed to be the channel axis
    mesh : str or tcio.ObjMesh
        Mesh, either as path to file, or as ObjMesh object.
    resolution : np.array of shape (3,)
        Image resolution in pixels/micron for the three spatial axes
    normal_offsets : np.array of float, optional
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    uv_mask : str, None, or np.array of shape (uv_grid_steps, uv_grid_steps) and dtype bool
        Mask of covered part of the UV square. Interpolation results are set to np.nan outside the
        covered region. If "auto", mask is infered automatically from the mesh information.
        If None, no masking takes place. No masking may result in spurious results in the part of
        the UV square not covered by the unwrapped mesh. Can be obtained manually from exported
        blender UV layout.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.
    
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
        3d volumetric data multulayer-interpolated across [0,1]^2 UV grid, with uniform step size.
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. 
    interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        Normals across [0,1]^2 UV grid, with uniform step size.
    """
    if isinstance(image, str):
        image = tcio.adjust_axis_order(tcio.imread(image))
    if isinstance(mesh, str):
        mesh = tcio.ObjMesh.read_obj(mesh)
    mesh.match_vertex_info()
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    with warnings.catch_warnings(): # deal with warning if interpolator fails
        warnings.simplefilter("error")
        if mesh.is_triangular:
            try:
                warnings.simplefilter("always")
                interpolated_3d_positions = interpolate_3d_to_uv(mesh.matched_texture_vertices,
                                                                 mesh.matched_vertices,
                                                                 mesh_triangles=mesh.texture_tris,
                                                                 uv_grid_steps=uv_grid_steps,
                                                                 map_back=map_back)
                interpolated_normals = interpolate_3d_to_uv(mesh.matched_texture_vertices, mesh.matched_normals,
                                                            mesh_triangles=mesh.texture_tris,
                                                            uv_grid_steps=uv_grid_steps,
                                                            map_back=map_back)
                interpolated_data = interpolate_volumetric_data_to_uv_multilayer(image,
                                                                                 interpolated_3d_positions,
                                                                                 interpolated_normals,
                                                                                 normal_offsets,
                                                                                 resolution, uv_mask=None)
                return interpolated_data, interpolated_3d_positions, interpolated_normals 
            except RuntimeWarning:
                pass
        if (uv_mask == "auto"):
            uv_mask = get_uv_layout_mask_mask(mesh, uv_grid_steps=uv_grid_steps)
        interpolated_3d_positions = interpolate_3d_to_uv(mesh.matched_texture_vertices, mesh.matched_vertices,
                                                         mesh_triangles=None,
                                                         uv_grid_steps=uv_grid_steps, uv_mask=uv_mask,
                                                         map_back=map_back)
        interpolated_normals = interpolate_3d_to_uv(mesh.matched_texture_vertices, mesh.matched_normals,
                                                    mesh_triangles=None,
                                                    uv_grid_steps=uv_grid_steps, uv_mask=uv_mask,
                                                    map_back=map_back)
        interpolated_data = interpolate_volumetric_data_to_uv_multilayer(image,
                                                                         interpolated_3d_positions,
                                                                         interpolated_normals, normal_offsets,
                                                                         resolution, uv_mask=uv_mask)
        return interpolated_data, interpolated_3d_positions, interpolated_normals 

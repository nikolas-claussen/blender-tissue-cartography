# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/02_cartographic_interpolation.ipynb.

# %% auto 0
__all__ = ['get_cross_section_vertices_normals', 'get_uv_layout_mask_mask', 'interpolate_barycentric',
           'interpolate_per_vertex_field_to_UV', 'interpolate_UV_to_per_vertex_field',
           'interpolate_volumetric_data_to_uv', 'interpolate_volumetric_data_to_uv_multilayer',
           'create_cartographic_projections']

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 2
import numpy as np
from skimage import transform
from scipy import interpolate
import matplotlib as mpl
import matplotlib.pyplot as plt
from . import io as tcio
from . import mesh as tcmesh
from . import remesh as tcremesh

import warnings
import igl

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 22
def get_cross_section_vertices_normals(slice_axis, slice_index, image, mesh, resolution,
                                       get_normals=True, width=3):
    """
    Get mesh vertices and normals for diagnostic cross-section overlay plots.
    
    Usage example:
    
        `
        slice_image, slice_vertices, slice_normals = get_cross_section_vertices_normals(1, 100,
                                    image, mesh, metadata_dict["resolution_in_microns"])
        plt.scatter(*slice_vertices.T, s=5, c="tab:red")
        plt.quiver(*slice_vertices.T, *slice_normals.T, color="tab:red")
        plt.imshow(slice_image[0], vmax=10000, origin="lower")
        `
    
    Note: `origin="lower"` in plt.imshow() is essential for a correctly oriented plot in Python!!
        
    Parameters
    ----------
    image : 4d np.ndarray of shape (channels, n_x, n_y, n_z)
        Image. Axis 0 is channel
    mesh : tcmesh.ObjMesh
        Mesh
    resolution : int, default 256
        Resolution in pixels/micron.
    slice_index : int
        Index along the sliced axis
    slice_axis : int, 0,1,2
        Axis along which to slice image array
    get_normals : bool, default True
        Whether to return normals also
    width : float
        Width of slice for vertex selection, in microns
    
    Returns
    -------
    np.array, np.array, np.array
        slice_image : np.array 
            Slice of image. Axis 0 is channel
        slice_vertices : np.array
            Projected vertices in the slice. The second axis is the coordinate one.
        slice_normals : 2d  np.array (..., 2)
            Projected normals in slice. The second axis is the coordinate one."""
    slice_image = image.take(indices=slice_index, axis=slice_axis+1).transpose((0,2,1))
    slice_coordinate = slice_index*resolution[slice_axis]
    if get_normals:
        slice_mask = np.abs(mesh.vertices[:,slice_axis]-slice_coordinate) < width
        slice_vertices = mesh.vertices[slice_mask] / resolution
        slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        slice_normals = mesh.normals[slice_mask] / resolution
        slice_normals = slice_normals.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
        return slice_image, slice_vertices, slice_normals
    slice_mask = np.abs(mesh.vertices[:,slice_axis]-slice_coordinate) < width
    slice_vertices = mesh.vertices[slice_mask] / resolution
    slice_vertices = slice_vertices.take(indices=[i for i in range(3) if i != slice_axis], axis=1)
    return slice_image, slice_vertices

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 33
def get_uv_layout_mask_mask(mesh: tcmesh.ObjMesh, uv_grid_steps=256):
    """
    Get a layout mask of the UV square: 1 where the UV square is covered by the unwrapped mesh, 0 outside.
    
    Based on matplotlib hack - this function works for non-triangular meshes.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Mesh with texture_vertices
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    
    Returns
    -------
    uv_mask : np.array of shape (uv_grid_steps, uv_grid_steps)
        Mask of the part of the UV square covered by the unwrapped mesh
    """
    assert mesh.texture_vertices is not None, "mesh must have texture vertices"
    fig = plt.figure(figsize=(1,1), dpi=uv_grid_steps, frameon=False)
    ax = plt.gca()
    if not mesh.is_triangular:
        valid_faces = [[v[1] for v in fc] for fc in mesh.faces if not np.isnan(list(tcmesh.flatten(fc))).any()]
        polygons = mpl.collections.PatchCollection([mpl.patches.Polygon([mesh.texture_vertices[v] for v in fc])
                                                    for fc in valid_faces], color="black")
        ax.add_collection(polygons)
    else:
        ax.tripcolor(*mesh.texture_vertices.T, mesh.texture_tris, np.ones((mesh.texture_vertices.shape[0],)),
                      cmap="binary", vmin=0, vmax=1)
    ax.set_xlim([0,1])
    ax.set_ylim([0,1])
    ax.set_axis_off()
    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    fig.canvas.draw()
    uv_mask = np.frombuffer(fig.canvas.buffer_rgba(), dtype=np.uint8).astype(float)
    uv_mask = 1-(uv_mask.reshape(fig.canvas.get_width_height()[::-1] + (4,))[...,0] > 0)
    plt.close()
    
    return uv_mask.astype(bool)

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 35
def interpolate_barycentric(points, vertices, faces, values, distance_threshold=np.inf):
    """
    Interpolate values defined on triangular mesh vertices onto points using barycentric interpolation.
    
    Can handle triangular meshes in both 3d and 2d. Points not on the triangular mesh
    are projected onto the closest point. Points more distant than the distance_threshold
    will be set to np.nan. The data on the triangular mesh must be defined per vertex
    and can have any number of axes (scalars, vectors, tensors, ...).
    
    This function can also be used to transfer values defined on one mesh to another mesh's
    vertices (if the two meshes are well-aligned in space).
    
    Parameters
    ----------
    points : np.array of shape (n_points, 2) or (n_points, 3)
        Points at which to evaluate
    vertices : np.array of shape (n_vertices, 2) or (n_vertices, 3)
        Mesh vertices
    faces : np.array of shape (n_faces, 3)
        Mesh triangles, indices into vertices array
    values : np.array of shape (n_vertices, ...)
        Values at mesh vertices. Can have any number of additional axes.
    distance_threshold : float
        Points with a squared distance to mesh > distance_threshold
        are set to np.nan
        
    Returns
    -------
    interpolated : np.array of shape (n_points, ...)
        Values at points.

    """
    assert vertices.shape[1] in [2,3], "Vertices must be 2d or 3d"
    if vertices.shape[1] == 2:
        vertices = np.pad(vertices, ((0,0), (0,1)))
        points = np.pad(points, ((0,0), (0,1)))

    # find the closest points on the mesh
    squared_distances, indices, points = igl.point_mesh_squared_distance(points, vertices, faces)
    hit_tris = faces[indices]
    # barycentric coordinates of the hit points. need small hack for data type issue 
    barycentric = igl.barycentric_coordinates_tri(np.array(points, order="C"),
                                                 *np.array(vertices[hit_tris].transpose((1,0,2)), order='C'))
    interpolated = np.einsum('vt,vt...->v...', barycentric, values[hit_tris])
    interpolated[squared_distances>distance_threshold] = np.nan
    return interpolated

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 38
def interpolate_per_vertex_field_to_UV(mesh, field, domain="per-vertex", uv_grid_steps=256, map_back=True,
                                       distance_threshold=1e-4, use_fallback=False):
    """
    Interpolate a field defined per-vertex into the UV square.
    
    The field can be defined per texture-vertex or per 3D-vertex. Make sure you use the right option!
    
    Assumes the map x,y,z -> u,v to be invertible. This is not guaranteed - you can create overlapping UV 
    coordinates in Blender.     Raises RuntimeWarning if any of the triangles in the UV map are flipped,
    indicating self-intersections.
    
    The provided UV coordinates will be mapped back to [0, 1]**2 if map_back is True.
    Else, coordinates outside [0,1] are ignored.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Input mesh with UV coordinates.
    field : np.array of shape (mesh.texture_vertices.shape[0],...)
        Input field. Can be an array with any number of axes (e.g. scalar or vector field).
    domain : "per-vertex" or "per-texture-vertex"
        Whether the field is defined per-vertex or per texture vertex.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]**2. Else, coordinates outside [0,1] are ignored.
    distance_threshold : float
        Points at a squared distance > distance_threshold in the UV square are considered
        "outside" the unwrapped mesh and are set to np.nan.
    use_fallback : bool or 'auto', default 'auto'
        Ignore mesh connectivity when interpolating. This is to be used as a fallback
        if you have a UV map with lots of flipped triangles (i.e. self-intersections).
        If 'auto', the fallback option is chosen automatically if there are any flipped 
        triangles.

    Returns
    -------
    interpolated : np.array of shape (uv_grid_steps, uv_grid_steps, ...)
        Field across [0,1]**2 UV grid, with a uniform step size. UV positions that don't
        correspond to any value are set to np.nan.
            
    """
    if domain == "per-vertex":
        field = field[mesh.get_vertex_to_texture_vertex_indices()]
    flipped_triangles = len(igl.flipped_triangles(mesh.texture_vertices, mesh.texture_tris))
    if flipped_triangles > 0:
        warnings.warn("UV map has self-intersections, {} flipped triangles. Try use_fallback=True?".format(
            flipped_triangles), RuntimeWarning)
    if use_fallback == 'auto':
        use_fallback = (flipped_triangles > 0)
    texture_vertices = np.copy(mesh.texture_vertices)
    if map_back:
        outside = (texture_vertices<0) | (texture_vertices > 1)
        texture_vertices[outside] = (texture_vertices[outside] % 1)
    if not mesh.is_triangular or use_fallback:
        warnings.warn("Use of non-triangular meshes is discouraged", DeprecationWarning)
        u, v = 2*[np.linspace(0,1, uv_grid_steps),]
        U, V = np.meshgrid(u, v)
        interpolated = interpolate.griddata(texture_vertices, field, (U, V), method='linear')[::-1]
        uv_mask = get_uv_layout_mask_mask(mesh, uv_grid_steps=uv_grid_steps)
        interpolated[~uv_mask] = np.nan
        return interpolated
    u, v = 2*[np.linspace(0, 1, uv_grid_steps),]
    UV = np.stack(np.meshgrid(u, v), axis=-1).reshape((-1, 2))
    interpolated = interpolate_barycentric(UV, texture_vertices, mesh.texture_tris, field,
                                           distance_threshold=distance_threshold)
    interpolated = interpolated.reshape((uv_grid_steps, uv_grid_steps,)+field.shape[1:])[::-1]
    return interpolated

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 42
def interpolate_UV_to_per_vertex_field(mesh, field, domain="per-vertex"):
    """
    Interpolate a field defined by gridded values across UV square onto mesh vertices.
    
    This is useful for downstream geometric analysis. For example, you compute
    a vector field on a grid of the UV square and now want to get its values
    at the mesh vertices for geometric analysis.
    
    There may be some np.nans at the mesh boundary!
    
    The result can be defined per texture-vertex or per 3D-vertex. Make sure you use the right option!
        
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Input mesh with UV coordinates.
    field : np.array of shape (uv_grid_steps, uv_grid_steps,...)
        Input field. Can be an array with any number of axes (e.g. scalar or vector field).
        Must be defined on a square grid with uniform step size of the UV square.
    domain : "per-vertex" or "per-texture-vertex"
        Whether the result will be defined per-vertex or per texture vertex.
        If per-vertex, the values corresponding to all texture vertices that
        map to a vertex are averaged.

    Returns
    -------
    np.array of shape (n_vertices, ...)
        Field evaluated at mesh vertices.
            
    """
    assert field.shape[0] == field.shape[1], "Input shape must be square"

    uv_grid_steps = field.shape[0]
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    per_texture_vertex = interpolate.interpn((u, v), np.moveaxis(field, 1,0)[:,::-1], mesh.texture_vertices,
                                             method="linear", bounds_error=False)
    if domain == "per-texture-vertex":
        return per_texture_vertex
    return mesh.map_per_texture_vertex_to_per_vertex(per_texture_vertex)

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 43
def interpolate_volumetric_data_to_uv(image, interpolated_3d_positions, resolution):
    """ 
    Interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_per_vertex_field_to_UV.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
        
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, uv_grid_steps, uv_grid_steps)
        3d volumetric data interpolated onto UV grid.
    """
    x, y, z = [np.arange(ni) for ni in image.shape[1:]]
    interpolated_data = np.stack([interpolate.interpn((x, y, z), channel, interpolated_3d_positions/resolution,
                                  method="linear", bounds_error=False) for channel in image])
    
    return interpolated_data

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 51
def interpolate_volumetric_data_to_uv_multilayer(image, interpolated_3d_positions, interpolated_normals,
                                                 normal_offsets, resolution,):
    """ 
    Multilayer-interpolate volumetric image data onto UV coordinate grid.
    
    Uses 3d positions corresponding to each UV grid point as computed by interpolate_per_vertex_field_to_UV.
    3d coordinates (in microns) are converted into image coordinates via the scaling factor.
    
    Generates multiple "layers" by shifting surface along its normals.
    
    Parameters
    ----------
    image : 4d np.array
        Image, axis 0  is assumed to be the channel axis
    interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d positions across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan.
    interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
        3d normals across [0,1]^2 UV grid, with uniform step size. UV positions that don't correspond to 
        any value are set to np.nan. Normal vectors will be automatically normalized.
    normal_offsets : np.array of shape (n_layers,)
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    resolution : np.array of shape (3,)
        Resolution in pixels/microns for each of the three spatial axes.
    
    Returns
    -------
    interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
        3d volumetric data multilayer-interpolated onto UV grid.
    
    """
    interpolated_normals = (interpolated_normals.T / np.linalg.norm(interpolated_normals, axis=-1).T).T
    interpolated_data = np.stack([interpolate_volumetric_data_to_uv(image,
                                  interpolated_3d_positions+o*interpolated_normals, resolution,)
                                  for o in normal_offsets], axis=1)
    return interpolated_data

# %% ../nbs/Python library/02_cartographic_interpolation.ipynb 57
def create_cartographic_projections(image, mesh, resolution, normal_offsets=(0,), uv_grid_steps=256,
                                    map_back=True, use_fallback='auto'):
    """
    Create multilayer cartographic projections of an image using mesh.
    
    Computes multiple layers along the surface normal, with given normal offsets (in microns). 0 offset
    corresponds to no shift away from the mesh. Also computes 3d positions (in microns)
    and surface normals interpolated onto the UV grid.
    
    UV positions that don't correspond to any 3d position are set to np.nan.
    
    Parameters
    ----------
    image : str or 4d np.array
        Image, either as a path to a file or as an array. If array, axis 0  is assumed to be the channel axis
    mesh : str or tcmesh.ObjMesh
        Mesh, either as path to file, or as ObjMesh object.
    resolution : np.array of shape (3,)
        Image resolution in pixels/micron for the three spatial axes
    normal_offsets : np.array of float, optional
        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).
        0 corresponds to no shift.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.
    use_fallback : bool or 'auto', default 'auto'
        Ignore mesh connectivity when interpolating. This is to be used as a fallback
        if you have a UV map with lots of flipped triangles (i.e. self-intersections).
        If 'auto', the fallback option is chosen automatically if there are any flipped 
        triangles.
    
    Returns
    -------
    np.array, np.array, np.array
        interpolated_data : np.array of shape (n_channels, n_layers, uv_grid_steps, uv_grid_steps)
            3d volumetric data multilayer-interpolated across [0,1]^2 UV grid, with uniform step size.
        interpolated_3d_positions : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
            3d positions across [0,1]^2 UV grid, with uniform step size. 
        interpolated_normals : np.array of shape (uv_grid_steps, uv_grid_steps, 3)
            Normals across [0,1]^2 UV grid, with a uniform step size.
    """
    if isinstance(image, str):
        image = tcio.adjust_axis_order(tcio.imread(image))
    if isinstance(mesh, str):
        mesh = tcmesh.ObjMesh.read_obj(mesh)
    u, v = 2*[np.linspace(0,1, uv_grid_steps),]
    U, V = np.meshgrid(u, v)
    interpolated_3d_positions = interpolate_per_vertex_field_to_UV(mesh, mesh.vertices, domain="per-vertex",
                                                                   uv_grid_steps=uv_grid_steps,
                                                                   map_back=map_back, use_fallback=use_fallback)
    interpolated_normals = interpolate_per_vertex_field_to_UV(mesh, mesh.normals, domain="per-vertex",
                                                              uv_grid_steps=uv_grid_steps,
                                                              map_back=map_back, use_fallback=use_fallback)
    interpolated_data = interpolate_volumetric_data_to_uv_multilayer(image,
                                                                     interpolated_3d_positions,
                                                                     interpolated_normals, normal_offsets,
                                                                     resolution)
    return interpolated_data, interpolated_3d_positions, interpolated_normals 

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/04a_remeshing.ipynb.

# %% auto 0
__all__ = ['marching_cubes', 'subdivide_igl', 'make_delaunay', 'qslim']

# %% ../nbs/Python library/04a_remeshing.ipynb 3
from . import mesh as tcmesh

from scipy import ndimage
import numpy as np
import igl

import warnings

# %% ../nbs/Python library/04a_remeshing.ipynb 6
def marching_cubes(volume, isovalue=0.5, sigma_smoothing=0):
    """
    Compute triangular mesh of isosurface using marching cubes as implemented by lib|igl.
    
    Parameters
    ----------
    volume : 3d np.array
        Array with scalar values from which to compute the isosurface.
    isovalue: float, default 0.5
        Isosurface to extract
    sigma_smoothing: float, default 0
        If >0, carry out Gaussian smoothing before marching cubes

    Returns
    -------
    np.array, np.array
        vertices : np.array of shape (n_vertices, 3)
            Vertices
        faces : np.array of shape (n_faces, 3)
            Triangular faces (each face is a set of indices into the vertices array)
    """
    pts_grid = np.stack(np.meshgrid(*[np.arange(i) for i in volume.shape], indexing="ij"),
                        axis=-1).reshape(-1,3, order="F").astype(float)
    if sigma_smoothing>0:
        vals = ndimage.gaussian_filter(volume, sigma=sigma_smoothing).flatten(order="F")
    else:
        vals = volume.flatten(order="F")
    vertices, faces = igl.marching_cubes(vals, pts_grid, *volume.shape, isovalue)
    return vertices, faces

# %% ../nbs/Python library/04a_remeshing.ipynb 12
def subdivide_igl(mesh, reglue=True, decimals=None):
    """
    Refine mesh by edge subdivision using igl.
    
    Subdivides all edges by placing new vertices at edge midpoints. Preserves UV information,
    by cutting the mesh along seams and (optionally) gluing back after. New texture vertices
    are also placed at texture-edge midpoints.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    reglue : bool
        Glue back after cutting
    decimals : int or None
        Decimal precision for merging vertices when regluing. If None, estimate from average
        edge mesh length as -4*log_10(avg length)

    Returns
    -------
    mesh_subdiv : ObjMesh
        Subdivided mesh.
    """
    mesh_cut = mesh.cut_along_seams()
    new_vertices, new_faces = igl.upsample(mesh_cut.vertices, mesh_cut.tris, number_of_subdivs=1)
    new_texture_vertices, _ = igl.upsample(mesh_cut.texture_vertices, mesh_cut.tris, number_of_subdivs=1)
    mesh_subdiv = tcmesh.ObjMesh(vertices=new_vertices, texture_vertices=new_texture_vertices,
                               faces=[[[v,v] for v in fc] for fc in new_faces])
    mesh_subdiv.set_normals()
    if reglue:
        mesh_subdiv = tcmesh.glue_seams(mesh_subdiv, decimals=decimals)
    return mesh_subdiv

# %% ../nbs/Python library/04a_remeshing.ipynb 16
def make_delaunay(mesh):
    """
    Make mesh triangles less deformed by edge flips. 
    
    This algorithm improves mesh quality (i.e. makes triangles less deformed)
    without moving vertices by "edge flips" using the Delaunay algorithm.
    UV information is preserved by forbidding the flip of edges along the
    UV seams.
    
    Note that this algorithm can lead to self-overlap of the UV map.
    You can fix this using wrapping.smooth_laplacian_texture.
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.

    Returns
    -------
    mesh_new : ObjMesh
        Mesh with flipped edges.
    """
    if mesh.only_vertices:
        l = igl.edge_lengths(mesh.vertices, mesh.tris)
        l_new, f_new = igl.intrinsic_delaunay_triangulation(l, mesh.tris)
        mesh_new = tcmesh.ObjMesh(vertices=mesh.vertices, faces=f_new)
        return mesh_new
    mesh_cut = mesh.cut_along_seams()
    l = igl.edge_lengths(mesh_cut.vertices, mesh_cut.tris)
    l_new, f_new = igl.intrinsic_delaunay_triangulation(l, mesh_cut.tris)
    mesh_new = tcmesh.ObjMesh(vertices=mesh_cut.vertices, normals=mesh_cut.normals,
                              texture_vertices=mesh_cut.texture_vertices,
                              faces=[[[v,v] for v in fc] for fc in f_new])
    mesh_new = tcmesh.glue_seams(mesh_new, decimals=None)
    return mesh_new

# %% ../nbs/Python library/04a_remeshing.ipynb 20
def qslim(mesh, max_n_faces):
    """
    Simplify mesh by face decimation using the qslim algorithm.
    
    A wrapper of igl.qslim. This _will_ destroy UV mapping information!
    
    Parameters
    ----------
    mesh : ObjMesh
        Initial mesh.
    max_n_faces : int
        Maximum number of faces in output
    
    Returns
    -------
    mesh_new : ObjMesh
        Decimated mesh.

    """
    _, vertices_new, faces_new, _, _ = igl.qslim(mesh.vertices, mesh.tris, max_m=max_n_faces)
    return tcmesh.ObjMesh(vertices=vertices_new, faces=faces_new)

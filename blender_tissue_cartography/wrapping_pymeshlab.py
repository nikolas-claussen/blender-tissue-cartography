# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03b_wrapping_pymeshlab.ipynb.

# %% auto 0
__all__ = ['shrinkwrap_pymeshlab']

# %% ../nbs/03b_wrapping_pymeshlab.ipynb 1
from . import interface_pymeshlab as intmsl
import numpy as np
from copy import deepcopy
import warnings
import pymeshlab

# %% ../nbs/03b_wrapping_pymeshlab.ipynb 17
def shrinkwrap_pymeshlab(mesh_source, mesh_target, n_iter_smooth_target=10, n_iter_smooth_wrapped=10):
    """
    Shrink-wrap the source mesh onto the target mesh using pymeshlab.
    
    Sets the vertex positions of mesh_source to the closes point on the surface of mesh_target (not necessarily
    a vertex). Optionally, smoothes the target mesh and the wrapped mesh for smoother results using a Taubin
    filter (recommended). Gives out a warning if the shrink-wrapping flips any vertex normals, which can
    indicate problems.
    
    The shrinkwrapped mesh still has the UV maps of the source mesh, and so can be used to compute
    cartographic projections.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh to be deformed
    mesh_target : tcio.ObjMesh
        Mesh with target shape
    n_iter_smooth_target : int, default 10
        Taubin smoothing iterations for target
    n_iter_smooth_wrapped : int, default 10
        Taubin smoothing iterations for shrinkwrapped mesh, after shrinkwrapping

    Returns
    -------
    mesh_wrapped : tcio.ObjMesh

    """
    mesh_target_msl = intmsl.convert_to_pymeshlab(mesh_target)
    mesh_source_msl = intmsl.convert_to_pymeshlab(mesh_source)
    # create MeshSet and add the two meshes
    ms = pymeshlab.MeshSet()
    ms.add_mesh(mesh_target_msl)
    ms.add_mesh(mesh_source_msl)
    # taubin smoothing of target
    ms.set_current_mesh(0)
    ms.apply_coord_taubin_smoothing(stepsmoothnum=n_iter_smooth_target)
    # wrapping - note that the source-target convention is incorrectly documented
    ms.transfer_attributes_per_vertex(sourcemesh=0, targetmesh=1, vertexsampling=False, geomtransfer=True,
                                      normaltransfer=True, upperbound=pymeshlab.PercentageValue(100))
    # taubin smoothing of wrapped source
    ms.set_current_mesh(1)
    ms.apply_coord_taubin_smoothing(stepsmoothnum=n_iter_smooth_target)
    mesh_wrapped = intmsl.convert_from_pymeshlab(ms.mesh(1))
    # check if any normals were flipped
    dots = np.einsum("vi,vi->v", mesh_source.vertex_normals, mesh_wrapped.vertex_normals)
    if np.sum(dots < 0) > 0:
        warnings.warn(f"Warning: {np.sum(dots<0)} normal(s) flipped during shrink-wrapping")
    return mesh_wrapped

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/03_differential_geometry.ipynb.

# %% auto 0
__all__ = ['compute_per_vertex_area_distortion', 'get_area_distortion_in_UV', 'compute_per_vertex_angle_distortion',
           'compute_per_face_jacobian', 'compute_per_vertex_jacobian', 'get_metric_norm', 'get_metric_angle',
           'get_induced_metric', 'tri_grad', 'get_normal_projector', 'separate_tangential_normal', 'get_div', 'get_rot',
           'get_grad_perp']

# %% ../nbs/Python library/03_differential_geometry.ipynb 3
from . import mesh as tcmesh
from . import interpolation as tcinterp
from . import rotation as tcrot

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import sparse, linalg

# %% ../nbs/Python library/03_differential_geometry.ipynb 7
def compute_per_vertex_area_distortion(source_vertices, source_faces, target_vertices, target_faces,
                                       evaluate_at='source', cutoff=1e-15):
    """
    Compute area distortion factor for a map between meshes.
    
    The result is evaluated at the vertices of the source or target mesh.
    Faces must be such that faces[i] is mapped to target_faces[i].
    This function computes (target area / source area).
    
    This can be used to (a) visualize map distortion and (b)
    correct for it, for example by using it as a weighting factor
    for averages.
    
    Example (compute distortion of UV map):
    `
    compute_per_vertex_area_distortion(mesh.texture_vertices, mesh.texture_tris,
                                       mesh.vertices, mesh.tris)
    `
    
    Parameters
    ----------
    source_vertices : np.array
        Source mesh vertices.
    source_faces : np.array of shape (..., 3)
        Spurce mesh faces. Must be triangular.
    target_vertices : np.array
        Target mesh vertices.
    target_faces : np.array of shape (..., 3)
        Target mesh faces. Must be triangular.
    evaluate_at : str, 'source' or 'target'
        Whether to evaluate the result at the source or target
        mesh vertices.
    cutoff : float
        Numerical cutoff for small target areas (avoid 0 division error)
    
    Returns
    -------
    area_ratio_at_vertices : np.array
        Area distortion factor (source area/target area) evaluated on source or target mesh vertices.
    """
    areas_source = igl.doublearea(source_vertices, source_faces)
    areas_target = igl.doublearea(target_vertices, target_faces)
    mask_source = np.abs(areas_source) < cutoff
    areas_source[mask_source] = cutoff * np.sign(areas_source[mask_source])
    area_ratio = areas_target/areas_source
    if evaluate_at == 'target':
        area_ratio_at_vertices = igl.average_onto_vertices(target_vertices, target_faces,
                                                           np.stack(target_vertices.shape[1]*[area_ratio]).T)[:,0]
    elif evaluate_at == 'source':
        area_ratio_at_vertices = igl.average_onto_vertices(source_vertices, source_faces,
                                                           np.stack(source_vertices.shape[1]*[area_ratio]).T)[:,0]
    return area_ratio_at_vertices

# %% ../nbs/Python library/03_differential_geometry.ipynb 8
def get_area_distortion_in_UV(mesh, uv_grid_steps=1024, map_back=True):
    """
    Get area distortion of UV map, interpolated across the UV square.
    
    Used to measure area distortion of your cartographic mapping.
    This can be used to (a) visualize map distortion and (b)
    correct for it, for example by using it as a weighting factor
    for averages.
    
    Assumes the map $x,y,z \mapsto u,v$ to be invertible. This is not guaranteed
    - you can create overlapping UV coordinates in blender. The provided UV coordinates
    will be mapped back to [0, 1]^2 if map_back is True. Else, coordinates  outside [0,1] are ignored.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Input mesh with UV coordinates.
    uv_grid_steps : int, default 256
        Size of UV grid. Determines resolution of result.
    map_back : bool, default True
        Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.

    Returns
    -------
    distortion_interpolated : np.array of shape (uv_grid_steps, uv_grid_steps)
        Area distortion across [0,1]^2 UV grid, with uniform step size. UV positions that don't
        correspond to any value are set to np.nan.

    """
    distortion = compute_per_vertex_area_distortion(mesh.texture_vertices, mesh.texture_tris,
                                                    mesh.vertices, mesh.tris, evaluate_at='source')
    distortion_interpolated = tcinterp.interpolate_per_vertex_field_to_UV(mesh, distortion,
                                                                          uv_grid_steps=uv_grid_steps,
                                                                          map_back=map_back,
                                                                          domain='per-texture-vertex')
    return distortion_interpolated

# %% ../nbs/Python library/03_differential_geometry.ipynb 15
def compute_per_vertex_angle_distortion(source_vertices, source_faces, target_vertices, target_faces,
                                        evaluate_at='source', cutoff=1e-15):
    """  
    Compute angle distortion for a map between meshes.
    
    The result is evaluated at the vertices of the source or target mesh.
    Faces must be such that faces[i] is mapped to target_faces[i].
    This function computes np.abs(target angles - source angles),
    averaged over each triangle (in radians).
    
    This can be used to visualize map distortion.
    
    Example (compute distortion of UV map):
    `
    compute_per_vertex_angle_distortion(mesh.texture_vertices, mesh.texture_tris,
                                        mesh.vertices, mesh.tris)
    `
    
    Parameters
    ----------
    source_vertices : np.array
        Source mesh vertices.
    source_faces : np.array of shape (..., 3)
        Spurce mesh faces. Must be triangular.
    target_vertices : np.array
        Target mesh vertices.
    target_faces : np.array of shape (..., 3)
        Target mesh faces. Must be triangular.
    evaluate_at : str, 'source' or 'target'
        Whether to evaluate the result at the source or target
        mesh vertices.
    
    Returns
    -------
    area_ratio_at_vertices : np.array
        Area distortion factor (source area/target area) evaluated on source or target mesh vertices.
    """
    source_angles = igl.internal_angles(source_vertices, source_faces)
    target_angles = igl.internal_angles(target_vertices, target_faces)
    angle_error = np.abs(source_angles-target_angles).mean(axis=-1)
    if evaluate_at == 'target':
        angle_error_at_vertices = igl.average_onto_vertices(target_vertices, target_faces,
                                                            np.stack(target_vertices.shape[1]*[angle_error]).T)[:,0]
    elif evaluate_at == 'source':
        angle_error_at_vertices = igl.average_onto_vertices(source_vertices, source_faces,
                                                            np.stack(source_vertices.shape[1]*[angle_error]).T)[:,0]
    return angle_error_at_vertices

# %% ../nbs/Python library/03_differential_geometry.ipynb 21
def compute_per_face_jacobian(source_vertices, source_faces, target_vertices, target_faces):
    """
    Compute Jacobian factor for a map between meshes.
    
    Faces must be such that faces[i] is mapped to target_faces[i].
    This function computes the Jacobian mapping tangent vectors of the 
    source mesh to tangent vectors of the target mesh.
    The result is evaluated at the mesh faces.

    Example (compute distortion of UV map):
    `
    compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris
                                mesh.vertices, mesh.tris)
    `
    
    Parameters
    ----------
    source_vertices : np.array
        Source mesh vertices.
    source_faces : np.array of shape (..., 3)
        Spurce mesh faces. Must be triangular.
    target_vertices : np.array
        Target mesh vertices.
    target_faces : np.array of shape (..., 3)
        Target mesh faces. Must be triangular.
    
    Returns
    -------
    Jacobian : np.array
        Jacobian. Shape is (n_faces, d_target, d_source),
        where d is the spatial dimension (e.g. 2, 3).
    """
    A = source_vertices[source_faces]
    B = target_vertices[target_faces]
    A = (A.transpose((1,0,2)) - A.mean(axis=1)).transpose((1,0,2))
    B = (B.transpose((1,0,2)) - B.mean(axis=1)).transpose((1,0,2))
    jac = np.stack([np.linalg.lstsq(a, b, rcond=None)[0].T for a,b in zip(A, B)])
    return jac

def compute_per_vertex_jacobian(source_vertices, source_faces, target_vertices, target_faces,
                                evaluate_at='source'):
    """
    Compute Jacobian factor for a map between meshes.
    
    Faces must be such that faces[i] is mapped to target_faces[i].
    This function computes the Jacobian mapping tangent vectors of the 
    source mesh to tangent vectors of the target mesh.
    The result is evaluated at the vertices of the source mesh.
    
    Important: after you apply the per-vertex Jacobian,
    you may still need to permute the result, defined per
    source vertex, so it is defined per target mesh,
    e.g. using mesh.get_vertex_to_texture_vertex_indices()
    if mapping from 3d to UV.
    
    Example (compute distortion of UV map):
    `
    compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris
                                mesh.vertices, mesh.tris)
    `
    
    Parameters
    ----------
    source_vertices : np.array
        Source mesh vertices.
    source_faces : np.array of shape (..., 3)
        Spurce mesh faces. Must be triangular.
    target_vertices : np.array
        Target mesh vertices.
    target_faces : np.array of shape (..., 3)
        Target mesh faces. Must be triangular.
    evaluate_at : str, 'source' or 'target'
        Whether to evaluate the result at the source or target
        mesh vertices.
        
    Returns
    -------
    Jacobian : np.array
        Jacobian. Shape is (n_vertices, d_target, d_source),
        where d is the spatial dimension (e.g. 2, 3).
    """
    jac_per_face = compute_per_face_jacobian(source_vertices, source_faces,
                                             target_vertices, target_faces)
    jac_per_vertices = np.stack([igl.average_onto_vertices(source_vertices, source_faces, x)
                                 for x in jac_per_face.transpose((1,0,2))], axis=1)        
    return jac_per_vertices

# %% ../nbs/Python library/03_differential_geometry.ipynb 28
def get_metric_norm(vf, g):
    """Compute norm of vector field vf (shape (..., d)) using metric g (shape (..., d, d))."""
    return np.sqrt(np.einsum('...i,...ij,...j->...', vf, g, vf))

def get_metric_angle(vf1, vf2, g):
    """Compute angle in radians between two vector fields (shape (..., d)) in degrees using metric g (shape (..., d, d))."""
    norm1 = get_metric_norm(vf1, g)
    norm2 = get_metric_norm(vf2, g)
    inner = np.einsum('...i,...ij,...j->...', vf1, g, vf2)
    angle = np.arccos((1-1e-5)*inner/(norm1*norm2))
    return angle

def get_induced_metric(mesh):
    """
    Compute induced metric, evaluated at textures vertices.
    
    See https://en.wikipedia.org/wiki/Induced_metric.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Mesh. Must have texture map defined
        
    Returns
    -------
    g : np.array of shape (n_texture_vertices, 2, 2)
        Induced metric.
        
    """
    jac = compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris, mesh.vertices, mesh.tris)
    g = np.einsum('via,vib->vab', jac, jac)
    return g

# %% ../nbs/Python library/03_differential_geometry.ipynb 35
def tri_grad(field, vertices, faces, grad_matrix=None):
    """
    Calculate the gradient of a function defined on vertices of a triangular mesh.

    If a vector or tensor field is passed, the gradient is applied
    to each component individually.
    
    See https://libigl.github.io/libigl-python-bindings/tut-chapter1/#gradient

    Parameters
    ----------
    field : np.array of shape (#vertices,...)
        scalar, vector, or tensor field defined at mesh vertices
    vertices : np.array of shape (#vertices, dim)
        vertices.
    faces : np.array of shape (#faces, 3)
        Triangular faces.
    grad_matrix : scipy.sparse, optional
        Gradient operator. The default is None (calculate from vertices, faces).

    Returns
    -------
    np.array of shape (#vertices, dim, ...)
        Gradient of scalar function/tensor, defined on vertices.
        Axis 1 comprises the gradients along x,y,z.

    """
    if grad_matrix is None:  # calculate gradient operator
        grad_matrix = igl.grad(vertices, faces)
    # calculate the gradient of field by matrix multiplication
    index_shape = field.shape[1:]
    field = field.reshape((field.shape[0], int(np.prod(field.shape[1:]))))
    grad_field = grad_matrix.dot(field)
    # order='F' copied from igl tutorial
    grad_field = grad_field.reshape((faces.shape[0], vertices.shape[1], field.shape[1]), order='F')
    # now, average onto vertices. Need to iterate over all other axes
    grad_field = np.stack([igl.average_onto_vertices(vertices, faces, grad_field[:, :, i])
                           for i in range(grad_field.shape[2])], axis=2)
    # finally, reshape into original shape
    grad_field = grad_field.reshape(grad_field.shape[:2] + index_shape)
    return grad_field

# %% ../nbs/Python library/03_differential_geometry.ipynb 45
def get_normal_projector(vertices=None, faces=None, normals=None):
    """
    Get projection matrix that removes components normal to the surface
    
    Mathematically, 1-n.n^T where n is the unit surface normal.
    Defined per vertex. 
    
    Parameters
    ----------
    vertices : np.array of shape (#vertices, dim) or None
        vertices. If None, must supply normals
    faces : np.array of shape (#faces, 3) or None
        Triangular faces. If None, must supply normals
    normals : None or np.array of shape (#vertices, dim)
        If None, recompute normals from vertices and faces

    Returns
    -------
    np.array of shape (#vertices, dim, dim)
        Projector

    """
    if normals is None:
        normals = igl.per_vertex_normals(vertices, faces)
        normals = (normals.T/np.linalg.norm(normals, axis=-1)).T
    return np.eye(normals.shape[1])-np.einsum('vi,vj->vij', normals, normals)

# %% ../nbs/Python library/03_differential_geometry.ipynb 46
def separate_tangential_normal(field, vertices=None, faces=None, normals=None):
    """
    Separate tangential and normal components of field defined at vertices.
    
    Vector and rank-2 tensor fields are supported. For a rank-2 tensor,
    normal-tangential cross components are discarded.
    
    Parameters
    ----------
    field : np.array of shape (#vertices, dim) or (#vertices, dim, dim)
        Vector or rank-2 tensor field defined at vertices
    vertices : np.array of shape (#vertices, dim) or None
        vertices. If None, must supply normals
    faces : np.array of shape (#faces, 3) or None
        Triangular faces. If None, must supply normals
    normals : None or np.array of shape (#vertices, dim)
        If None, recompute normals from vertices and faces

    Returns
    -------
    np.array, np.array
        tangential_component : np.array of shape (#vertices, dim) or (#vertices, dim, dim)
        normal_component : np.array of shape (#vertices, dim) or (#vertices, dim, dim)

    """
    P = get_normal_projector(vertices, faces, normals)
    P_orth = np.eye(P.shape[-1]) - P 
    n_components = len(field.shape) - 1
    assert n_components in [1, 2], "Must be vector or rank-2 tensor field"
    if n_components == 1:
        tangential_component = np.einsum('vij,vj->vi', P, field)
        normal_component = field - tangential_component
    elif n_components == 2:
        tangential_component = np.einsum('vij,vjk,vkl->vil', P, field, P)
        normal_component = np.einsum('vij,vjk,vkl->vil', P_orth, field, P_orth)
    return tangential_component, normal_component

# %% ../nbs/Python library/03_differential_geometry.ipynb 51
def get_div(field, vertices, faces, normals=None):
    """
    Calculate tangent-plane divergence of vector field defined on vertices of triangular mesh.

    Parameters
    ----------
    field : np.array of shape (#vertices, dim)
        vector field defined at mesh vertices
    vertices : np.array of shape (#vertices, dim)
        vertices.
    faces : np.array of shape (#faces, 3)
        Triangular faces.
    normals : np.array of shape (#vertices, dim) or None
        If None, recompute normals from vertices and faces

    Returns
    -------
    np.array of shape (#vertices,)
        Divergence of vector field.

    """
    gradient = tri_grad(field, vertices, faces)
    gradient, _ = separate_tangential_normal(gradient, vertices, faces, normals)
    gradient_symmetric = (gradient + gradient.transpose((0,2,1)))/2
    return np.trace(gradient_symmetric, axis1=1, axis2=2)

def get_rot(field, vertices, faces, normals=None):
    """
    Calculate tangent-plane rotation of vector field defined on vertices of triangular mesh.
    
    This result is a scalar, equal to (Nabla x field).normals

    Parameters
    ----------
    field : np.array of shape (#vertices, dim)
        vector field defined at mesh vertices
    vertices : np.array of shape (#vertices, dim)
        vertices.
    faces : np.array of shape (#faces, 3)
        Triangular faces.
    normals : np.array of shape (#vertices, dim) or None
        If None, recompute normals from vertices and faces

    Returns
    -------
    np.array of shape (#vertices,)
        Curl of vector field. 

    """
    if normals is None:
        normals = igl.per_vertex_normals(vertices, faces)
        normals = (normals.T/np.linalg.norm(normals, axis=-1)).T

    gradient = tri_grad(field, vertices, faces)
    gradient, _ = separate_tangential_normal(gradient, vertices, faces, normals)
    gradient_antisymmetric = (gradient - gradient.transpose((0,2,1)))/2

    curl = np.stack([gradient_antisymmetric[:,1,2],
                     gradient_antisymmetric[:,2,0],
                     gradient_antisymmetric[:,0,1],], axis=-1)
    
    return np.einsum('vi,vi->v', normals, curl)

def get_grad_perp(field, vertices, faces, normals=None):
    """
    Calculate the gradient of a scalar field, rotated by 90 deg around the surface normal.
    
    As occurs e.g. when calculating vector field from stream function.
    
    Parameters
    ----------
    field : np.array of shape (#vertices,)
        Scalar field defined at mesh vertices
    vertices : np.array of shape (#vertices, dim)
        vertices.
    faces : np.array of shape (#faces, 3)
        Triangular faces.
    normals : np.array of shape (#vertices, dim) or None
        If None, recompute normals from vertices and faces.
        sign of normals determines sense of rotation.

    Returns
    -------
    np.array of shape (#vertices, dim)
        90-degree rotated gradient of scalar field. 

    """
    if normals is None:
        normals = igl.per_vertex_normals(vertices, faces)
        normals = (normals.T/np.linalg.norm(normals, axis=-1)).T
    assert len(field.shape) == 1, "Must be scalar field"
    gradient = tri_grad(field, vertices, faces)
    gradient, _ = separate_tangential_normal(gradient, vertices, faces, normals)
    # construct 90 deg rotation
    quaternion = np.pad(np.sin(np.pi/4)*normals, ((0,0), (1,0)), constant_values=np.cos(np.pi/4))
    quaternion = (quaternion.T / np.linalg.norm(quaternion, axis=1))
    R = tcrot.quaternion_to_rot_max(quaternion).T
    return np.einsum('vij,vj->vi', R, gradient)

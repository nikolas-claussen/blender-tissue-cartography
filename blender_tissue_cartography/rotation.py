# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/05b_registration_rotation.ipynb.

# %% auto 0
__all__ = ['cartesian_to_spherical', 'spherical_to_cartesian', 'compute_spherical_harmonics_coeffs',
           'spherical_harmonics_to_grid', 'quaternion_to_rot_max', 'rot_mat_to_quaternion',
           'quaternion_to_complex_pair', 'conjugate_quaternion', 'invert_quaternion', 'multiply_quaternions',
           'quaternion_power', 'get_binomial_matrix', 'get_wigner_D_matrix', 'parity_spherical_harmonics_coeffs',
           'rotate_spherical_harmonics_coeffs', 'overlap_spherical_harmonics', 'get_icosphere',
           'rotation_alignment_brute_force', 'rotation_alignment_refined', 'rotational_alignment']

# %% ../nbs/Python library/05b_registration_rotation.ipynb 3
from . import mesh as tcmesh

from . import registration as tcreg
from . import wrapping as tcwrap

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import integrate, interpolate, optimize, special

import matplotlib as mpl

import itertools

# %% ../nbs/Python library/05b_registration_rotation.ipynb 7
def cartesian_to_spherical(arr):
    """
    Convert cartesian coordinates to spherical coordinates.
    
    Uses en.wikipedia.org/wiki/Spherical_coordinate_system convention.
    
    Parameters
    ----------
    arr : np.array of shape (..., 3)
        array of x/y/z coordinates. last axis indexes coordinate axes.
        
    Returns
    -------
    np.array, np.array, np.array
        r, theta, phi spherical coordinates
    """
    r = np.linalg.norm(arr, axis=-1)
    theta = np.arccos(arr[...,2]/r)
    rho = np.linalg.norm(arr[...,:2], axis=-1)
    rho[rho==0] = 1e-4
    phi = np.sign(arr[...,1])*np.arccos(arr[...,0]/rho)
    return r, theta, phi

def spherical_to_cartesian(r, theta, phi):
    """
    Convert spherical coordinates to cartesian coordinates.
    
    Uses en.wikipedia.org/wiki/Spherical_coordinate_system convention.
    
    Parameters
    ----------
    r, theta, phi : np.arrays
        Spherical coordinates
        
    Returns
    -------
    arr : np.array of shape (..., 3)
        array of x/y/z coordinates. Last axis indexes coordinate axes.
    """
    return (r* np.stack([np.sin(theta)*np.cos(phi), np.sin(theta)*np.sin(phi), np.cos(theta)])).T

# %% ../nbs/Python library/05b_registration_rotation.ipynb 17
def compute_spherical_harmonics_coeffs(f, phi, theta, weights, max_l):
    """
    Compute spherical harmonic coefficients for a scalar real-valued function defined on the unit sphere.
    
    Takes as input values of the function at sample points (and sample weights), and computes
    the overlap with each spherical harmonic by "naive" numerical integration.
    
    Since the function is assumed real, we have f^{l}_{-m} = np.conjugate(f^{l}_{m}).
    
    Parameters
    ----------
    f : np.array 
        Sample values
    phi : np.array of shape
        Sample point azimuthal coordinates
    theta : np.array of shape
        Sample point longditudinal coordinates
    weights : np.array
        Sample weights. For instance, if you have a function sampled on a regular phi-theta grid,
        this should be dTheta*dPhi*np.sin(theta)
    max_l : int
        Maximum angular momentum
        
    Returns
    -------
    coeffs : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l-1. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l
    """

    coeffs = {}
    for l in range(max_l):
        vec = np.zeros(max([1, 2*l+1]), dtype="complex_")
        for m in range(0, l+1):
            entry = np.sum(weights*f*special.sph_harm(m, l, phi, theta))
            vec[l+m] = entry
            vec[l-m] = np.conjugate(entry)*(-1)**m
        coeffs[l] = np.copy(vec)
    return coeffs

# %% ../nbs/Python library/05b_registration_rotation.ipynb 20
def spherical_harmonics_to_grid(coeffs, n_grid=256):
    """
    Compute signal on rectangular phi-theta grid given spherical harmonics coefficients.
    
    Assumes underlying function is real-valued
    
    Parameters
    ----------
    coeffs : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l
    
    Returns
    -------
    reconstructed : 2d np.array
        Reconstructed signal interpolated on rectangular phi-theta grid
    
    """
    phi_grid, theta_grid = np.meshgrid(np.linspace(-np.pi,np.pi, 2*n_grid), np.linspace(0, np.pi, n_grid)[::-1], )
    reconstructed = np.zeros_like(phi_grid, dtype="complex_")
    for l, coeff_vec in coeffs.items():
        for m in range(0, l+1):
            Y_ml = special.sph_harm(m, l, phi_grid, theta_grid)
            if m == 0:
                reconstructed += coeff_vec[l]*Y_ml
            else:
                reconstructed += (coeff_vec[l+m]*np.conjugate(Y_ml)+coeff_vec[l-m]*Y_ml*(-1)**m)
    return reconstructed

# %% ../nbs/Python library/05b_registration_rotation.ipynb 39
def quaternion_to_rot_max(q):
    """
    Convert unit quaternion into a 3d rotation matrix.
    
    See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace
    """
    assert np.allclose(np.linalg.norm(q, axis=0), 1), "Must be unit quaternion!"
    a, b, c, d = q
    return np.array([[a**2+b**2-c**2-d**2, 2*b*c-2*a*d, 2*a*c+2*b*d],
                     [2*a*d+2*b*c, a**2-b**2+c**2-d**2, 2*c*d-2*a*b],
                     [2*b*d-2*a*c, 2*a*b+2*c*d, a**2-b**2-c**2+d**2]])

def rot_mat_to_quaternion(Q):
    """
    Convert 3d rotation matrix into unit quaternion.
    
    If determinant(Q) = -1, returns the unit quaternion corresponding to -Q
    
    See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace
    """
    if np.linalg.det(Q) < 0:
        return rot_mat_to_quaternion(-Q)
    trace = np.trace(Q)
    if trace < (-1+1e-5): # rotation by pi
        vals, vecs = np.linalg.eig(Q)
        u = vecs[:,np.argmin(np.abs(vals-1))].real
        return np.hstack([[0], u])
    r = np.sqrt(1+trace)/2
    u_ind = np.argmax(np.abs(np.diag(Q)))
    q = np.array([r, 0, 0, 0])
    Q_anti = (Q-Q.T)/(4*r)
    q[1+(u_ind+0)%3] = Q_anti[(u_ind+2)%3,(u_ind+1)%3]
    q[1+(u_ind+1)%3] = Q_anti[(u_ind+0)%3,(u_ind+2)%3]
    q[1+(u_ind+2)%3] = Q_anti[(u_ind+1)%3,(u_ind+0)%3]
    return q

def quaternion_to_complex_pair(q):
    """Convert quaternion to pair of complex numbers q0+iq3, q2+iq1"""
    return q[0]+1j*q[3], q[2]+1j*q[1]

def conjugate_quaternion(q):
    """Conjugate a quaternion"""
    return np.array([1, -1, -1, -1]) * q

def invert_quaternion(q):
    """Invert a quaternion"""
    return conjugate_quaternion(q) / np.linalg.norm(q)

def multiply_quaternions(q, p):
     return np.array([q[0]*p[0]-q[1]*p[1]-q[2]*p[2]-q[3]*p[3],
                      q[0]*p[1]+q[1]*p[0]+q[2]*p[3]-q[3]*p[2],
                      q[0]*p[2]+q[2]*p[0]-q[1]*p[3]+q[3]*p[1],
                      q[0]*p[3]+q[3]*p[0]+q[1]*p[2]-q[2]*p[1]])
    
def quaternion_power(q, n):
    """Raise quaternion to an integer power, potentially negative"""
    assert isinstance(n, int), "power n must be an integer"
    if n == 0:
        return np.array([1,0,0,0])
    if n > 0:
        n_iter = n
        q_inverted = q
    elif n < 0:
        n_iter = -n
        q_inverted = invert_quaternion(q)
    res = np.copy(q_inverted)
    while n_iter > 1:
        res = multiply_quaternions(q_inverted,res)
        n_iter -= 1
    return res

# %% ../nbs/Python library/05b_registration_rotation.ipynb 49
def get_binomial_matrix(N_max):
    """
    Get N_max by N_max matrix with entries binomial_matrix[i, j] = (i choose j).
    
    Computed via Pascal's triangle.
    """
    binomial_matrix = np.zeros((N_max+1, N_max+1))
    binomial_matrix[0,0] = binomial_matrix[1,0] = 1
    for i in range(1, N_max+1):
        for j in range(0, i+1):
            binomial_matrix[i, j] = binomial_matrix[i-1, j-1]+binomial_matrix[i-1, j]
    return binomial_matrix

# %% ../nbs/Python library/05b_registration_rotation.ipynb 52
def _get_wigner_D_element(Ra, Rb, l, mp, m, binomial_matrix):
    """
    Compute Wigner's D matrix element for a rotation defined by a unit quaternion R,
    represented as complex pair Ra=(R0+iR3), Rb=(R2+iR1). Requires pre-computed binomial matrix.
    
    Following https://spherical.readthedocs.io/en/main/WignerDMatrices/
    """
    comb_factor = np.sqrt(binomial_matrix[2*l, l+mp]/binomial_matrix[2*l, l+m])
    if np.abs(Ra) < 1e-10:
        if -mp != m:
            return 0
        return (-1)**(l+m) * Rb**(2*m)
    if np.abs(Rb) < 1e-10:
        if mp != m:
            return 0
        return Ra**(2*m)
    if np.abs(Ra) > np.abs(Rb):
        R_factor = np.abs(Ra)**(2*l-2*m) * Ra**(m+mp) * Rb**(m-mp)
        choose_factor = 0
        rho_min = max([mp-m, 0])
        power_fac = (np.abs(Rb)/np.abs(Ra))**2
        for rho in range(rho_min, l+mp+1):
            choose_factor += (binomial_matrix[l+mp, rho]*binomial_matrix[l-mp, l-rho-m]
                              *power_fac**(rho-rho_min)*(-1)**rho)
        return comb_factor*R_factor*choose_factor*power_fac**rho_min
    elif np.abs(Rb) > np.abs(Ra):
        R_factor = np.abs(Rb)**(2*l-2*m) * Ra**(m+mp) * Rb**(m-mp)
        choose_factor = 0
        rho_min = max([-mp-m, 0])
        power_fac = (np.abs(Ra)/np.abs(Rb))**2
        for rho in range(rho_min, l-mp+1):
            choose_factor += (binomial_matrix[l-mp, rho]*binomial_matrix[l+mp, l-rho-m]
                              *power_fac**(rho-rho_min)*(-1)**rho)
        return (-1)**(l-m)*comb_factor*R_factor*choose_factor*power_fac**rho_min

def get_wigner_D_matrix(q, l, binomial_matrix=None):
    """Get (2*l+1, 2*l+1) Wigner D matrix for angular momentum l and rotation (unit quatertion) q"""
    matrix = np.zeros(((2*l+1, 2*l+1)), dtype="complex_")
    Ra, Rb = quaternion_to_complex_pair(q)
    if l == 0:
        matrix[0,0] = 1
        return matrix
    if binomial_matrix is None:
        binomial_matrix = get_binomial_matrix(2*l)
    for m in range(-l, l+1):
        for mp in range(-l, l+1):
            matrix[l+mp, l+m] = _get_wigner_D_element(Ra, Rb, l, mp, m, binomial_matrix=binomial_matrix)
    return matrix

# %% ../nbs/Python library/05b_registration_rotation.ipynb 58
def parity_spherical_harmonics_coeffs(coeffs):
    """
    Apply parity operator to spherical harmonics coefficients.
    
    Parity means (x,y,z) -> (-x,-y,-z) and f^l_m -> (-1)^m * f^l_m.
    
    Parameters
    ----------
         use rot_mat_to_quaternion
    coeffs : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l-1. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l
    
    Returns
    -------
    dict of np.array
        Parity-transformed spherical harmonics coefficients.

    """
    return {key: (-1)**key * val for key, val in coeffs.items()}

def rotate_spherical_harmonics_coeffs(R, coeffs):
    """
    Rotate spherical harmonics by the given (improper or proper) rotation matrix.
    
    Uses Wigner-D matrices. Don't use this function in an optimization context - 
    you can in general save a bunch of time by reusing D-matrices etc.
    
    Parameters
    ----------
    R : np.array of shape (3, 3)
        Rotation matrix, may be improper. If you have a quaternion,
         use quaternion_to_rot_mat.
    coeffs : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l-1. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l
    
    Returns
    -------
    dict of np.array
        Rotated spherical harmonics coefficients.
    """
    if np.linalg.det(R) < 0:
        q = rot_mat_to_quaternion(-R)
        return {key: get_wigner_D_matrix(q, l=key)@val
                for key, val in parity_spherical_harmonics_coeffs(coeffs).items()}
    q = rot_mat_to_quaternion(-R)
    return {key: get_wigner_D_matrix(q, l=key)@val for key, val in coeffs.items()}

def overlap_spherical_harmonics(coeffsA, coeffsB, normalized=False):
    """
    Compute overlap (L2 inner product) between two sets of spherical harmonics.

    Optionally, normalize by the norm of coeffsA, coeffsB.
    """
    max_l = min([max(coeffsA.keys()), max(coeffsB.keys())])
    ls = range(0, max_l)
    inner_prod = np.sum([coeffsA[l].dot(np.conjugate(coeffsB[l])) for l in ls])
    if normalized:
        normalization = np.sqrt(np.abs(np.sum([coeffsA[l].dot(np.conjugate(coeffsA[l])) for l in ls])
                               *np.sum([coeffsB[l].dot(np.conjugate(coeffsB[l])) for l in ls])))
        return inner_prod/normalization
    return inner_prod

# %% ../nbs/Python library/05b_registration_rotation.ipynb 70
def get_icosphere(subdivide=0):
    """
    Return the icosphere triangle mesh with 42 regularly spaced vertices on the unit sphere.
    
    Optionally, subdivide mesh n times, increasing vertex count by factor 4^n.
    """
    vertices = np.array([[ 0.      , -1.      ,  0.      ], [ 0.723607, -0.44722 ,  0.525725],
                         [-0.276388, -0.44722 ,  0.850649], [-0.894426, -0.447216,  0.      ],
                         [-0.276388, -0.44722 , -0.850649], [ 0.723607, -0.44722 , -0.525725],
                         [ 0.276388,  0.44722 ,  0.850649], [-0.723607,  0.44722 ,  0.525725],
                         [-0.723607,  0.44722 , -0.525725], [ 0.276388,  0.44722 , -0.850649],
                         [ 0.894426,  0.447216,  0.      ], [ 0.      ,  1.      ,  0.      ],
                         [-0.162456, -0.850654,  0.499995], [ 0.425323, -0.850654,  0.309011],
                         [ 0.262869, -0.525738,  0.809012], [ 0.850648, -0.525736,  0.      ],
                         [ 0.425323, -0.850654, -0.309011], [-0.52573 , -0.850652,  0.      ],
                         [-0.688189, -0.525736,  0.499997], [-0.162456, -0.850654, -0.499995],
                         [-0.688189, -0.525736, -0.499997], [ 0.262869, -0.525738, -0.809012],
                         [ 0.951058,  0.      ,  0.309013], [ 0.951058,  0.      , -0.309013],
                         [ 0.      ,  0.      ,  1.      ], [ 0.587786,  0.      ,  0.809017],
                         [-0.951058,  0.      ,  0.309013], [-0.587786,  0.      ,  0.809017],
                         [-0.587786,  0.      , -0.809017], [-0.951058,  0.      , -0.309013],
                         [ 0.587786,  0.      , -0.809017], [ 0.      ,  0.      , -1.      ],
                         [ 0.688189,  0.525736,  0.499997], [-0.262869,  0.525738,  0.809012],
                         [-0.850648,  0.525736,  0.      ], [-0.262869,  0.525738, -0.809012],
                         [ 0.688189,  0.525736, -0.499997], [ 0.162456,  0.850654,  0.499995],
                         [ 0.52573 ,  0.850652,  0.      ], [-0.425323,  0.850654,  0.309011],
                         [-0.425323,  0.850654, -0.309011], [ 0.162456,  0.850654, -0.499995]])
    faces = np. array([[ 0, 13, 12], [12, 14,  2], [12, 13, 14], [13,  1, 14],
                       [ 1, 13, 15], [ 0, 12, 17], [ 0, 17, 19], [ 0, 19, 16],
                       [ 1, 15, 22], [ 2, 14, 24], [ 3, 18, 26], [ 4, 20, 28],
                       [ 5, 21, 30], [ 1, 22, 25], [ 2, 24, 27], [ 3, 26, 29],
                       [ 4, 28, 31], [ 5, 30, 23], [ 6, 32, 37], [ 7, 33, 39],
                       [ 8, 34, 40], [ 9, 35, 41], [10, 36, 38], [38, 41, 11],
                       [38, 36, 41], [36,  9, 41], [41, 40, 11], [41, 35, 40],
                       [35,  8, 40], [40, 39, 11], [40, 34, 39], [34,  7, 39],
                       [39, 37, 11], [39, 33, 37], [33,  6, 37], [37, 38, 11],
                       [37, 32, 38], [32, 10, 38], [23, 36, 10], [23, 30, 36],
                       [30,  9, 36], [31, 35,  9], [31, 28, 35], [28,  8, 35],
                       [29, 34,  8], [29, 26, 34], [26,  7, 34], [27, 33,  7],
                       [27, 24, 33], [24,  6, 33], [25, 32,  6], [25, 22, 32],
                       [22, 10, 32], [30, 31,  9], [30, 21, 31], [21,  4, 31],
                       [28, 29,  8], [28, 20, 29], [20,  3, 29], [26, 27,  7],
                       [26, 18, 27], [18,  2, 27], [24, 25,  6], [24, 14, 25],
                       [14,  1, 25], [22, 23, 10], [22, 15, 23], [15,  5, 23],
                       [16, 21,  5], [16, 19, 21], [19,  4, 21], [19, 20,  4],
                       [19, 17, 20], [17,  3, 20], [17, 18,  3], [17, 12, 18],
                       [12,  2, 18], [15, 16,  5], [15, 13, 16], [13,  0, 16],])
    if subdivide > 0:
        vertices, faces = igl.loop(vertices, faces, number_of_subdivs=subdivide)
    vertices = (vertices.T/np.linalg.norm(vertices, axis=-1)).T
    return tcmesh.ObjMesh(vertices=vertices, faces=faces)

# %% ../nbs/Python library/05b_registration_rotation.ipynb 71
def rotation_alignment_brute_force(sph_harmonics_source, sph_harmonics_target, 
                                   max_l=None, n_angle=100, n_subdiv_axes=1, allow_flip=False):
    """
    Compute rotational alignment between two signals on the sphere by brute force.
    
    The two signals have to be represented by their spherical harmonics coefficients.
    Uses Wigner-D matrices to calculate the overlap between the two signals
    for a set of rotations and finds the rotation that maximizes the overlap.
    
    The trial rotations are generated by taking a set of approx. equidistant
    points on the 2d sphere as rotation axes, and a set of equally spaced
    angles [0,..., 2*pi] as rotation angles.
    
    The rotation is such that it transforms the source signal to match the target.
        
    Parameters
    ----------
    sph_harmonics_source : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Source signal, to be
        transformed.
    sph_harmonics_target : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Target signal.
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls the number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1. In this case, 
        we return _two_ sets of overlaps and rotation matrices, one for the best
        proper, and one for the best improper rotation.
    
    Returns
    -------
    np.array, float or (np.array, float), (np.array, float)
        optimal_trial_rotation : (3,3) np.array
            Best trial rotation as rotation matrix.
        overlap : float
            Normalized overlap. 1=perfect alignment.
    """
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])

    alpha_0 = 2*np.pi/n_angle
    axes = get_icosphere(subdivide=n_subdiv_axes).vertices
    axes = axes[axes[:,-1] >= 0] # ax and -ax rotation axes are equivalent
    corr_coeffs = np.zeros((axes.shape[0], n_angle+1), dtype="complex_")
    corr_coeffs_flipped = np.zeros((axes.shape[0], n_angle+1), dtype="complex_")
    sph_harmonics_source_flipped = parity_spherical_harmonics_coeffs(sph_harmonics_source)
    normalization = np.sqrt(np.sum([val.dot(np.conjugate(val)) for val in sph_harmonics_source.values()])
                           *np.sum([val.dot(np.conjugate(val)) for val in sph_harmonics_target.values()]))
    for i, axis in enumerate(axes): # iterate over rotation axes
        q = np.hstack([[np.cos(alpha_0/2)], np.sin(alpha_0/2)*axis])
        correlation = np.zeros(n_angle+1,  dtype="complex_")
        correlation_flipped = np.zeros(n_angle+1,  dtype="complex_")
        for l in range(0, max_l):
            D_matrix = get_wigner_D_matrix(q, l=l)
            rotated_l = [sph_harmonics_source[l], D_matrix@sph_harmonics_source[l]]
            for n in range(1, n_angle): # iterate over rotation angle via matrix multiplication
                rotated_l.append(D_matrix@rotated_l[-1])
            correlation += np.stack(rotated_l).dot(np.conjugate(sph_harmonics_target[l]))
            # now the same for the parity-flipped coeffs
            rotated_l_flipped = [sph_harmonics_source_flipped[l], D_matrix@sph_harmonics_source_flipped[l]]
            for n in range(1, n_angle):
                rotated_l_flipped.append(D_matrix@rotated_l_flipped[-1])
            correlation_flipped += np.stack(rotated_l_flipped).dot(np.conjugate(sph_harmonics_target[l]))
        corr_coeffs[i] = correlation
        corr_coeffs_flipped[i] = correlation_flipped
    max_index = np.unravel_index(np.argmax(corr_coeffs.real), corr_coeffs.shape)
    alpha_opt = max_index[1]*alpha_0
    q_opt = np.hstack([[np.cos(alpha_opt/2)], np.sin(alpha_opt/2)*axes[max_index[0]]])
    overlap = corr_coeffs[max_index]/normalization
    if allow_flip:
        max_index_flipped = np.unravel_index(np.argmax(corr_coeffs_flipped.real), corr_coeffs_flipped.shape)
        alpha_opt_flipped = max_index_flipped[1]*alpha_0
        q_opt_flipped = np.hstack([[np.cos(alpha_opt_flipped/2)],
                                    np.sin(alpha_opt_flipped/2)*axes[max_index_flipped[0]]])
        overlap_flipped = corr_coeffs_flipped[max_index_flipped]/normalization
        return quaternion_to_rot_max(q_opt), overlap, -quaternion_to_rot_max(q_opt_flipped), overlap_flipped
    return quaternion_to_rot_max(q_opt), overlap

# %% ../nbs/Python library/05b_registration_rotation.ipynb 76
def _get_minus_overlap(q, sph_harmonics_source, sph_harmonics_target, max_l=None, binomial_matrix=None,):
    """
    Get negative overlap between spherical harmonics, as a function of rotation q, for optimization.
    """
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])    
    corr_coeff = 0
    ls = range(0, max_l)
    for l in ls:
        D_matrix = get_wigner_D_matrix(q/np.linalg.norm(q), l=l, binomial_matrix=binomial_matrix)
        corr_coeff += (D_matrix@sph_harmonics_source[l]).dot(np.conjugate(sph_harmonics_target[l]))
    normalization = np.sqrt(np.abs(np.sum([sph_harmonics_source[l].dot(np.conjugate(sph_harmonics_source[l]))
                                           for l in ls])
                                  *np.sum([sph_harmonics_target[l].dot(np.conjugate(sph_harmonics_target[l]))
                                           for l in ls])))
    return -corr_coeff.real/normalization

def rotation_alignment_refined(sph_harmonics_source, sph_harmonics_target, R_initial,
                               max_l=None, maxfev=100):
    """
    Refine rotational alignment between two signals on the sphere by optimization.
    
    The two signals have to be represented by their spherical harmonics coefficients.
    Uses Wigner-D matrices to calculate the overlap between the two signals
    and uses Nelder-Mead optimization to find the best one.
    
    Requires a good initial guess for the rotation, as created by 
    rotation_alignment_brute_force.
    
    The rotation is such that it transforms the source signal to match the target.
        
    Parameters
    ----------
    sph_harmonics_source : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Source signal, to be
        transformed.
    sph_harmonics_target : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Target signal.
    R_initial : (3, 3) np.array
        Initial rotation as a rotation matrix
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    maxfev : int
        Number of function evaluations during optimization. This parameter has
        the strongest influence on the run time.
    
    Returns
    -------
    np.array, float
        optimal_rotation : (3, 3) np.array
            Best rotation as rotation matrix. Will always have the same determinant (i.e. -1, 1)
            as the initial guess.
        overlap : float
            Normalized overlap. 1=perfect alignment.
    """
    tol = 1e-7
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])
    if np.linalg.det(R_initial) < 0:
        q_initial = rot_mat_to_quaternion(-R_initial)
        sph_harmonics_source_flipped = parity_spherical_harmonics_coeffs(sph_harmonics_source)
        args = (sph_harmonics_source_flipped, sph_harmonics_target,
                max_l, get_binomial_matrix(2*max_l))
        sol = optimize.minimize(_get_minus_overlap, q_initial, args=args, method="Nelder-Mead", tol=tol,
                                options={"maxfev": maxfev})
        return -quaternion_to_rot_max(sol.x/np.linalg.norm(sol.x)), -sol.fun
    q_initial = rot_mat_to_quaternion(R_initial)
    args = (sph_harmonics_source, sph_harmonics_target, max_l, get_binomial_matrix(2*max_l))
    sol = optimize.minimize(_get_minus_overlap, q_initial, args=args, method="Nelder-Mead", tol=tol,
                            options={"maxfev": maxfev})
    return quaternion_to_rot_max(sol.x/np.linalg.norm(sol.x)), -sol.fun

# %% ../nbs/Python library/05b_registration_rotation.ipynb 79
def rotational_alignment(sph_harmonics_source, sph_harmonics_target, allow_flip=False, max_l=None,
                         n_angle=100, n_subdiv_axes=1, maxfev=100,):
    """
    Rotational alignment between two signals on the sphere.
    
    The two signals have to be represented by their spherical harmonics coefficients.
    Uses Wigner-D matrices to calculate the overlap between the two signals.
    
    Alignment happens in two steps: first, a coarse alignment using a large number
    of trial rotation axes and angles, and then refinement via optimization.
    
    The rotation is such that it transforms the source signal to match the target.

    Parameters
    ----------
    sph_harmonics_source : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Source signal, to be
        transformed.
    sph_harmonics_target : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Target signal.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1. 
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls the number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    maxfev : int
        Number of function evaluations during fine optimization.
    
    Returns
    -------
    np.array, float
        optimal_rotation : (3, 3) np.array
            Best rotation as rotation matrix. Will always have the same determinant (i.e. -1, 1)
            as the initial guess.
        overlap : float
            Normalized overlap. 1=perfect alignment.
    """
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])
    if not allow_flip:
        R_initial, _ = rotation_alignment_brute_force(sph_harmonics_source, sph_harmonics_target,
                           allow_flip=False, max_l=max_l, n_angle=n_angle, n_subdiv_axes=n_subdiv_axes)
        R_refined, overlap = rotation_alignment_refined(sph_harmonics_source, sph_harmonics_target,
                                                        R_initial, max_l=max_l, maxfev=maxfev)
        return R_refined, overlap
    R_initial, _, R_initial_flipped, _ = rotation_alignment_brute_force(sph_harmonics_source, sph_harmonics_target,
                                                                    allow_flip=True, max_l=max_l,
                                                                    n_angle=n_angle, n_subdiv_axes=n_subdiv_axes)
    R_refined, overlap = rotation_alignment_refined(sph_harmonics_source, sph_harmonics_target,
                                                    R_initial, max_l=max_l, maxfev=maxfev)
    R_refined_flipped, overlap_flipped = rotation_alignment_refined(sph_harmonics_source,
                                        sph_harmonics_target, R_initial_flipped, max_l=max_l, maxfev=maxfev)
    if overlap_flipped > overlap:
        return R_refined_flipped, overlap_flipped
    return R_refined, overlap

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/05a_registration.ipynb.

# %% auto 0
__all__ = ['package_affine_transformation', 'get_inertia', 'align_by_centroid_and_intertia', 'procrustes', 'icp']

# %% ../nbs/Python library/05a_registration.ipynb 1
import numpy as np
from scipy import stats, spatial, linalg
import itertools
import igl

# %% ../nbs/Python library/05a_registration.ipynb 17
def package_affine_transformation(matrix, vector):
    """Package matrix transformation & translation into (d+1,d+1) matrix representation of affine transformation."""
    matrix_rep = np.hstack([matrix, vector[:, np.newaxis]])
    matrix_rep = np.pad(matrix_rep, ((0,1),(0,0)), constant_values=0)
    matrix_rep[-1,-1] = 1
    return matrix_rep

def get_inertia(pts, q=0):
    """Get inertia tensor of 3d point cloud. q in [0, 1) removes points with outlier coordinates."""
    pts_nomean = pts - stats.trim_mean(pts,q, axis=0)
    x, y, z = pts_nomean.T
    Ixx = stats.trim_mean(x**2, q)
    Ixy = stats.trim_mean(x*y, q)
    Ixz = stats.trim_mean(x*z, q)
    Iyy = stats.trim_mean(y**2, q)
    Iyz = stats.trim_mean(y*z, q)
    Izz = stats.trim_mean(z*z, q)
    return np.array([[Ixx, Ixy, Ixz], [Ixy,Iyy, Iyz], [Ixz, Iyz, Izz]])

def align_by_centroid_and_intertia(source, target, q=0, scale=True, shear=False, n_samples=10000,
                                   choose_minimal_rotation=False):
    """
    Align source point cloud to target point cloud using affine transformation.
    
    Align by matching centroids and axes of inertia tensor. Since the inertia tensor is invariant
    under reflections along its principal axes, all 2^3 reflections are tried and (a) the one leading
    to the best agreement with the target or (b) the one corresponding to the least amount of rotation
    is chosen. This is controlled using the choose_minimal_rotation argument.
    
    Parameters
    ----------
    source : np.array of shape (n_source, 3)
        Point cloud to be aligned.
    target : np.array of shape (n_target, 3)
        Point cloud to align to.
    q : float, optional, default 0
        Quantile for outlier removal. Removes points with coordinates outside (qth, (1-1)qth) quantile from
        calculation of inertia tensor and centroid
    scale : bool, default True
        Whether to allow scale transformation (True) or rotations only (False)
    shear : bool, default False
        Whether to allow shear transformation (True) or rotations/scale only (False)
    n_samples : int, optional
        Number of samples of source to use when estimating distances.
    choose_minimal_rotation : bool, default False
        Whether to chose the rotation matrix closest to the identity. If False, the rotation matrix
        (possibly with det=-1) leading to the best alignment with the target is chosen.

    Returns
    -------
    np.array, np.array
        affine_matrix_rep : np.array of shape (4, 4)
            Affine transformation source -> target
        aligned : np.array of shape (n_source, 3)
            Aligned coordinates
    """
    target_centroid = stats.trim_mean(target, q, axis=0)
    target_inertia = get_inertia(target, q=q)
    target_eig = np.linalg.eigh(target_inertia)

    source_centroid = stats.trim_mean(source, q, axis=0)
    source_inertia = get_inertia(source, q=q)
    source_eig = np.linalg.eigh(source_inertia)

    flips = [np.diag([i,j,k]) for i, j, k in itertools.product(*(3*[[-1,1]]))]
    trafo_matrix_candidates = []
    if not choose_minimal_rotation:
        tree = spatial.cKDTree(target)
        samples = source[np.random.randint(low=0, high=source.shape[0], size=min([n_samples, source.shape[0]])),:]
    distances = []
    for flip in flips:
        if shear:
            trafo_matrix = (source_eig.eigenvectors
                            @ np.diag(np.sqrt(target_eig.eigenvalues/source_eig.eigenvalues))
                            @ flip @ target_eig.eigenvectors.T)
        elif scale and not shear:
            scale_fact = np.sqrt(stats.gmean(target_eig.eigenvalues)/stats.gmean(source_eig.eigenvalues))
            trafo_matrix = scale_fact*source_eig.eigenvectors@flip@target_eig.eigenvectors.T
        elif not scale and not shear:
            trafo_matrix = source_eig.eigenvectors@flip@target_eig.eigenvectors.T
        trafo_matrix = trafo_matrix.T
        trafo_matrix_candidates.append(trafo_matrix)
        if not choose_minimal_rotation:
            trafo_translate = target_centroid - trafo_matrix@source_centroid
            aligned = samples@trafo_matrix.T + trafo_translate
            distances.append(stats.trim_mean(tree.query(aligned)[0], q))
        else:
            rot_matrix = source_eig.eigenvectors@flip@target_eig.eigenvectors.T
            distances.append(np.abs(3-np.trace(rot_matrix)))
    trafo_matrix = trafo_matrix_candidates[np.argmin(distances)]
    trafo_translate = target_centroid - trafo_matrix@source_centroid
    aligned = source@trafo_matrix.T + trafo_translate
    affine_matrix_rep = np.round(package_affine_transformation(trafo_matrix, trafo_translate),decimals=2)
    return affine_matrix_rep, aligned

# %% ../nbs/Python library/05a_registration.ipynb 31
def procrustes(source, target, include_scaling=True, include_reflections=True):
    """
    Wrapper around igl.procrustes
    
    Compute rotation+scaling+translation between two sets of points.
    
    Parameters
    ----------
    source : np.array of shape (n_points, n_dimensions)
    target : np.array of shape (n_points, n_dimensions)
    include_scaling, nclude_reflections : bool, 

    Returns
    -------
    np.array, np.array, float
        trafo_affine : np.array
            (4,4) array representing the affine transformation from source to target.
        aligned : np.array
            The orientation of the source that best fits the target.
        disparity : float
            np.linalg.norm(aligned-target, axis=1).mean()
    """
    scale_igl, rot_igl, translate_igl = igl.procrustes(source, target,
                                                       include_scaling=include_scaling,
                                                       include_reflections=include_reflections)
    trafo_affine = package_affine_transformation(scale_igl*rot_igl.T, translate_igl)
    aligned = source@trafo_affine[:3,:3].T + trafo_affine[:3,-1]
    disparity = np.linalg.norm(aligned-target, axis=1).mean()
    return trafo_affine, aligned, disparity

# %% ../nbs/Python library/05a_registration.ipynb 36
def icp(source, target, initial=None, threshold=1e-4, max_iterations=20, include_scaling=True, n_samples=1000):
    """
    Apply the iterative closest point algorithm to align point cloud a with
    point cloud b. Will only produce reasonable results if the
    initial transformation is roughly correct. Initial transformation can be
    found by applying Procrustes' analysis to a suitable set of landmark
    points (often picked manually), or by inertia+centroid-based alignment,
    implemented in align_by_centroid_and_intertia.

    Parameters
    ----------
    source : (n,3) float
      Source points in space.
    target : (m,3) float or Trimesh
      Target points in space or mesh.
    initial : (4,4) float
      Initial transformation.
    threshold : float
      Stop when the change in cost is less than threshold
    max_iterations : int
      Maximum number of iterations
    include_scaling : bool, optional
      Whether to allow dilations. If False, orthogonal Procrustes is used
    n_samples : int or None
        If not None, n_samples sample points are randomly chosen from the source array for distance computation
    
    Returns
    ----------
    np.array, np.array, float
        matrix : (4,4) np.array
          The transformation matrix sending a to b
        transformed : (n,3) np.array
          The image of a under the transformation
        cost : float
          The cost of the transformation
    """
    # initialize transform matrix
    total_matrix = np.eye(4) if initial is None else initial
    tree = spatial.cKDTree(target)
    # subsample and apply initial transformation
    samples = (source[np.random.randint(low=0, high=source.shape[0], size=min([n_samples, source.shape[0]])),:]
               if n_samples is not None else source[:])
    samples = samples@total_matrix[:3,:3].T + total_matrix[:3,-1]
    # start with infinite cost
    old_cost = np.inf
    # avoid looping forever by capping iterations
    for _ in range(max_iterations):
        # Find closest point in target to each point in sample and align
        closest = target[tree.query(samples, 1)[1]]
        matrix, samples, cost = procrustes(samples, closest, include_scaling=include_scaling,
                                           include_reflections=False)
        # update a with our new transformed points
        total_matrix = np.dot(matrix, total_matrix)
        if old_cost - cost < threshold:
            break
        else:
            old_cost = cost
    aligned = source@total_matrix[:3,:3].T + total_matrix[:3,-1]
    return total_matrix, aligned, cost

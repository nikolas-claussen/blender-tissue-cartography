# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_registration.ipynb.

# %% auto 0
__all__ = ['get_inertia', 'package_affine_transformation', 'align_by_centroid_and_interia', 'obj_facelist_to_trilist']

# %% ../nbs/04_registration.ipynb 1
from . import io as tcio
from . import interpolation as tcinterp
from importlib import reload

# %% ../nbs/04_registration.ipynb 2
import numpy as np
from skimage import transform
from scipy import stats, spatial
import os
import matplotlib.pyplot as plt
import mcubes
import pymeshlab
from trimesh import Trimesh
from trimesh import registration as trireg
from copy import deepcopy

# %% ../nbs/04_registration.ipynb 18
def get_inertia(pts, q=0):
    """Get inertia tensor of point cloud. q in [0, 1) removes points with outlier coordinates"""
    pts_nomean = pts - stats.trim_mean(pts,q, axis=0)
    x, y, z = pts_nomean.T
    Ixx = stats.trim_mean(x**2, q)
    Ixy = stats.trim_mean(x*y, q)
    Ixz = stats.trim_mean(x*z, q)
    Iyy = stats.trim_mean(y**2, q)
    Iyz = stats.trim_mean(y*z, q)
    Izz = stats.trim_mean(z*z, q)
    return np.array([[Ixx, Ixy, Ixz], [Ixy,Iyy, Iyz], [Ixz, Iyz, Izz]])

def package_affine_transformation(matrix, vector):
    """Package matrix transformation & translation into (d+1,d+1) matrix representation of affine transformation."""
    matrix_rep = np.hstack([matrix, vector[:, np.newaxis]])
    matrix_rep = np.pad(matrix_rep, ((0,1),(0,0)), constant_values=0)
    matrix_rep[-1,-1] = 1
    return matrix_rep

def align_by_centroid_and_interia(source, target, q=0, scale=True):
    """
    Align source point cloud to target point cloud using affine transformation.
    
    Align by matching centroids and axes of intertia tensor. Since the inertia tensor is invariant
    under reflections along its principal axes, all 2^3 reflections are tried and the one leading
    to best agreement with the target is chosen.
    
    Parameters
    ----------
    source : np.array of shape (n_source, 3)
        Point cloud to be aligned.
    target : np.array of shape (n_target, 3)
        Point cloud to align to.
    q : float, optional, default 0
        Quantile for outlier removal. Removes points with coordinates outside (qth, (1-1)qth) quantile from
        calculation of intertia tensor and centroid
    scale : bool, default True
        Whether to allow shear transformation (True) or rotations only (False)
    
    Returns
    -------
    affine_matrix_rep : np.array of shape (4, 4)
        Affine transformation source -> target
    aligned : np.array of shape (n_source, 3)
        Aligned coordinates
    """
    target_centroid = stats.trim_mean(target, q, axis=0)
    target_inertia = get_inertia(target, q=q)
    target_eig = np.linalg.eigh(target_inertia)

    source_centroid = stats.trim_mean(source, q, axis=0)
    source_inertia = get_inertia(source, q=q)
    source_eig = np.linalg.eigh(source_inertia)

    flips = list(tcio.flatten([[[np.diag([i,j,k]) for i in [-1,1]] for j in [-1,1]] for k in [-1,1]], max_depth=2))
    trafo_matrix_candidates = []

    for flip in flips:
        if scale:
            trafo_matrix = (source_eig.eigenvectors
                            @ np.diag(np.sqrt(target_eig.eigenvalues/source_eig.eigenvalues))
                            @ flip
                            @ target_eig.eigenvectors.T)
        else:
            trafo_matrix = source_eig.eigenvectors@flip@target_eig.eigenvectors.T
        trafo_matrix = trafo_matrix.T
        trafo_matrix_candidates.append(trafo_matrix)
    tree = spatial.cKDTree(target)

    distances = []
    for trafo_matrix in trafo_matrix_candidates:
        trafo_translate = target_centroid - trafo_matrix@source_centroid
        aligned = source@trafo_matrix.T + trafo_translate
        distances.append(stats.trim_mean(tree.query(aligned)[0], q))
    print(distances)
    trafo_matrix = trafo_matrix_candidates[np.argmin(distances)]
    trafo_translate = target_centroid - trafo_matrix@source_centroid
    aligned = source@trafo_matrix.T + trafo_translate
    affine_matrix_rep = np.round(package_affine_transformation(trafo_matrix, trafo_translate),decimals=2)
    return affine_matrix_rep, aligned

# %% ../nbs/04_registration.ipynb 28
def obj_facelist_to_trilist(faces):
    """
    Convert .obj list of faces to list of triangles. Texture and normal vertex info is discarded.
    
    For conversion to trimesh.Trimesh mesh object, for instance.
    
    Parameters
    ----------
    faces : list
        Faces can be lists of vertex indices, or vertex/texture vertex/normal index triples
    
    Returns
    -------
    np.array of shape (n_tris, 3)
        Array of triangular faces
    """

    vertex_length = len(faces[0][0])
    if vertex_length == 3:
        return np.array([[v[0] for v in f] for f in faces if len(f)==3])
    return np.array([[v for v in f] for f in faces if len(f)==3])

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03d_conformal_wrapping.ipynb.

# %% auto 0
__all__ = ['map_to_disk', 'rot_mat', 'rotational_align_disk', 'extrapolate_fast_marching', 'wrap_coords_via_disk',
           'wrap_coords_via_disk_no_skfmm', 'stereographic_plane_to_sphere', 'stereographic_sphere_to_plane',
           'center_moebius', 'map_to_sphere']

# %% ../nbs/03d_conformal_wrapping.ipynb 1
from . import io as tcio
from . import registration as tcreg
from . import wrapping as tcwrap
from . import rotation as tcrot

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import interpolate, ndimage, optimize, sparse, spatial
from skimage import registration, transform

import matplotlib as mpl

import skfmm

# %% ../nbs/03d_conformal_wrapping.ipynb 10
def map_to_disk(mesh):
    """
    Map mesh to unit disk by computing harmonic UV coordinates.
    
    The longest boundary loop of the mesh is mapped to the unit circle.
    Follows https://libigl.github.io/libigl-python-bindings/tut-chapter4/.
    
    The disk rotation angle is arbitrary
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    quantiles : tuple
        Image quantile to set to 0 and 1.
    
    Returns
    -------
    mesh_parametrized : tcio.ObjMesh
        Mesh with UV coordinates mapping it to the disk.
    
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    ## Find the open boundary
    bnd = igl.boundary_loop(mesh.tris)
    assert len(bnd) > 0, "No boundary found! Your mesh may not be a disk" 

    ## Map the boundary to a circle, preserving edge proportions
    bnd_uv = igl.map_vertices_to_circle(mesh.vertices, bnd)

    ## Harmonic parametrization for the internal vertices
    uv = igl.harmonic(mesh.vertices, mesh.tris, bnd, bnd_uv, 1)
    uv = uv/2+np.array([0.5, 0.5])
    
    ## create new mesh
    mesh_parametrized = tcio.ObjMesh(vertices=mesh.vertices, texture_vertices=uv, normals=None,
                                faces=[[[v,v] for v in fc] for fc in mesh.tris])
    mesh_parametrized.set_normals()
    
    return mesh_parametrized

# %% ../nbs/03d_conformal_wrapping.ipynb 15
def rot_mat(phi):
    """Get rotation matrix with angle phi"""
    return np.array([[np.cos(phi), np.sin(phi)],[-np.sin(phi), np.cos(phi)]])

# %% ../nbs/03d_conformal_wrapping.ipynb 18
def rotational_align_disk(mesh_source, mesh_target, q=0.05, n_grid=256):
    """
    Rotationally align two UV map to the disk by the conformal factor.
    
    Computes aligned UV coordinates. Assumes that the UV
    coordinates are in [0,1]^2. Rotational alignment works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the plane), which is rotated so that the maximum is at the y-axis
    via a Fourier transform.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment
    
    Returns
    -------
    new_texture_vertices_mesh_source : np.array
        Rotationally aligned texture vertices
    
    """
    assert mesh_source.tris.shape==mesh_source.texture_tris.shape,\
        "3d and UV triangulations must be identical"
    assert (mesh_source.tris==mesh_source.texture_tris).all(),\
        "3d and UV triangulations must be identical"
    assert mesh_target.tris.shape==mesh_target.texture_tris.shape,\
        "3d and UV triangulations must be identical"
    assert (mesh_target.tris==mesh_target.texture_tris).all(),\
        "3d and UV triangulations must be identical"
    # compute conformal distortion factors, clip to avoid outliers
    conformal_factor_source = (igl.doublearea(mesh_source.vertices, mesh_source.tris)/
                               igl.doublearea(mesh_source.texture_vertices, mesh_source.texture_tris))
    conformal_factor_source = np.clip(conformal_factor_source, np.quantile(conformal_factor_source, q),
                                      np.quantile(conformal_factor_source, 1-q))
    uv_centroids_source = mesh_source.texture_vertices[mesh_source.texture_tris].mean(axis=1)
    conformal_factor_target = (igl.doublearea(mesh_target.vertices, mesh_target.tris)/
                               igl.doublearea(mesh_target.texture_vertices, mesh_target.texture_tris))
    conformal_factor_target = np.clip(conformal_factor_target, np.quantile(conformal_factor_target, q),
                                      np.quantile(conformal_factor_target, 1-q))
    uv_centroids_target = mesh_target.texture_vertices[mesh_target.texture_tris].mean(axis=1)
    # interpolate onto a grid
    U, V = np.meshgrid(*2*[np.linspace(0, 1, n_grid)])
    conformal_factor_source = igl.average_onto_vertices(mesh_source.vertices, mesh_source.texture_tris,
                                                        np.stack(3*[conformal_factor_source], axis=-1))[:,0]
    conformal_factor_target = igl.average_onto_vertices(mesh_target.vertices, mesh_target.texture_tris,
                                                        np.stack(3*[conformal_factor_target], axis=-1))[:,0]
    interpolated_source = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*mesh_source.texture_vertices.T,
                                                                              mesh_source.texture_tris),
                                                        conformal_factor_source)(U,V)
    interpolated_target = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*mesh_target.texture_vertices.T,
                                                                              mesh_target.texture_tris),
                                                        conformal_factor_target)(U,V)
    # compute rotational alignment
    interpolated_source_polar = transform.warp_polar(interpolated_source, radius=n_grid/2-1)
    interpolated_target_polar = transform.warp_polar(interpolated_target, radius=n_grid/2-1)

    shifts, _, _ = registration.phase_cross_correlation(interpolated_source_polar, interpolated_target_polar,
                                                        reference_mask=~np.isnan(interpolated_source_polar),
                                                        moving_mask=~np.isnan(interpolated_target_polar),
                                                        normalization=None)

    rot_angle = shifts[0]*np.pi/180
    new_texture_vertices = (mesh_source.texture_vertices-np.array([0.5,0.5]))@rot_mat(-rot_angle)
    new_texture_vertices += np.array([0.5,0.5])
    return new_texture_vertices

# %% ../nbs/03d_conformal_wrapping.ipynb 22
def extrapolate_fast_marching(arr):
    """Fill nans in 2d numpy array via fast-marching extrapolation."""
    mask = ~ndimage.binary_erosion(~np.isnan(arr), iterations=2)
    extended = skfmm.extension_velocities(mask, arr)[1]
    return extended

# %% ../nbs/03d_conformal_wrapping.ipynb 23
def wrap_coords_via_disk(mesh_source, mesh_target, n_grid=512):
    """
    Map 3d coords of source mesh to target mesh via a disk parametrization. 
    
    """
    # compute harmonic map to disk
    mesh_source_disk = map_to_disk(mesh_source)
    mesh_target_disk = map_to_disk(mesh_target)
    # rotational alignment of parametrizations
    mesh_source_disk.texture_vertices = rotational_align_disk(mesh_source_disk, mesh_target_disk)
    # interpolate 3d coordinates. we use a grid and extend the interpolated UV coordinates
    # to the whole UV square in order to avoid issues with the disk boundary.
    U, V = np.meshgrid(*2*[np.linspace(0, 1, n_grid)])
    triangulation_target = mpl.tri.Triangulation(*mesh_target_disk.texture_vertices.T,
                                                 mesh_target_disk.texture_tris)
    interpolators = [mpl.tri.LinearTriInterpolator(triangulation_target, x) for x in mesh_target_disk.vertices.T]
    interpolated = np.stack([extrapolate_fast_marching(np.array(f(U, V))) for f in interpolators], axis=0)
    # interpolate onto source mesh
    new_coords = np.stack([interpolate.interpn((U[0], V[:,0]), x, mesh_source_disk.texture_vertices[:,::-1])
                           for x in interpolated], axis=-1)
    return new_coords

# %% ../nbs/03d_conformal_wrapping.ipynb 24
def wrap_coords_via_disk_no_skfmm(mesh_source, mesh_target):
    """
    Map 3d coords of source mesh to target mesh via a disk parametrization. 
    
    """
    # compute harmonic map to disk
    mesh_source_disk = map_to_disk(mesh_source)
    mesh_target_disk = map_to_disk(mesh_target)
    # rotational alignment of parametrizations
    mesh_source_disk.texture_vertices = rotational_align_disk(mesh_source_disk, mesh_target_disk)
    # interpolate 3d coordinates
    triangulation_target = mpl.tri.Triangulation(*mesh_target_disk.texture_vertices.T,
                                                 mesh_target_disk.texture_tris)
    interpolators = [mpl.tri.LinearTriInterpolator(triangulation_target, z) for z in mesh_target_disk.vertices.T]
    interpolated = np.stack([np.array(f(*mesh_source_disk.texture_vertices.T)) for f in interpolators], axis=-1)
    # fix issues due to the boundary - there may be texture vertices of the source mesh
    # we first fix all the boundary vertices which are nan by interpolating from the two closest target boundary pts
    bnd_source = igl.boundary_loop(mesh_source_disk.texture_tris)
    bnd_target = igl.boundary_loop(mesh_target_disk.texture_tris)
    tree = spatial.cKDTree(mesh_target_disk.texture_vertices[bnd_target])
    dists, inds = tree.query(mesh_source_disk.texture_vertices[bnd_source], k=2)
    dists = (dists.T / dists.sum(axis=1)).T
    interpolated_bdry = (mesh_target_disk.vertices[bnd_target][inds].T * dists.T).sum(axis=1).T
    nan_and_bdry = np.isnan(interpolated[bnd_source]).any(axis=1)
    interpolated_bdry[~nan_and_bdry] = interpolated[bnd_source][~nan_and_bdry]
    interpolated[bnd_source] = interpolated_bdry
    # now there still may be interior vertices which are nan. we fix them via a second round of interpolation
    if np.isnan(interpolated).any():
        mask = ~np.isnan(interpolated).any(axis=-1)
        missing = np.stack([interpolate.LinearNDInterpolator(mesh_source_disk.texture_vertices[mask], x[mask])(
            mesh_source_disk.texture_vertices[~mask]) for x in interpolated.T], axis=-1)
        interpolated[~mask] = missing
    return interpolated

# %% ../nbs/03d_conformal_wrapping.ipynb 36
def stereographic_plane_to_sphere(uv):
    """
    Stererographic projection from plane to unit sphere from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    uv should be an array of shape (..., 2)
    """
    return (np.stack([2*uv[:,0], 2*uv[:,1], uv[:,0]**2+uv[:,1]**2-1], axis=0) / (1+uv[:,0]**2+uv[:,1]**2)).T
    
def stereographic_sphere_to_plane(pts):
    """
    Stererographic projection from unit sphere to plane from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    pts should be an array of shape (..., 3)
    """
    assert np.allclose(np.linalg.norm(pts, axis=1), 1, rtol=1e-03, atol=1e-04), "Points not on unit sphere!"
    return (np.stack([pts[:,0], pts[:,1]], axis=0)/(1-pts[:,2])).T

# %% ../nbs/03d_conformal_wrapping.ipynb 40
def center_moebius(vertices_3d, vertices_sphere, tris, n_iter_centering=10, alpha=0.5):
    """
    Apply Moeboius inversions to minimize area distortion of map from mesh to sphere.
    
    Implementation of Algorithm 1 from:
    https://www.cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf
    
    Parameters
    ----------
    vertices_3d : np.array of shape (n_verts, 3)
        3d mesh vertices
    vertices_sphere : np.array of shape (n_verts, 3)
        Initial vertex positions on unit shpere
    tris : np.array of shape (n_faces, 3) and dtype int
        Faces of triangular mesh
    n_iter_centering : int
        Centering algorithm iterations.
    alpha : float between 0 and 1
        Learning rate. Lower values make the algorithm more stable
    
    Returns
    -------
    vertices_sphere_centered : np.array of shape (n_verts, 3)
        Centered sphere coordinates
    com_norm : float
        Distance of sphere vertex center of mass from origin. Low values
        indicate convergence of algorithm.
    """
    As = igl.doublearea(vertices_3d, tris)
    As /= As.sum()
    Vs = np.copy(vertices_sphere)
    for i in range(n_iter_centering):
        # compute triangle centroids
        Cs = Vs[tris].mean(axis=1)
        Cs = (Cs.T/np.linalg.norm(Cs,axis=-1)).T
        # compute center of mass, weighted by 3d areas
        mu = (As*Cs.T).sum(axis=1)
        # compute Jacobian and get inversion center
        J = (As*(np.eye(3) - np.einsum('vi,vj->vij', Cs, Cs)).T).sum(axis=-1)
        c = -alpha*np.linalg.inv(J)@mu
        # compute inversion
        Vs = ((1-np.linalg.norm(c)**2)*(Vs+c).T /np.linalg.norm(Vs+c, axis=1)**2).T + c
    return Vs, np.linalg.norm(mu)

# %% ../nbs/03d_conformal_wrapping.ipynb 42
def map_to_sphere(mesh, n_iter_centering=10, alpha=0.5):
    """
    Compute conformal map of mesh to unit sphere.
    
    First, remove one vertex (last one by default), and map the resulting disk-topology
    mesh to the plane using least squares conformal maps. Then map the plane to
    the sphere using stereographic projection.
    
    The conformal map is chosen so that area distortion is as small as possible by
    (a) optimizing over the scale ("radius") of the map to the disk and (b) "centering"
    the map using Algorithm 1 from cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf.
    
    This means the map is canonical up to rotations of the sphere.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a sphere, and should be triangular.
    n_iter_centering : int
        Centering algorithm iterations. If 0, no centerting is performed
    alpha : float between 0 and 1
        Learning rate. Lower values make the centering algorithm more stable
    
    Returns
    -------
    vertices_sphere : np.array
        Sphere coordinates
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    # remove "north pole" - by convention, the last vertex in the mesh
    north_pole = mesh.vertices.shape[0]-1
    faces_all = mesh.tris
    tri_mask = (faces_all==north_pole).any(axis=1) 
    faces_disk = faces_all[~tri_mask]
    vertices_disk = mesh.vertices[:-1]
    ## Find the open boundary
    bnd = igl.boundary_loop(faces_disk)
    ## least squares conformal map
    bnd = igl.boundary_loop(faces_disk)
    b = np.array([bnd[0], bnd[int(np.round(len(bnd)/2))]])
    bc = np.array([[0.0, -1.0], [0.0, 1.0]])
    _, uv = igl.lscm(vertices_disk, faces_disk, b, bc)
    uv = uv-uv.mean(axis=0)
    # map plane to sphere. the scale factor of the map mesh -> plane is arbitrary,
    # so we chose it in a way that minimizes area distortion
    areas = igl.doublearea(mesh.vertices, faces_all)
    areas = (areas/areas.mean())
    def get_distoration(R):
        """
        Measure area distortion as function of mesh -> plane scale factor.
        """
        coords_sphere = np.vstack([stereographic_plane_to_sphere(R*uv), np.array([0,0,1])])
        areas_sphere = igl.doublearea(coords_sphere, faces_all)
        areas_sphere = (areas_sphere/areas_sphere.mean())
        distortion = np.log(areas_sphere/areas)
        return np.abs(distortion).mean()
    R_opt = optimize.minimize_scalar(get_distoration, bracket=(1e-2, 1e5)).x
    vertices_sphere = np.vstack([stereographic_plane_to_sphere(R_opt*uv), np.array([0,0,1])])
    # center map to sphere using Moebius ivnersions
    if n_iter_centering > 0:
        vertices_sphere, _ = center_moebius(mesh.vertices, vertices_sphere, faces_all,
                                            n_iter_centering=n_iter_centering, alpha=alpha)
    return vertices_sphere

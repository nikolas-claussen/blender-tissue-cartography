# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03d_conformal_wrapping.ipynb.

# %% auto 0
__all__ = ['map_to_disk', 'compute_per_vertex_conformal_factor', 'get_rot_mat2d', 'rotational_align_disk', 'wrap_coords_via_disk',
           'find_conformal_boundary_conditions', 'stereographic_plane_to_sphere', 'stereographic_sphere_to_plane',
           'center_moebius', 'map_to_sphere', 'rotational_align_sphere', 'wrap_coords_via_sphere']

# %% ../nbs/03d_conformal_wrapping.ipynb 1
from . import io as tcio
from . import registration as tcreg
from . import wrapping as tcwrap
from . import rotation as tcrot

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import interpolate, ndimage, optimize, sparse, spatial
from skimage import registration, transform

import matplotlib as mpl

# %% ../nbs/03d_conformal_wrapping.ipynb 11
def map_to_disk(mesh, set_uvs=False):
    """
    Map mesh to unit disk by computing harmonic UV coordinates.
    
    The longest boundary loop of the mesh is mapped to the unit circle.
    Follows https://libigl.github.io/libigl-python-bindings/tut-chapter4/.
    
    The disk rotation angle is arbitrary
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    quantiles : tuple
        Image quantile to set to 0 and 1.
    set_uvs : bool
        whether to set the disk coordinates as UV coordinates of the mesh.
    
    Returns
    -------
    uv : np.array
        2d vertex coordinates mapping the mesh to the unit disk in [0,1]^1
    
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    ## Find the open boundary
    bnd = igl.boundary_loop(mesh.tris)
    assert len(bnd) > 0, "No boundary found! Your mesh may not be a disk" 

    ## Map the boundary to a circle, preserving edge proportions
    bnd_uv = igl.map_vertices_to_circle(mesh.vertices, bnd)

    ## Harmonic parametrization for the internal vertices
    uv = igl.harmonic(mesh.vertices, mesh.tris, bnd, bnd_uv, 1)
    uv = uv/2+np.array([0.5, 0.5])
    
    ## create new mesh
    if set_uvs:
        mesh.faces = [[[v,v] for v in fc] for fc in mesh.tris]
        mesh.texture_vertices = uv
    
    return uv

# %% ../nbs/03d_conformal_wrapping.ipynb 16
def compute_per_vertex_conformal_factor(vertices, faces, target_vertices, target_faces, cutoff=1e-15):
    """
    Compute conformal factor for map between meshes.
    
    The result is evaluated at the vertices of the target mesh.
    Faces must be such that faces[i] is mapped to target_faces[i].
    
    Parameters
    ----------
    vertices : np.array
        Mesh vertices.
    faces : np.array of shape (..., 3)
        Mesh faces. Must be triangular.
    target_vertices : np.array
        Target mesh vertices.
    target_faces : np.array of shape (..., 3)
        Target mesh faces. Must be triangular.
    cutoff : float
        Numerical cutoff for small target areas (avoid 0 division error)
    Returns
    -------
    area_ratio_at_vertices : np.array
        Conformal factor (area / target area) evaluated on target mesh vertices.
    """
    areas = igl.doublearea(vertices, faces)
    areas_target = np.clip(igl.doublearea(target_vertices, target_faces), cutoff, np.inf)
    area_ratio = areas/areas_target
    area_ratio_at_vertices = igl.average_onto_vertices(target_vertices, target_faces,
                                                       np.stack(target_vertices.shape[1]*[area_ratio]).T)[:,0]
    return area_ratio_at_vertices

# %% ../nbs/03d_conformal_wrapping.ipynb 17
def get_rot_mat2d(phi):
    """Get 2d rotation matrix with angle phi"""
    return np.array([[np.cos(phi), np.sin(phi)],[-np.sin(phi), np.cos(phi)]])

# %% ../nbs/03d_conformal_wrapping.ipynb 24
def rotational_align_disk(mesh_source, mesh_target, 
                          disk_uv_source=None, disk_uv_target=None,
                          q=0.05, n_grid=256):
    """
    Rotationally align two UV map to the disk by the conformal factor.
    
    Computes aligned UV coordinates. Assumes that the UV
    coordinates are in [0,1]^2. Rotational alignment works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the plane), which is rotated so that the maximum is at the y-axis
    via a Fourier transform.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    disk_uv_source : np.array or None
        Disk coordinates for each vertex in source mesh. Optional.
        If None, the UV coordinates of mesh_source are used.
    disk_uv_target : np.array or None
        Disk coordinates for each vertex in target mesh. Optional.
        If None, the UV coordinates of disk_uv_target are used.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment
    
    Returns
    -------
    new_texture_vertices_mesh_source : np.array
        Rotationally aligned texture vertices
    rot_mat : np.array of shape (2,2)
        Rotation matrix
    
    """
    if disk_uv_source is None:
        disk_uv_source = np.copy(mesh_source.texture_vertices)
        disk_tris_source = mesh_source.texture_tris
    else:
        disk_tris_source = mesh_source.tris
    if disk_uv_target is None:
        disk_uv_target = np.copy(mesh_target.texture_vertices)
        disk_tris_target = mesh_target.texture_tris
    else:
        disk_tris_target = mesh_target.tris

    # compute conformal distortion factors, clip to avoid outliers
    conformal_factor_source = compute_per_vertex_conformal_factor(mesh_source.vertices, mesh_source.tris,
                                                                  disk_uv_source, disk_tris_source)
    conformal_factor_source = np.clip(conformal_factor_source, np.quantile(conformal_factor_source, q),
                                      np.quantile(conformal_factor_source, 1-q))
    conformal_factor_target = compute_per_vertex_conformal_factor(mesh_target.vertices, mesh_target.tris,
                                                                  disk_uv_target, disk_tris_target)
    conformal_factor_target = np.clip(conformal_factor_target, np.quantile(conformal_factor_target, q),
                                      np.quantile(conformal_factor_target, 1-q))
    # interpolate onto a grid
    U, V = np.meshgrid(*2*[np.linspace(0, 1, n_grid)])
    interpolated_source = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*disk_uv_source.T,
                                                                              disk_tris_source),
                                                        conformal_factor_source)(U,V)
    interpolated_target = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*disk_uv_target.T,
                                                                              disk_tris_target),
                                                        conformal_factor_target)(U,V)
    # compute rotational alignment
    interpolated_source_polar = transform.warp_polar(interpolated_source, radius=n_grid/2-1)
    interpolated_target_polar = transform.warp_polar(interpolated_target, radius=n_grid/2-1)

    shifts, _, _ = registration.phase_cross_correlation(interpolated_source_polar, interpolated_target_polar,
                                                        reference_mask=~np.isnan(interpolated_source_polar),
                                                        moving_mask=~np.isnan(interpolated_target_polar),
                                                        normalization=None)

    rot_angle = shifts[0]*np.pi/180
    rot_mat = get_rot_mat2d(rot_angle)
    new_texture_vertices = (disk_uv_source-np.array([0.5,0.5]))@rot_mat.T
    new_texture_vertices += np.array([0.5,0.5])
    return new_texture_vertices, rot_mat

# %% ../nbs/03d_conformal_wrapping.ipynb 28
def wrap_coords_via_disk(mesh_source, mesh_target, disk_uv_source=None, disk_uv_target=None,
                         align=True, q=0.05, n_grid=256):
    """
    Map 3d coords of source mesh to target mesh via a disk parametrization.
    
    Disk parametrization can be provided or computed on the fly via harmonic coordinates.
    If desired, the two disks are also rotationally aligned.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    disk_uv_source : np.array or None
        Disk coordinates for each vertex in source mesh. Optional.
        If None, computed via map_to_disk.
    disk_uv_target : np.array or None
        Disk coordinates for each vertex in target mesh. Optional.
        If None, computed via map_to_disk.
    align : bool, default True
        Whether to rotationally align the parametrizations. If False, they are used as-is.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment.
        Higher values increase alignment precision.
    
    Returns
    -------
    new_coords : np.array
        New 3d vertex coordinates for mesh_source, lying on the surface
        defined by mesh_target
    """
    # compute harmonic map to disk
    if disk_uv_source is None:
        disk_uv_source = map_to_disk(mesh_source, set_uvs=False)
    if disk_uv_target is None:
        disk_uv_target = map_to_disk(mesh_target, set_uvs=False)
    # rotational alignment of parametrizations
    if align:
        disk_uv_source_aligned, _ = rotational_align_disk(mesh_source, mesh_target, disk_uv_source, disk_uv_target,
                                                          q=q, n_grid=n_grid)
    else:
        disk_uv_source_aligned = disk_uv_source
    # copy over 3d coordinates 
    new_coords = tcwrap.transfer_per_vertex_attribute(np.pad(disk_uv_source_aligned, ((0,0), (0,1))),
                                                      np.pad(disk_uv_target, ((0,0), (0,1))),
                                                      mesh_target.tris, mesh_target.vertices)
    return new_coords

# %% ../nbs/03d_conformal_wrapping.ipynb 40
def find_conformal_boundary_conditions(vertices_disk, faces_disk, bnd, tol=1e-2):
    """
    Find boundary condition for map to disk most compatible with conformal map.
    
    Uses stupid method - direct optimization. Not to be used beyond beyond boundaries 
    more than a few vertices long.
    
    To do: look at https://arxiv.org/pdf/1704.06873
    """
    angles_3d = igl.internal_angles(vertices_disk, faces_disk)
    bnd_uv_initial = igl.map_vertices_to_circle(vertices_disk, bnd)
    phi_bnd_initial = np.arctan2(*bnd_uv_initial.T)
    def _conformal_err(phi_bnd):
        bnd_uv = np.stack([np.sin(phi_bnd), np.cos(phi_bnd)], axis=-1)
        uv = igl.harmonic(vertices_disk, faces_disk, bnd, bnd_uv, 1)
        angles_uv = igl.internal_angles(uv, faces_disk)
        return np.nanmean(np.abs(angles_3d-angles_uv))

    sol = optimize.minimize(_conformal_err, phi_bnd_initial, method="BFGS", tol=tol,
                           options={"maxiter": 100})
    bnd_final = np.stack([np.sin(sol.x), np.cos(sol.x)], axis=-1)
    return bnd_final

# %% ../nbs/03d_conformal_wrapping.ipynb 56
def stereographic_plane_to_sphere(uv):
    """
    Stererographic projection from plane to unit sphere from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    uv should be an array of shape (..., 2)
    """
    return (np.stack([2*uv[:,0], 2*uv[:,1], uv[:,0]**2+uv[:,1]**2-1], axis=0) / (1+uv[:,0]**2+uv[:,1]**2)).T
    
def stereographic_sphere_to_plane(pts):
    """
    Stererographic projection from unit sphere to plane from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    pts should be an array of shape (..., 3)
    """
    assert np.allclose(np.linalg.norm(pts, axis=1), 1, rtol=1e-03, atol=1e-04), "Points not on unit sphere!"
    return (np.stack([pts[:,0], pts[:,1]], axis=0)/(1-pts[:,2])).T

# %% ../nbs/03d_conformal_wrapping.ipynb 60
def center_moebius(vertices_3d, vertices_sphere, tris, n_iter_centering=10, alpha=0.5):
    """
    Apply Moeboius inversions to minimize area distortion of map from mesh to sphere.
    
    Implementation of Algorithm 1 from:
    https://www.cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf
    
    Parameters
    ----------
    vertices_3d : np.array of shape (n_verts, 3)
        3d mesh vertices
    vertices_sphere : np.array of shape (n_verts, 3)
        Initial vertex positions on unit shpere
    tris : np.array of shape (n_faces, 3) and dtype int
        Faces of triangular mesh
    n_iter_centering : int
        Centering algorithm iterations.
    alpha : float between 0 and 1
        Learning rate. Lower values make the algorithm more stable
    
    Returns
    -------
    vertices_sphere_centered : np.array of shape (n_verts, 3)
        Centered sphere coordinates
    com_norm : float
        Distance of sphere vertex center of mass from origin. Low values
        indicate convergence of algorithm.
    """
    As = igl.doublearea(vertices_3d, tris)
    As /= As.sum()
    Vs = np.copy(vertices_sphere)
    for i in range(n_iter_centering):
        # compute triangle centroids
        Cs = Vs[tris].mean(axis=1)
        Cs = (Cs.T/np.linalg.norm(Cs,axis=-1)).T
        # compute center of mass, weighted by 3d areas
        mu = (As*Cs.T).sum(axis=1)
        # compute Jacobian and get inversion center
        J = (As*(np.eye(3) - np.einsum('vi,vj->vij', Cs, Cs)).T).sum(axis=-1)
        c = -alpha*np.linalg.inv(J)@mu
        # compute inversion
        Vs = ((1-np.linalg.norm(c)**2)*(Vs+c).T /np.linalg.norm(Vs+c, axis=1)**2).T + c
    return Vs, np.linalg.norm(mu)

# %% ../nbs/03d_conformal_wrapping.ipynb 70
def map_to_sphere(mesh, method="harmonic", R_max=100, n_iter_centering=20, alpha=0.5, set_uvs=False):
    """
    Compute conformal map of mesh to unit sphere.
    
    First, remove one vertex (last one by default), and map the resulting disk-topology
    mesh to the plane using least squares conformal maps. Then map the plane to
    the sphere using stereographic projection.
    
    The conformal map is chosen so that area distortion is as small as possible by
    (a) optimizing over the scale ("radius") of the map to the disk and (b) "centering"
    the map using Algorithm 1 from cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf.
    
    This means the map is canonical up to rotations of the sphere.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a sphere, and should be triangular.
    method : str, "harmonic", "harmonic-conformal-boundary", "LSCM"
        Method for comuting the map from sphere \ north pole to plane.
        Recommended: harmonic
    R_max :  float
        Maximum radius to consider when computing inverse stereographic
        projection. If you get weird results, try a lower value.
    n_iter_centering : int
        Centering algorithm iterations. If 0, no centerting is performed
    alpha : float between 0 and 1
        Learning rate. Lower values make the centering algorithm more stable
    set_uvs : bool, default False
        Whether to set spherical coordinates phi, theta as UV coordinates.
        Will scale by dividing phi, theta by 2pi so they fit in the UV square.
        Will overwrite existing UV coordinates
    Returns
    -------
    vertices_sphere : np.array
        Sphere coordinates. Same shape as mesh.vertices
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    # remove "north pole" - by convention, the last vertex in the mesh
    north_pole = mesh.vertices.shape[0]-1
    faces_all = mesh.tris
    tri_mask = (faces_all==north_pole).any(axis=1) 
    faces_disk = faces_all[~tri_mask]
    vertices_disk = mesh.vertices[:-1]
    ## Find the open boundary
    bnd = igl.boundary_loop(faces_disk)
    assert method in ["LSCM", "harmonic", "harmonic-conformal-boundary"], "Invalid method"
    if method == "LSCM": ## least squares conformal map
        bnd = igl.boundary_loop(faces_disk)
        b = np.array([bnd[0], bnd[int(np.round(len(bnd)/2))]])
        bc = np.array([[0.0, -1.0], [0.0, 1.0]])
        _, uv = igl.lscm(vertices_disk, faces_disk, b, bc)
        uv = uv-uv.mean(axis=0)
    if method == "harmonic-conformal-boundary": # harmonic map
        bnd_uv = find_conformal_boundary_conditions(vertices_disk, faces_disk, bnd)
        uv = igl.harmonic(vertices_disk, faces_disk, bnd, bnd_uv, 1)
    if method == "harmonic": # harmonic map
        bnd_uv = igl.map_vertices_to_circle(vertices_disk, bnd)
        uv = igl.harmonic(vertices_disk, faces_disk, bnd, bnd_uv, 1)
    # map plane to sphere. the scale factor of the map mesh -> plane is arbitrary,
    # so we chose it in a way that minimizes area distortion
    areas = igl.doublearea(mesh.vertices, faces_all)
    areas = (areas/areas.mean())
    def get_distoration(R):
        """
        Measure area distortion as function of mesh -> plane scale factor.
        """
        coords_sphere = np.vstack([stereographic_plane_to_sphere(R*uv), np.array([0,0,1])])
        areas_sphere = igl.doublearea(coords_sphere, faces_all)
        areas_sphere = np.clip(areas_sphere, 1e-20, 4*np.pi)
        areas_sphere = (areas_sphere/areas_sphere.mean())
        distortion = np.log(areas_sphere/areas)
        return np.abs(distortion).mean()
    sol = optimize.minimize_scalar(get_distoration, bounds=(0, R_max))
    R_opt = sol.x
    vertices_sphere = np.vstack([stereographic_plane_to_sphere(R_opt*uv), np.array([0,0,1])])
    # center map to sphere using Moebius ivnersions
    if n_iter_centering > 0:
        vertices_sphere, _ = center_moebius(mesh.vertices, vertices_sphere, faces_all,
                                            n_iter_centering=n_iter_centering, alpha=alpha)
    if set_uvs:
        _, theta, phi = tcrot.cartesian_to_spherical(vertices_sphere)
        theta = np.clip(theta/(2*np.pi), 0, 1)
        phi = np.clip(phi/(2*np.pi)+0.5, 0, 1)
        mesh.faces = [[[v,v] for v in fc] for fc in mesh.tris]
        mesh.texture_vertices = np.stack([phi, theta], axis=-1)
    if igl.doublearea(vertices_sphere, faces_all).min() <= 0:
        warnings.warn("Warning: some triangle on sphere have 0 or negative area", RuntimeWarning)
        
    return vertices_sphere

# %% ../nbs/03d_conformal_wrapping.ipynb 89
def rotational_align_sphere(mesh_source, mesh_target, coords_sphere_source, coords_sphere_target,
                            allow_flip=False, max_l=10, n_angle=100, n_subdiv_axes=1, maxfev=100):
    """
    Rotationally align two UV map to the sphere by the conformal factor.
    
    Computes aligned spherical coordinates. Rotational alignment works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the sphere), and optimizing over rotations to find the one
    which leads to the best alignment. This works via an expansion in
    spherical harmonics. See tcrot.rotational_alignment
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a sphere (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a sphere (potentially with holes),
        and should be triangular.
    coords_sphere_source : np.array or None
        Sphere coordinates for each vertex in source mesh.
        If None, the UV coordinates are interpreted as angles 2*pi*u=phi,
        2*pi*v=theta.
    coords_sphere_target : np.array or None
        Sphere coordinates for each vertex in source mesh.
        If None, the UV coordinates are interpreted as angles 2*pi*u=phi,
        2*pi*v=theta.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1. 
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    maxfev : int
        Number of function evaluations during fine optimization.
    
    Returns
    -------
    coords_sphere_source_rotated : np.array
        Rotationally aligned sphere vertices
    rot_mat : np.array of shape (3,3)
        Rotation matrix
    overlap  : float
        How well the conformal factors overlap. 1 = perfect overlap.
    
    """
    if coords_sphere_source is None:
        coords_sphere_source = spherical_to_cartesian(1, 2*np.pi*mesh_source.texture_vertices[:,1],
                                                      2*np.pi*mesh_source.texture_vertices[:,0])
        tris_sphere_source = mesh_source.texture_tris
    else:
        tris_sphere_source = mesh_source.tris

    if coords_sphere_target is None:
        coords_sphere_target = spherical_to_cartesian(1, 2*np.pi*mesh_target.texture_vertices[:,1],
                                                      2*np.pi*mesh_target.texture_vertices[:,0])
        tris_sphere_target = mesh_target.texture_tris
    else:
        tris_sphere_target = mesh_target.tris

    # compute the conformal factor
    conformal_factor_source = compute_per_vertex_conformal_factor(mesh_source.vertices, mesh_source.tris,
                                                                  coords_sphere_source, tris_sphere_source)
    conformal_factor_target = compute_per_vertex_conformal_factor(mesh_target.vertices, mesh_target.tris,
                                                                  coords_sphere_target, tris_sphere_target)
    # transform to log
    signal_source = np.log(conformal_factor_source)
    signal_target = np.log(conformal_factor_target)

    # compute the spherical harmonics coefficients
    max_l = 10
    _, theta_source, phi_source = tcrot.cartesian_to_spherical(coords_sphere_source)
    _, theta_target, phi_target = tcrot.cartesian_to_spherical(coords_sphere_target)
    weights_source = igl.doublearea(coords_sphere_source, tris_sphere_source)/2
    weights_source = igl.average_onto_vertices(coords_sphere_source, tris_sphere_source,
                                               np.stack(3*[weights_source], axis=-1))[:,0]
    weights_target = igl.doublearea(coords_sphere_target, tris_sphere_target)/2
    weights_target = igl.average_onto_vertices(coords_sphere_target, tris_sphere_target,
                                               np.stack(3*[weights_target], axis=-1))[:,0]
    # subtract mean
    signal_source -= np.average(signal_source, weights=weights_source)
    signal_target -= np.average(signal_target, weights=weights_target)
    coeffs_source = tcrot.compute_spherical_harmonics_coeffs(signal_source, phi_source, theta_source,
                                                             weights_source, max_l=max_l)
    coeffs_target = tcrot.compute_spherical_harmonics_coeffs(signal_target, phi_target, theta_target,
                                                             weights_target, max_l=max_l)
        
    # compute the rotation to match them.
    R_refined, overlap = tcrot.rotational_alignment(coeffs_source, coeffs_target, max_l=max_l,
                                                    n_angle=n_angle, n_subdiv_axes=n_subdiv_axes, maxfev=maxfev,
                                                    allow_flip=allow_flip)

    return coords_sphere_source @ R_refined.T, R_refined, overlap

# %% ../nbs/03d_conformal_wrapping.ipynb 96
def wrap_coords_via_sphere(mesh_source, mesh_target, coords_sphere_source=None, coords_sphere_target=None,
                           method="harmonic", n_iter_centering=10, alpha=0.5,
                           align=True, allow_flip=False, max_l=10, n_angle=100, n_subdiv_axes=1, maxfev=100):
    """
    Map 3d coords of source mesh to target mesh via a sphere parametrization.
    
    Sphere parametrizations can be provided or computed on the fly using the least-area
    distorting conformal map to the sphere (see map_to_sphere). If desired, the two
    parametrizations are also aligned with respect to 3d rotations using mesh shape,
    using spherical harmonics. See rotational_align_sphere for details.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    coords_sphere_source : np.array or None
        Sphere coordinates for each vertex in source mesh. Optional.
        If None, computed via map_to_sphere.
    coords_sphere_target : np.array or None
        Sphere coordinates for each vertex in target mesh. Optional.
        If None, computed via map_to_sphere.
    method : str, "harmonic" or "LSCM"
        Method for comuting the map from sphere \ north pole to plane
    n_iter_centering : int
        Centering algorithm iterations for computing map to sphere. If 0, no centerting is performed
    alpha : float between 0 and 1
        Learning rate for computing map to sphere. Lower values make the centering algorithm more stable.
    align : bool, default True
        Whether to rotationally align the parametrizations. If False, they are used as-is.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1 for rotational alignment.
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    maxfev : int
        Number of function evaluations during fine optimization for rotational alignment.

    Returns
    -------
    new_coords : np.array
        New 3d vertex coordinates for mesh_source, lying on the surface
        defined by mesh_target
    overlap : np.array
        Overlap of conformal factor (area distortion) on sphere of the two meshes. Only returned if align is True.
        1 indicates perfect overlap.
    """
    # compute harmonic map to disk
    if coords_sphere_source is None:
        coords_sphere_source = map_to_sphere(mesh_source, n_iter_centering=n_iter_centering, alpha=alpha,
                                             set_uvs=False, method=method)
    if coords_sphere_target is None:
        coords_sphere_target = map_to_sphere(mesh_target, n_iter_centering=n_iter_centering, alpha=alpha,
                                             set_uvs=False, method=method)
    # rotational alignment of parametrizations
    if align:
        coords_sphere_source_aligned, R, overlap = rotational_align_sphere(mesh_source, mesh_target,
                                                coords_sphere_source, coords_sphere_target,
                                                allow_flip=allow_flip, max_l=max_l,
                                                n_angle=n_angle, n_subdiv_axes=n_subdiv_axes, maxfev=maxfev)
    else:
        coords_sphere_source_aligned = coords_sphere_source
    # copy over 3d coordinates 
    new_coords = tcwrap.transfer_per_vertex_attribute(coords_sphere_source_aligned,
                                                      coords_sphere_target,
                                                      mesh_target.tris, mesh_target.vertices)
    if align:
        return new_coords, overlap
    return new_coords

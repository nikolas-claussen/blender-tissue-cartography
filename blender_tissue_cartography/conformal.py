# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03d_conformal_wrapping.ipynb.

# %% auto 0
__all__ = ['map_to_disk', 'rot_mat', 'transfer_per_verte_attribute', 'rotational_align_disk', 'extrapolate_fast_marching',
           'wrap_coords_via_disk_skfmm', 'wrap_coords_via_disk', 'stereographic_plane_to_sphere',
           'stereographic_sphere_to_plane', 'center_moebius', 'map_to_sphere', 'rotation_alignment_refined']

# %% ../nbs/03d_conformal_wrapping.ipynb 1
from . import io as tcio
from . import registration as tcreg
from . import wrapping as tcwrap
from . import rotation as tcrot

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import interpolate, ndimage, optimize, sparse, spatial
from skimage import registration, transform

import matplotlib as mpl

import skfmm

# %% ../nbs/03d_conformal_wrapping.ipynb 10
def map_to_disk(mesh):
    """
    Map mesh to unit disk by computing harmonic UV coordinates.
    
    The longest boundary loop of the mesh is mapped to the unit circle.
    Follows https://libigl.github.io/libigl-python-bindings/tut-chapter4/.
    
    The disk rotation angle is arbitrary
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    quantiles : tuple
        Image quantile to set to 0 and 1.
    
    Returns
    -------
    mesh_parametrized : tcio.ObjMesh
        Mesh with UV coordinates mapping it to the disk.
    
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    ## Find the open boundary
    bnd = igl.boundary_loop(mesh.tris)
    assert len(bnd) > 0, "No boundary found! Your mesh may not be a disk" 

    ## Map the boundary to a circle, preserving edge proportions
    bnd_uv = igl.map_vertices_to_circle(mesh.vertices, bnd)

    ## Harmonic parametrization for the internal vertices
    uv = igl.harmonic(mesh.vertices, mesh.tris, bnd, bnd_uv, 1)
    uv = uv/2+np.array([0.5, 0.5])
    
    ## create new mesh
    mesh_parametrized = tcio.ObjMesh(vertices=mesh.vertices, texture_vertices=uv, normals=None,
                                faces=[[[v,v] for v in fc] for fc in mesh.tris])
    mesh_parametrized.set_normals()
    
    return mesh_parametrized

# %% ../nbs/03d_conformal_wrapping.ipynb 15
def rot_mat(phi):
    """Get rotation matrix with angle phi"""
    return np.array([[np.cos(phi), np.sin(phi)],[-np.sin(phi), np.cos(phi)]])

# %% ../nbs/03d_conformal_wrapping.ipynb 22
def transfer_per_verte_attribute(source_vertices, target_vertices, target_faces, attribute):
    """
    Transfer a per-vertex attribute from one mesh to another via barycentric interpolation.
    
    For each point among the source vertices, find the closest point on the target mesh
    (not necessarily a target vertex!), and find the value of the per-target-vertex
    attribute "attribute" via barycentric interpolation.
    
    This can be used to copy e.g. 3d coordinates from one mesh to another given 
    a common paramatrization (e.g. to disk or sphere)/
    
    Parameters
    ----------
    source_vertices : np.array of shape (..., 3)
        Vertices onto which to transfer the attribute
    target_vertices : np.array of shape (..., 3)
        Vertices on which the attribute is defined
    target_faces : np.arraay of shape (..., 3)
        Triangular faces of target mesh, indices into the target_vertices array
    attribute : np.array
        Must have same length of axis 0 as target_vertices
        
    Returns
    -------
    transfered_attribute : np.array
        Same length of axis 0 as source_vertices.
    
    """
    distances, indices, points = igl.point_mesh_squared_distance(source_vertices, target_vertices, target_tris)
    hit_tris = target_tris[indices]
    # barycentric coordinates of the hit points. need small hack for data type issue 
    barycentric = igl.barycentric_coordinates_tri(np.array(points, order="C"),
                                                 *np.array(target_vertices[hit_tris].transpose((1,0,2)), order='C'))
    interpolated = np.einsum('vt,vt...->v...', barycentric, attribute[hit_tris])
    return interpolated

# %% ../nbs/03d_conformal_wrapping.ipynb 26
def rotational_align_disk(mesh_source, mesh_target, q=0.05, n_grid=256):
    """
    Rotationally align two UV map to the disk by the conformal factor.
    
    Computes aligned UV coordinates. Assumes that the UV
    coordinates are in [0,1]^2. Rotational alignment works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the plane), which is rotated so that the maximum is at the y-axis
    via a Fourier transform.
    
    Parameters
    ----------
    mesh_source : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcio.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment
    
    Returns
    -------
    new_texture_vertices_mesh_source : np.array
        Rotationally aligned texture vertices
    
    """
    assert mesh_source.tris.shape==mesh_source.texture_tris.shape,\
        "3d and UV triangulations must be identical"
    assert (mesh_source.tris==mesh_source.texture_tris).all(),\
        "3d and UV triangulations must be identical"
    assert mesh_target.tris.shape==mesh_target.texture_tris.shape,\
        "3d and UV triangulations must be identical"
    assert (mesh_target.tris==mesh_target.texture_tris).all(),\
        "3d and UV triangulations must be identical"
    # compute conformal distortion factors, clip to avoid outliers
    conformal_factor_source = (igl.doublearea(mesh_source.vertices, mesh_source.tris)/
                               igl.doublearea(mesh_source.texture_vertices, mesh_source.texture_tris))
    conformal_factor_source = np.clip(conformal_factor_source, np.quantile(conformal_factor_source, q),
                                      np.quantile(conformal_factor_source, 1-q))
    uv_centroids_source = mesh_source.texture_vertices[mesh_source.texture_tris].mean(axis=1)
    conformal_factor_target = (igl.doublearea(mesh_target.vertices, mesh_target.tris)/
                               igl.doublearea(mesh_target.texture_vertices, mesh_target.texture_tris))
    conformal_factor_target = np.clip(conformal_factor_target, np.quantile(conformal_factor_target, q),
                                      np.quantile(conformal_factor_target, 1-q))
    uv_centroids_target = mesh_target.texture_vertices[mesh_target.texture_tris].mean(axis=1)
    # interpolate onto a grid
    U, V = np.meshgrid(*2*[np.linspace(0, 1, n_grid)])
    conformal_factor_source = igl.average_onto_vertices(mesh_source.vertices, mesh_source.texture_tris,
                                                        np.stack(3*[conformal_factor_source], axis=-1))[:,0]
    conformal_factor_target = igl.average_onto_vertices(mesh_target.vertices, mesh_target.texture_tris,
                                                        np.stack(3*[conformal_factor_target], axis=-1))[:,0]
    interpolated_source = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*mesh_source.texture_vertices.T,
                                                                              mesh_source.texture_tris),
                                                        conformal_factor_source)(U,V)
    interpolated_target = mpl.tri.LinearTriInterpolator(mpl.tri.Triangulation(*mesh_target.texture_vertices.T,
                                                                              mesh_target.texture_tris),
                                                        conformal_factor_target)(U,V)
    # compute rotational alignment
    interpolated_source_polar = transform.warp_polar(interpolated_source, radius=n_grid/2-1)
    interpolated_target_polar = transform.warp_polar(interpolated_target, radius=n_grid/2-1)

    shifts, _, _ = registration.phase_cross_correlation(interpolated_source_polar, interpolated_target_polar,
                                                        reference_mask=~np.isnan(interpolated_source_polar),
                                                        moving_mask=~np.isnan(interpolated_target_polar),
                                                        normalization=None)

    rot_angle = shifts[0]*np.pi/180
    new_texture_vertices = (mesh_source.texture_vertices-np.array([0.5,0.5]))@rot_mat(-rot_angle)
    new_texture_vertices += np.array([0.5,0.5])
    return new_texture_vertices

# %% ../nbs/03d_conformal_wrapping.ipynb 30
def extrapolate_fast_marching(arr):
    """Fill nans in 2d numpy array via fast-marching extrapolation."""
    mask = ~ndimage.binary_erosion(~np.isnan(arr), iterations=2)
    extended = skfmm.extension_velocities(mask, arr)[1]
    return extended

# %% ../nbs/03d_conformal_wrapping.ipynb 31
def wrap_coords_via_disk_skfmm(mesh_source, mesh_target, n_grid=512):
    """
    Map 3d coords of source mesh to target mesh via a disk parametrization. 
    
    """
    # compute harmonic map to disk
    mesh_source_disk = map_to_disk(mesh_source)
    mesh_target_disk = map_to_disk(mesh_target)
    # rotational alignment of parametrizations
    mesh_source_disk.texture_vertices = rotational_align_disk(mesh_source_disk, mesh_target_disk)
    # interpolate 3d coordinates. we use a grid and extend the interpolated UV coordinates
    # to the whole UV square in order to avoid issues with the disk boundary.
    U, V = np.meshgrid(*2*[np.linspace(0, 1, n_grid)])
    triangulation_target = mpl.tri.Triangulation(*mesh_target_disk.texture_vertices.T,
                                                 mesh_target_disk.texture_tris)
    interpolators = [mpl.tri.LinearTriInterpolator(triangulation_target, x) for x in mesh_target_disk.vertices.T]
    interpolated = np.stack([extrapolate_fast_marching(np.array(f(U, V))) for f in interpolators], axis=0)
    # interpolate onto source mesh
    new_coords = np.stack([interpolate.interpn((U[0], V[:,0]), x, mesh_source_disk.texture_vertices[:,::-1])
                           for x in interpolated], axis=-1)
    return new_coords

# %% ../nbs/03d_conformal_wrapping.ipynb 32
def wrap_coords_via_disk(mesh_source, mesh_target):
    """
    Map 3d coords of source mesh to target mesh via a disk parametrization. 
    
    """
    # compute harmonic map to disk
    mesh_source_disk = map_to_disk(mesh_source)
    mesh_target_disk = map_to_disk(mesh_target)
    # rotational alignment of parametrizations
    mesh_source_disk.texture_vertices = rotational_align_disk(mesh_source_disk, mesh_target_disk)
    # copy over 3d coordinates 
    new_coords = transfer_per_verte_attribute(np.pad(mesh_source_disk.texture_vertices, ((0,0), (0,1))),
                                              np.pad(mesh_target_disk.texture_vertices, ((0,0), (0,1))),
                                              mesh_target_disk.texture_tris,
                                              mesh_target.vertices)
    return new_coords

# %% ../nbs/03d_conformal_wrapping.ipynb 44
def stereographic_plane_to_sphere(uv):
    """
    Stererographic projection from plane to unit sphere from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    uv should be an array of shape (..., 2)
    """
    return (np.stack([2*uv[:,0], 2*uv[:,1], uv[:,0]**2+uv[:,1]**2-1], axis=0) / (1+uv[:,0]**2+uv[:,1]**2)).T
    
def stereographic_sphere_to_plane(pts):
    """
    Stererographic projection from unit sphere to plane from north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    pts should be an array of shape (..., 3)
    """
    assert np.allclose(np.linalg.norm(pts, axis=1), 1, rtol=1e-03, atol=1e-04), "Points not on unit sphere!"
    return (np.stack([pts[:,0], pts[:,1]], axis=0)/(1-pts[:,2])).T

# %% ../nbs/03d_conformal_wrapping.ipynb 48
def center_moebius(vertices_3d, vertices_sphere, tris, n_iter_centering=10, alpha=0.5):
    """
    Apply Moeboius inversions to minimize area distortion of map from mesh to sphere.
    
    Implementation of Algorithm 1 from:
    https://www.cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf
    
    Parameters
    ----------
    vertices_3d : np.array of shape (n_verts, 3)
        3d mesh vertices
    vertices_sphere : np.array of shape (n_verts, 3)
        Initial vertex positions on unit shpere
    tris : np.array of shape (n_faces, 3) and dtype int
        Faces of triangular mesh
    n_iter_centering : int
        Centering algorithm iterations.
    alpha : float between 0 and 1
        Learning rate. Lower values make the algorithm more stable
    
    Returns
    -------
    vertices_sphere_centered : np.array of shape (n_verts, 3)
        Centered sphere coordinates
    com_norm : float
        Distance of sphere vertex center of mass from origin. Low values
        indicate convergence of algorithm.
    """
    As = igl.doublearea(vertices_3d, tris)
    As /= As.sum()
    Vs = np.copy(vertices_sphere)
    for i in range(n_iter_centering):
        # compute triangle centroids
        Cs = Vs[tris].mean(axis=1)
        Cs = (Cs.T/np.linalg.norm(Cs,axis=-1)).T
        # compute center of mass, weighted by 3d areas
        mu = (As*Cs.T).sum(axis=1)
        # compute Jacobian and get inversion center
        J = (As*(np.eye(3) - np.einsum('vi,vj->vij', Cs, Cs)).T).sum(axis=-1)
        c = -alpha*np.linalg.inv(J)@mu
        # compute inversion
        Vs = ((1-np.linalg.norm(c)**2)*(Vs+c).T /np.linalg.norm(Vs+c, axis=1)**2).T + c
    return Vs, np.linalg.norm(mu)

# %% ../nbs/03d_conformal_wrapping.ipynb 50
def map_to_sphere(mesh, n_iter_centering=10, alpha=0.5):
    """
    Compute conformal map of mesh to unit sphere.
    
    First, remove one vertex (last one by default), and map the resulting disk-topology
    mesh to the plane using least squares conformal maps. Then map the plane to
    the sphere using stereographic projection.
    
    The conformal map is chosen so that area distortion is as small as possible by
    (a) optimizing over the scale ("radius") of the map to the disk and (b) "centering"
    the map using Algorithm 1 from cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf.
    
    This means the map is canonical up to rotations of the sphere.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
        Mesh. Must be topologically a sphere, and should be triangular.
    n_iter_centering : int
        Centering algorithm iterations. If 0, no centerting is performed
    alpha : float between 0 and 1
        Learning rate. Lower values make the centering algorithm more stable
    
    Returns
    -------
    vertices_sphere : np.array
        Sphere coordinates
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    # remove "north pole" - by convention, the last vertex in the mesh
    north_pole = mesh.vertices.shape[0]-1
    faces_all = mesh.tris
    tri_mask = (faces_all==north_pole).any(axis=1) 
    faces_disk = faces_all[~tri_mask]
    vertices_disk = mesh.vertices[:-1]
    ## Find the open boundary
    bnd = igl.boundary_loop(faces_disk)
    ## least squares conformal map
    bnd = igl.boundary_loop(faces_disk)
    b = np.array([bnd[0], bnd[int(np.round(len(bnd)/2))]])
    bc = np.array([[0.0, -1.0], [0.0, 1.0]])
    _, uv = igl.lscm(vertices_disk, faces_disk, b, bc)
    uv = uv-uv.mean(axis=0)
    # map plane to sphere. the scale factor of the map mesh -> plane is arbitrary,
    # so we chose it in a way that minimizes area distortion
    areas = igl.doublearea(mesh.vertices, faces_all)
    areas = (areas/areas.mean())
    def get_distoration(R):
        """
        Measure area distortion as function of mesh -> plane scale factor.
        """
        coords_sphere = np.vstack([stereographic_plane_to_sphere(R*uv), np.array([0,0,1])])
        areas_sphere = igl.doublearea(coords_sphere, faces_all)
        areas_sphere = (areas_sphere/areas_sphere.mean())
        distortion = np.log(areas_sphere/areas)
        return np.abs(distortion).mean()
    R_opt = optimize.minimize_scalar(get_distoration, bracket=(1e-2, 1e5)).x
    vertices_sphere = np.vstack([stereographic_plane_to_sphere(R_opt*uv), np.array([0,0,1])])
    # center map to sphere using Moebius ivnersions
    if n_iter_centering > 0:
        vertices_sphere, _ = center_moebius(mesh.vertices, vertices_sphere, faces_all,
                                            n_iter_centering=n_iter_centering, alpha=alpha)
    return vertices_sphere

# %% ../nbs/03d_conformal_wrapping.ipynb 76
def _get_minus_overlap(q, sph_harmonics_source, sph_harmonics_target, max_l=None, binomial_matrix=None,):
    """
    Get negative overlap between spherical harmonics, as function of rotation q, for optimization.
    """
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])    
    corr_coeff = 0
    for l in range(0, max_l):
        D_matrix = get_wigner_D_matrix(q/np.linalg.norm(q),
                                       l=l, binomial_matrix=binomial_matrix)
        corr_coeff += np.sum(D_matrix@spherical_harmonics_coeffs_direct[l]
                             *np.conjugate(spherical_harmonics_coeffs_rotated[l]))
    normalization = np.sqrt(np.abs(np.sum([val.dot(np.conjugate(val)) for val in sph_harmonics_source.values()])
                                  *np.sum([val.dot(np.conjugate(val)) for val in sph_harmonics_target.values()])))
    return -np.abs(corr_coeff)/normalization

def rotation_alignment_refined(sph_harmonics_source, sph_harmonics_target, q_initial,
                               max_l=None, maxfev=200):
    """
    Refine rotational alignment between two signals on sphere by optimization.
    
    The two signals have to be represented by their spherical harmonics coefficients.
    Uses Wigner-D matrices to calculate the overlap between the two signals
    and uses Nelder-Mead optimization to find the best one.
    
    Requires a good initial guess for the rotation, as created by 
    rotation_alignment_brute_force.
    
    The rotation is such that it transforms the source signal to match the target.
        
    Parameters
    ----------
    sph_harmonics_source : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Source signal, to be
        transformed.
    sph_harmonics_target : dict of np.array
        Dictionary, indexed by total angular momentum l=0 ,..., max_l. Each entry is a vector
        of coefficients for the different values of m=-2l,...,2*l. Target signal.
    q_initial : 4d np.array
        Initial rotation as quaternion
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    maxfev : int
        Number of function evaluations during optimization.This parameter has
        the strongest influence on the run time.
    
    Returns
    -------
    optimal_rotation : 4d np.array
        Best rotation as unit quaternion.
    overlap : float
        Normalized overlap. 1=perfect alignment.
    overlap_initial : float
        Normalized overlap of initial condition. 1=perfect alignment. 
    """
    if max_l is None:
        max_l = min([max(sph_harmonics_source.keys()), max(sph_harmonics_target.keys())])
    args = (sph_harmonics_source, sph_harmonics_target, max_l, get_binomial_matrix(2*max_l))
    sol = optimize.minimize(_get_minus_overlap, q_initial, args=args, method="Nelder-Mead", tol=1e-5,
                            options={"maxfev": maxfev})
    return sol.x/np.linalg.norm(sol.x), sol.fun, get_minus_overlap(q_opt, *args)



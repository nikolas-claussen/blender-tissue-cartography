# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/06_harmonic_wrapping.ipynb.

# %% auto 0
__all__ = ['map_to_disk', 'get_rot_mat2d', 'rotational_align_disk', 'wrap_coords_via_disk', 'polygon_area', 'polygon_centroid',
           'xy_to_complex', 'complex_to_xy', 'moebius_disk', 'map_cylinder_to_disk', 'wrap_coords_via_disk_cylinder',
           'stereographic_plane_to_sphere', 'stereographic_sphere_to_plane', 'center_moebius', 'map_to_sphere',
           'rotational_align_sphere', 'wrap_coords_via_sphere']

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 3
from . import io as tcio
from . import mesh as tcmesh

from . import interpolation as tcinterp
from . import rotation as tcrot
from . import diffgeo as tcdfg

import numpy as np
from copy import deepcopy
import warnings
import igl

from scipy import interpolate, ndimage, optimize, sparse, spatial
from skimage import registration, transform

import matplotlib as mpl

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 8
def map_to_disk(mesh, bnd=None, set_uvs=False):
    """
    Map mesh to unit disk by computing harmonic UV coordinates.
    
    The longest boundary loop of the mesh is mapped to the unit circle.
    Follows https://libigl.github.io/libigl-python-bindings/tut-chapter4/.
    Note: the disk is centered at (1/2, 1/2).
    
    The disk rotation angle is arbitrary
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    bnd : np.array of ints or None
        Boundary to map to the unit circle. If None, computed automatically.
    set_uvs : bool
        whether to set the disk coordinates as UV coordinates of the mesh.
    
    Returns
    -------
    uv : np.array
        2d vertex coordinates mapping the mesh to the unit disk in [0,1]^1
    
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    ## Find the open boundary
    if bnd is None:
        bnd = igl.boundary_loop(mesh.tris)
    assert len(bnd) > 0, "No boundary found! Your mesh may not be a disk" 

    ## Map the boundary to a circle, preserving edge proportions
    bnd_uv = igl.map_vertices_to_circle(mesh.vertices, bnd)

    ## Harmonic parametrization for the internal vertices
    uv = igl.harmonic(mesh.vertices, mesh.tris, bnd, bnd_uv, 1)
    uv = uv/2+np.array([0.5, 0.5])
    
    ## create new mesh
    if set_uvs:
        mesh.faces = [[[v,v] for v in fc] for fc in mesh.tris]
        mesh.texture_vertices = uv
    
    return uv

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 13
def get_rot_mat2d(phi):
    """Get 2d rotation matrix with angle phi."""
    return np.array([[np.cos(phi), np.sin(phi)],[-np.sin(phi), np.cos(phi)]])

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 21
def rotational_align_disk(mesh_source, mesh_target, disk_uv_source=None, disk_uv_target=None,
                          allow_flip=True, q=0.01, n_grid=1024):
    """
    Rotationally align two UV maps to the disk by the conformal factor.
    
    Computes aligned UV coordinates. Assumes that the UV
    coordinates are in [0,1]^2. This works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the plane, and finding the optimal rotation to align
    the conformal factors via phase correlation.
    
    Parameters
    ----------
    mesh_source : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    disk_uv_source : np.array or None
        Disk coordinates for each vertex in the source mesh. Optional.
        If None, the UV coordinates of mesh_source are used.
    disk_uv_target : np.array or None
        Disk coordinates for each vertex in the target mesh. Optional.
        If None, the UV coordinates of disk_uv_target are used.
    allow_flip : bool
        Whether to allow flips (improper rotations). If a flip
        occurs, np.linalg.det(rot_mat) < 0
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment
    
    Returns
    -------
    np.array, np.array, float
        new_texture_vertices_mesh_source : np.array
            Rotationally aligned texture vertices
        rot_mat : np.array of shape (2,2)
            Rotation matrix
        overlap : float
            Overlap between aligned conformal factors. 1 = perfect alignment.
    
    """
    if disk_uv_source is None:
        disk_uv_source = np.copy(mesh_source.texture_vertices)
        disk_tris_source = mesh_source.texture_tris
    else:
        disk_tris_source = mesh_source.tris
    if disk_uv_target is None:
        disk_uv_target = np.copy(mesh_target.texture_vertices)
        disk_tris_target = mesh_target.texture_tris
    else:
        disk_tris_target = mesh_target.tris
    # compute conformal distortion factors, clip to avoid outliers
    conformal_factor_source = tcdfg.compute_per_vertex_area_distortion(disk_uv_source, disk_tris_source,
                                                                       mesh_source.vertices, mesh_source.tris,)
    conformal_factor_source = np.clip(conformal_factor_source, np.quantile(conformal_factor_source, q),
                                      np.quantile(conformal_factor_source, 1-q))
    conformal_factor_target = tcdfg.compute_per_vertex_area_distortion(disk_uv_target, disk_tris_target,
                                                                       mesh_target.vertices, mesh_target.tris)
    conformal_factor_target = np.clip(conformal_factor_target, np.quantile(conformal_factor_target, q),
                                      np.quantile(conformal_factor_target, 1-q))
    assert conformal_factor_source.mean() > 0, "Maps to disk must be orientation-preserving"
    assert conformal_factor_target.mean() > 0, "Maps to disk must be orientation-preserving"
    # interpolate into UV square
    u, v = 2*[np.linspace(0, 1, n_grid),]
    UV = np.stack(np.meshgrid(u, v), axis=-1).reshape((-1, 2))
    interpolated_source = tcinterp.interpolate_barycentric(UV, disk_uv_source, disk_tris_source,
                                                           conformal_factor_source, distance_threshold=np.inf)
    interpolated_source = interpolated_source.reshape((n_grid, n_grid))[::-1]

    interpolated_target = tcinterp.interpolate_barycentric(UV, disk_uv_target, disk_tris_target,
                                                           conformal_factor_target, distance_threshold=np.inf)
    interpolated_target = interpolated_target.reshape((n_grid, n_grid))[::-1]
    # compute rotational alignment, allowing for flips
    interpolated_source_polar = transform.warp_polar(interpolated_source, radius=n_grid/2-1)
    interpolated_target_polar = transform.warp_polar(interpolated_target, radius=n_grid/2-1)
    shifts, error, _ = registration.phase_cross_correlation(interpolated_source_polar, interpolated_target_polar,
                                                            normalization=None)
    if allow_flip:
        interpolated_source_polar_flipped = interpolated_source_polar[::-1]
        shifts_flipped, error_flipped, _ = registration.phase_cross_correlation(interpolated_source_polar_flipped,
                                                        interpolated_target_polar, normalization=None)
        if error > error_flipped:
            rot_angle = -shifts_flipped[0]*np.pi/180
            rot_mat = get_rot_mat2d(rot_angle) @ np.diag([1,-1])
            new_texture_vertices = (disk_uv_source-np.array([0.5,0.5]))@rot_mat.T
            new_texture_vertices += np.array([0.5,0.5])
            return new_texture_vertices, rot_mat, 1-error_flipped
    rot_angle = -shifts[0]*np.pi/180
    rot_mat = get_rot_mat2d(rot_angle)
    new_texture_vertices = (disk_uv_source-np.array([0.5,0.5]))@rot_mat.T
    new_texture_vertices += np.array([0.5,0.5])
    return new_texture_vertices, rot_mat, 1-error

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 26
def wrap_coords_via_disk(mesh_source, mesh_target,
                         disk_uv_source=None, disk_uv_target=None,
                         align=True, q=0.01, n_grid=1024):
    """
    Map 3d coordinates of source mesh to target mesh via a disk parametrization.
    
    Disk parametrization can be provided or computed on the fly via harmonic coordinates.
    If desired, the two disks are also rotationally aligned.
    
    Parameters
    ----------
    mesh_source : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    disk_uv_source : np.array or None
        Disk coordinates for each vertex in the source mesh. Optional.
        If None, computed via map_to_disk.
    disk_uv_target : np.array or None
        Disk coordinates for each vertex in target mesh. Optional.
        If None, computed via map_to_disk.
    align : bool, default True
        Whether to rotationally align the parametrizations. If False, they are used as-is.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment.
        Higher values increase alignment precision.
    
    Returns
    -------
    np.array, float
        new_coords : np.array
            New 3d vertex coordinates for mesh_source, lying on the surface
            defined by mesh_target
        overlap : float
            Only returned if align is True. A measure of geometry overlap. 1 = perfect alignment
    """
    # compute harmonic map to disk
    if disk_uv_source is None:
        disk_uv_source = map_to_disk(mesh_source, set_uvs=False)
    if disk_uv_target is None:
        disk_uv_target = map_to_disk(mesh_target, set_uvs=False)
    # rotational alignment of parametrizations
    if align:
        disk_uv_source_aligned, _, _ = rotational_align_disk(mesh_source, mesh_target, disk_uv_source, disk_uv_target,
                                                             q=q, n_grid=n_grid)
    else:
        disk_uv_source_aligned = disk_uv_source
    # copy over 3d coordinates 
    new_coords = tcinterp.interpolate_barycentric(np.pad(disk_uv_source_aligned, ((0,0), (0,1))),
                                                  np.pad(disk_uv_target, ((0,0), (0,1))),
                                                  mesh_target.tris, mesh_target.vertices, distance_threshold=np.inf)
    if align:
        return new_coords, overlap
    return new_coords

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 32
def polygon_area(pts):
    """ Polygon area via shoe-lace formula. Assuming no self-intersection. pts.shape is (..., 2)"""
    return np.sum(pts[...,0]*np.roll(pts[...,1], 1, axis=0) - np.roll(pts[...,0], 1, axis=0)*pts[...,1], axis=0)/2

def polygon_centroid(pts):
    """See https://en.wikipedia.org/wiki/Centroid. pts.shape is (..., 2)"""
    C_x = np.sum((pts[...,0]+np.roll(pts[...,0], 1, axis=0))
                 *(pts[...,0]*np.roll(pts[...,1], 1, axis=0)-np.roll(pts[...,0], 1, axis=0)*pts[...,1]), axis=0)/2
    C_y = np.sum((pts[...,1]+np.roll(pts[...,1], 1, axis=0))
                 *(pts[...,0]*np.roll(pts[...,1], 1, axis=0)-np.roll(pts[...,0], 1, axis=0)*pts[...,1]), axis=0)/2
    return np.array([C_x, C_y]) / (6*polygon_area(pts))

def xy_to_complex(arr):
    """Map (x,y) to x+iy. arr.shape==(...,2 )"""
    return arr[...,0]+1j*arr[...,1]

def complex_to_xy(arr):
    """Map x+iy to (x, y). Return shape==(...,2 )"""
    return np.stack([arr.real, arr.imag], axis=-1)

def moebius_disk(pts, b):
    """Compute a Moebius transformation of the disk. Moves disk origin by b. pts.shape is (..., 2)"""
    z, b = (xy_to_complex(pts), xy_to_complex(b))
    z_transformed = (z+b)/(1+np.conjugate(b)*z)
    return complex_to_xy(z_transformed)

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 42
def map_cylinder_to_disk(mesh, outer_boundary="longest", first_boundary=None,
                         second_boundary=None, set_uvs=False, return_filled=False):
    """
    Map cylinder mesh to unit disk by computing harmonic UV coordinates.
    
    One boundary loop of the mesh is mapped to the circle with a diameter 1/2.
    The second boundary is filled by adding an extra vertex at its center,
    which is mapped to the disk center.  
    
    Which of the two circular boundaries is mapped to the center resp.
    the outer circle is set by the option outer_boundary.
    
    The disk rotation angle is arbitrary.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    outer_boundary : "longest", "shortest" or int
        Boundary to map to the unit circle. If "longest"/"shortest", 
        the longer/shorter one is mapped to the unit circle. If int,
        the boundary containing the vertex defined by the int is used.
    first_boundary : np.array of ints or None
        First boundary loop of cylinder. If None, computed automatically.
    second_boundary : np.array of ints or None
        Second boundary loop of cylinder. If None, computed automatically.
    set_uvs : bool
        whether to set the disk coordinates as UV coordinates of the mesh.
    return_filled : bool
        Whether to return vertices and faces with filled hole.
    
    Returns
    -------
    np.array, np.array, np.array
        uv : np.array
            2d vertex coordinates mapping the mesh to the unit disk in [0,1]^1.
            If filled_vertices is True, the last entry is the coordinate of the added point.
        filled_vertices : np.array
            3d vertices with extra vertex to fill second boundary
        filled_faces : np.array
            Faces with added faces to fill the second boundary.
    
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    # determine the boundary
    if first_boundary is None:
        first_boundary = igl.boundary_loop(mesh.tris)
    if second_boundary is None:
        all_boundary_edges = igl.boundary_facets(mesh.tris)
        second_boundary = igl.edges_to_path(np.stack([e for e in all_boundary_edges
                                                      if not e[0] in first_boundary]))[0][:-1]    
    assert len(first_boundary) > 0 and len(second_boundary) > 0, "No boundary found! Your mesh must be a cylinder" 
    # decide which one is the outer boundary
    if outer_boundary == "shortest" or outer_boundary in second_boundary:
        first_boundary, second_boundary = (second_boundary, first_boundary)
    # add an extra vertex and triangles
    filled_tris = igl.topological_hole_fill(mesh.tris, [second_boundary])
    center_second_boundary = mesh.vertices[second_boundary].mean(axis=0)
    filled_vertices = np.vstack([mesh.vertices, [center_second_boundary]])    # map to disk via harmonic map
    bnd_uv = igl.map_vertices_to_circle(filled_vertices, first_boundary)
    uv = igl.harmonic(filled_vertices, filled_tris, first_boundary, bnd_uv, 1)
    # map the center of the second boundary to disk center
    uv = moebius_disk(uv, -uv[-1])
    # translate+scale so we fit in the UV square
    uv = uv/2+np.array([0.5, 0.5])
    # set UV coordinates if desired mesh
    if set_uvs:
        mesh.faces = [[[v,v] for v in fc] for fc in mesh.tris]
        mesh.texture_vertices = uv[:-1]
    if return_filled:
        return uv, filled_vertices, filled_tris
    return uv[:-1]

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 51
def wrap_coords_via_disk_cylinder(mesh_source, mesh_target, q=0.01, n_grid=1024):
    """
    Map 3d coordinates of source mesh to target mesh via an annulus parametrization.
    
    Annulus parametrization can be provided or computed on the fly via harmonic coordinates.
    If desired, the two disks are also rotationally aligned. Meshes must be cylindrical.
    Two choices exist for mapping a cylinder to the plane (depending on which boundary
    circle is mapped to the disk boundary resp. center). Both options are tried,
    and the one leading to better alignment is used.
    
    If you already have a map to the disk, use wrap_coords_via_disk instead.
    
    Parameters
    ----------
    mesh_source : tcmesh.ObjMesh
        Mesh. Must be topologically a cylinder and should be triangular.
    mesh_target : tcmesh.ObjMesh
        Mesh. Must be topologically a cylinder and should be triangular.
    q : float between 0 and 0.5
        Conformal factors are clipped at this quantile to avoid outliers.
    n_grid : int
        Grid for interpolation of conformal factor during alignment.
        Higher values increase alignment precision.
    
    Returns
    -------
    np.array, float
        new_coords : np.array
            New 3d vertex coordinates for mesh_source, lying on the surface
            defined by mesh_target
        overlap : float
            Measure of geometry overlap. 1 = perfect alignment
    """
    # compute harmonic map to annulus. For the source mesh, try both cylinders
    disk_uv_source_a = map_cylinder_to_disk(mesh_source, outer_boundary="longest",
                                            return_filled=False, set_uvs=False,)
    disk_uv_source_b = map_cylinder_to_disk(mesh_source, outer_boundary="shortest",
                                            return_filled=False, set_uvs=False,)
    disk_uv_target, vertices_target_filled, faces_target_filled = map_cylinder_to_disk(mesh_target, set_uvs=False,
                                                                                       outer_boundary="longest",
                                                                                       return_filled=True)
    # rotational alignment of parametrizations
    disk_uv_source_aligned_a, _, overlap_a = rotational_align_disk(mesh_source, mesh_target,
                                                                   disk_uv_source_a, disk_uv_target[:-1], 
                                                                   q=q, n_grid=n_grid)
    disk_uv_source_aligned_b, _, overlap_b = rotational_align_disk(mesh_source, mesh_target,
                                                                   disk_uv_source_b, disk_uv_target[:-1],
                                                                   q=q, n_grid=n_grid)
    if overlap_a > overlap_b:
        disk_uv_source_aligned = disk_uv_source_aligned_a
        overlap = overlap_a
    else:
        disk_uv_source_aligned = disk_uv_source_aligned_b
        overlap = overlap_b
    # copy over 3d coordinates. use filled topology
    disk_uv_target_filled = np.vstack([disk_uv_target, [np.array([0.5, 0.5])]])
    new_coords = tcinterp.interpolate_barycentric(np.pad(disk_uv_source_aligned, ((0,0), (0,1))),
                                                  np.pad(disk_uv_target_filled, ((0,0), (0,1))),
                                                  faces_target_filled, vertices_target_filled,
                                                  distance_threshold=np.inf)
    return new_coords, overlap

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 65
def stereographic_plane_to_sphere(uv):
    """
    Stereographic projection from plane to the unit sphere from the north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: plane is at z=0, unit sphere centered at origin.
    uv should be an array of shape (..., 2)
    """
    return (np.stack([2*uv[:,0], 2*uv[:,1], uv[:,0]**2+uv[:,1]**2-1], axis=0) / (1+uv[:,0]**2+uv[:,1]**2)).T
    
def stereographic_sphere_to_plane(pts):
    """
    Stereographic projection from unit sphere to plane from the north pole (0,0,1).
    
    See https://en.wikipedia.org/wiki/Stereographic_projection.
    Convention: the plane is at z=0, unit sphere centered at the origin.
    pts should be an array of shape (..., 3)
    """
    assert np.allclose(np.linalg.norm(pts, axis=1), 1, rtol=1e-03, atol=1e-04), "Points not on unit sphere!"
    return (np.stack([pts[:,0], pts[:,1]], axis=0)/(1-pts[:,2])).T

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 68
def center_moebius(vertices_3d, vertices_sphere, tris, n_iter_centering=10, alpha=0.5):
    """
    Apply Moeboius inversions to minimize area distortion of a map from mesh to sphere.
    
    Implementation of Algorithm 1 from:
    https://www.cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf
    
    Parameters
    ----------
    vertices_3d : np.array of shape (n_verts, 3)
        3d mesh vertices
    vertices_sphere : np.array of shape (n_verts, 3)
        Initial vertex positions on unit sphere
    tris : np.array of shape (n_faces, 3) and type int
        Faces of a triangular mesh
    n_iter_centering : int
        Centering algorithm iterations.
    alpha : float between 0 and 1
        Learning rate. Lower values make the algorithm more stable
    
    Returns
    -------
    np.array, float
        vertices_sphere_centered : np.array of shape (n_verts, 3)
            Centered sphere coordinates
        com_norm : float
            Distance of sphere vertex center of mass from origin. Low values
            indicate convergence of the algorithm.
    """
    As = igl.doublearea(vertices_3d, tris)
    As /= As.sum()
    Vs = np.copy(vertices_sphere)
    for i in range(n_iter_centering):
        # compute triangle centroids
        Cs = Vs[tris].mean(axis=1)
        Cs = (Cs.T/np.linalg.norm(Cs,axis=-1)).T
        # compute center of mass, weighted by 3d areas
        mu = (As*Cs.T).sum(axis=1)
        # compute Jacobian and get inversion center
        J = (As*(np.eye(3) - np.einsum('vi,vj->vij', Cs, Cs)).T).sum(axis=-1)
        c = -alpha*np.linalg.inv(J)@mu
        # compute inversion
        Vs = ((1-np.linalg.norm(c)**2)*(Vs+c).T /np.linalg.norm(Vs+c, axis=1)**2).T + c
    return Vs, np.linalg.norm(mu)

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 74
def map_to_sphere(mesh, method="harmonic", R_max=100, n_iter_centering=20, alpha=0.5, set_uvs=False):
    """
    Compute a map of mesh to the unit sphere.
    
    First, remove one vertex (the last one), and map the resulting disk-topology
    mesh to the plane using least squares conformal maps. Then map the plane to
    the sphere using stereographic projection.
    
    The conformal map is chosen so that area distortion is as small as possible by
    (a) optimizing over the scale ("radius") of the map to the disk and (b) "centering"
    the map using Algorithm 1 from cs.cmu.edu/~kmcrane/Projects/MobiusRegistration/paper.pdf.
    
    This means the map is canonical up to rotations of the sphere.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
        Mesh. Must be topologically a sphere, and should be triangular.
    method : str, "harmonic", "LSCM"
        Method for computing the map from mesh without the north pole to the plane.
        Recommended: harmonic.
    R_max :  float
        Maximum radius to consider when computing inverse stereographic
        projection. If you get weird results, try a lower value.
    n_iter_centering : int
        Centering algorithm iterations. If 0, no centering is performed
    alpha : float between 0 and 1
        Learning rate. Lower values make the centering algorithm more stable
    Returns
    -------
    vertices_sphere : np.array
        Sphere coordinates. Same shape as mesh.vertices
    """
    if not mesh.is_triangular:
        warnings.warn("Warning: ignoring non-triangular faces", RuntimeWarning)
    # remove "north pole" - by convention, the last vertex in the mesh
    north_pole = mesh.vertices.shape[0]-1
    faces_all = mesh.tris
    tri_mask = (faces_all==north_pole).any(axis=1) 
    faces_disk = faces_all[~tri_mask]
    vertices_disk = mesh.vertices[:-1]
    ## Find the open boundary
    bnd = igl.boundary_loop(faces_disk)
    assert method in ["LSCM", "harmonic"], "Invalid method"
    if method == "LSCM": ## least squares conformal map
        bnd = igl.boundary_loop(faces_disk)
        b = np.array([bnd[0], bnd[int(np.round(len(bnd)/2))]])
        bc = np.array([[0.0, -1.0], [0.0, 1.0]])
        _, uv = igl.lscm(vertices_disk, faces_disk, b, bc)
        uv = uv-uv.mean(axis=0)
    if method == "harmonic": # harmonic map
        bnd_uv = igl.map_vertices_to_circle(vertices_disk, bnd)
        uv = igl.harmonic(vertices_disk, faces_disk, bnd, bnd_uv, 1)
    # map plane to sphere. the scale factor of the map mesh -> plane is arbitrary,
    # so we chose it in a way that minimizes area distortion
    areas = igl.doublearea(mesh.vertices, faces_all)
    areas = (areas/areas.mean())
    def get_distoration(R):
        """
        Measure area distortion as a function of mesh -> plane scale factor.
        """
        coords_sphere = np.vstack([stereographic_plane_to_sphere(R*uv), np.array([0,0,1])])
        areas_sphere = igl.doublearea(coords_sphere, faces_all)
        areas_sphere = np.clip(areas_sphere, 1e-20, 4*np.pi)
        areas_sphere = (areas_sphere/areas_sphere.mean())
        distortion = np.log(areas_sphere/areas)
        return np.abs(distortion).mean()
    sol = optimize.minimize_scalar(get_distoration, bounds=(0, R_max))
    R_opt = sol.x
    vertices_sphere = np.vstack([stereographic_plane_to_sphere(R_opt*uv), np.array([0,0,1])])
    # center map to sphere using Moebius ivnersions
    if n_iter_centering > 0:
        vertices_sphere, _ = center_moebius(mesh.vertices, vertices_sphere, faces_all,
                                            n_iter_centering=n_iter_centering, alpha=alpha)
    if igl.doublearea(vertices_sphere, faces_all).min() <= 0:
        warnings.warn("Warning: some triangle on sphere have 0 or negative area", RuntimeWarning)
        
    return vertices_sphere

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 86
def rotational_align_sphere(mesh_source, mesh_target, coords_sphere_source, coords_sphere_target,
                            allow_flip=False, max_l=10, n_angle=100, n_subdiv_axes=1, maxfev=100):
    """
    Rotationally align two UV maps to the sphere by the conformal factor.
    
    Computes aligned spherical coordinates. Rotational alignment works by computing
    the conformal factor (how much triangle size changes as it is
    mapped to the sphere) and optimizing over rotations to find the one
    which leads to the best alignment. This works via an expansion in
    spherical harmonics. See tcrot.rotational_alignment
    
    Parameters
    ----------
    mesh_source : tcmesh.ObjMesh
        Mesh. Must be topologically a sphere (potentially with holes),
        and should be triangular.
    mesh_target : tcmesh.ObjMesh
        Mesh. Must be topologically a sphere (potentially with holes),
        and should be triangular.
    coords_sphere_source : np.array or None
        Sphere coordinates for each vertex in the source mesh.
        If None, the UV coordinates are interpreted as angles 2*pi*u=phi,
        2*pi*v=theta.
    coords_sphere_target : np.array or None
        Sphere coordinates for each vertex in the source mesh.
        If None, the UV coordinates are interpreted as angles 2*pi*u=phi,
        2*pi*v=theta.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1. 
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls the number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    maxfev : int
        Number of function evaluations during fine optimization.
    
    Returns
    -------
    np.array, np.array, float
        coords_sphere_source_rotated : np.array
            Rotationally aligned sphere vertices
        rot_mat : np.array of shape (3,3)
            Rotation matrix
        overlap  : float
            How well the conformal factors overlap. 1 = perfect overlap.
    
    """
    if coords_sphere_source is None:
        coords_sphere_source = spherical_to_cartesian(1, 2*np.pi*mesh_source.texture_vertices[:,1],
                                                      2*np.pi*mesh_source.texture_vertices[:,0])
        tris_sphere_source = mesh_source.texture_tris
    else:
        tris_sphere_source = mesh_source.tris

    if coords_sphere_target is None:
        coords_sphere_target = spherical_to_cartesian(1, 2*np.pi*mesh_target.texture_vertices[:,1],
                                                      2*np.pi*mesh_target.texture_vertices[:,0])
        tris_sphere_target = mesh_target.texture_tris
    else:
        tris_sphere_target = mesh_target.tris

    # compute the conformal factor
    conformal_factor_source = tcdfg.compute_per_vertex_area_distortion(coords_sphere_source, tris_sphere_source,
                                                                       mesh_source.vertices, mesh_source.tris,)
    conformal_factor_target = tcdfg.compute_per_vertex_area_distortion(coords_sphere_target, tris_sphere_target,
                                                                       mesh_target.vertices, mesh_target.tris)
    # transform to log
    signal_source = np.log(conformal_factor_source)
    signal_target = np.log(conformal_factor_target)

    # compute the spherical harmonics coefficients
    max_l = 10
    _, theta_source, phi_source = tcrot.cartesian_to_spherical(coords_sphere_source)
    _, theta_target, phi_target = tcrot.cartesian_to_spherical(coords_sphere_target)
    weights_source = igl.doublearea(coords_sphere_source, tris_sphere_source)/2
    weights_source = igl.average_onto_vertices(coords_sphere_source, tris_sphere_source,
                                               np.stack(3*[weights_source], axis=-1))[:,0]
    weights_target = igl.doublearea(coords_sphere_target, tris_sphere_target)/2
    weights_target = igl.average_onto_vertices(coords_sphere_target, tris_sphere_target,
                                               np.stack(3*[weights_target], axis=-1))[:,0]
    # subtract mean
    signal_source -= np.average(signal_source, weights=weights_source)
    signal_target -= np.average(signal_target, weights=weights_target)
    coeffs_source = tcrot.compute_spherical_harmonics_coeffs(signal_source, phi_source, theta_source,
                                                             weights_source, max_l=max_l)
    coeffs_target = tcrot.compute_spherical_harmonics_coeffs(signal_target, phi_target, theta_target,
                                                             weights_target, max_l=max_l)
        
    # compute the rotation to match them.
    R_refined, overlap = tcrot.rotational_alignment(coeffs_source, coeffs_target, max_l=max_l,
                                                    n_angle=n_angle, n_subdiv_axes=n_subdiv_axes, maxfev=maxfev,
                                                    allow_flip=allow_flip)

    return coords_sphere_source @ R_refined.T, R_refined, overlap

# %% ../nbs/Python library/06_harmonic_wrapping.ipynb 92
def wrap_coords_via_sphere(mesh_source, mesh_target, coords_sphere_source=None, coords_sphere_target=None,
                           method="harmonic", n_iter_centering=10, alpha=0.5,
                           align=True, allow_flip=False, max_l=10, n_angle=100, n_subdiv_axes=1, maxfev=100):
    """
    Map 3d coordinates of source mesh to target mesh via a sphere parametrization.
    
    Sphere parametrizations can be provided or computed on the fly using the least-area
    distorting conformal map to the sphere (see map_to_sphere). If desired, the two
    parametrizations are also aligned with respect to 3d rotations using mesh shape,
    using spherical harmonics. See rotational_align_sphere for details.
    
    Parameters
    ----------
    mesh_source : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    mesh_target : tcmesh.ObjMesh
        Mesh. Must be topologically a disk (potentially with holes),
        and should be triangular.
    coords_sphere_source : np.array or None
        Sphere coordinates for each vertex in the source mesh. Optional.
        If None, computed via map_to_sphere.
    coords_sphere_target : np.array or None
        Sphere coordinates for each vertex in the target mesh. Optional.
        If None, computed via map_to_sphere.
    method : str, "harmonic" or "LSCM"
        Method for comuting the map from sphere without north pole to plane
    n_iter_centering : int
        Centering algorithm iterations for computing map to the sphere. If 0, no centering is performed
    alpha : float between 0 and 1
        Learning rate for computing map to the sphere. Lower values make the centering algorithm more stable.
    align : bool, default True
        Whether to rotationally align the parametrizations. If False, they are used as-is.
    allow_flip : bool
        Whether to allow improper rotations with determinant -1 for rotational alignment.
    max_l : int
        Maximum angular momentum. If None, the maximum value available in the input
        spherical harmonics is used.
    n_angle : int
        Number of trial rotation angles [0,..., 2*pi]
    n_subdiv_axes : int
        Controls the number of trial rotation axes. Rotation axes are vertices of
        the icosphere which can be subdivided. There will be roughly
        40*4**n_subdiv_axes trial axes. This parameter has the strongest influence
        on the run time.
    maxfev : int
        Number of function evaluations during fine optimization for rotational alignment.

    Returns
    -------
    np.array, float
        new_coords : np.array
            New 3d vertex coordinates for mesh_source, lying on the surface
            defined by mesh_target
        overlap : np.array
            Overlap of conformal factor (area distortion) on sphere of the two meshes. Only returned if align is True.
            1 indicates perfect overlap.
    """
    # compute harmonic map to disk
    if coords_sphere_source is None:
        coords_sphere_source = map_to_sphere(mesh_source, n_iter_centering=n_iter_centering, alpha=alpha,
                                             set_uvs=False, method=method)
    if coords_sphere_target is None:
        coords_sphere_target = map_to_sphere(mesh_target, n_iter_centering=n_iter_centering, alpha=alpha,
                                             set_uvs=False, method=method)
    # rotational alignment of parametrizations
    if align:
        coords_sphere_source_aligned, R, overlap = rotational_align_sphere(mesh_source, mesh_target,
                                                coords_sphere_source, coords_sphere_target,
                                                allow_flip=allow_flip, max_l=max_l,
                                                n_angle=n_angle, n_subdiv_axes=n_subdiv_axes, maxfev=maxfev)
    else:
        coords_sphere_source_aligned = coords_sphere_source
    # copy over 3d coordinates 
    new_coords = tcinterp.interpolate_barycentric(coords_sphere_source_aligned,
                                                  coords_sphere_target,
                                                  mesh_target.tris, mesh_target.vertices, distance_threshold=np.inf)
    if align:
        return new_coords, overlap
    return new_coords

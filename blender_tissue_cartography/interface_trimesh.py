# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Python library/01d_interface_trimesh.ipynb.

# %% auto 0
__all__ = ['convert_to_trimesh', 'convert_from_trimesh']

# %% ../nbs/Python library/01d_interface_trimesh.ipynb 2
from . import mesh as tcmesh

import numpy as np
import trimesh

# %% ../nbs/Python library/01d_interface_trimesh.ipynb 4
def convert_to_trimesh(mesh: tcmesh.ObjMesh, add_texture_info=None) -> trimesh.Trimesh:
    """
    Convert tcmesh.ObjMesh to trimesh.Trimesh
    
    See https://trimesh.org/trimesh.base.html
    Note: normal information is recalculated. Discards any non-triangle faces.
    
    Texture is saved as a vertex attribute via v_tex_coords_matrix. Note that this discards
    information since a vertex can have multiple texture coordinates!
    For this reason, we also add the texture coordinates as a (n_faces, 3, s)-array attribute
    `face_tex`. Note: this will _not_ be updated if you remesh etc.
    
    Parameters
    ----------
    mesh : tcmesh.ObjMesh
    add_texture_info : None or bool
        Whether to add texture info to the trimesh.Trimesh. If None, texture is added if
        available for at least one vertex.
    Returns
    -------
    trimesh.Trimesh

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular. discarding non-triangular faces")
    add_texture_info = ((not mesh.only_vertices and len(mesh.texture_vertices) > 0)
                        if add_texture_info is None else add_texture_info)
    if not add_texture_info:
        return trimesh.Trimesh(mesh.vertices, mesh.tris)
    texture = trimesh.visual.texture.TextureVisuals(uv=mesh.vertex_textures)
    converted = trimesh.Trimesh(mesh.vertices, mesh.tris, visual=texture)
    converted.face_tex = tcmesh.index_else_nan(mesh.texture_vertices, mesh.texture_tris)
    return converted

# %% ../nbs/Python library/01d_interface_trimesh.ipynb 8
def convert_from_trimesh(mesh: trimesh.Trimesh, reconstruct_texture_from_faces=True,
                           texture_vertex_decimals=10) -> tcmesh.ObjMesh:
    """
    Convert trimesh mesh to ObjMesh.
    
    Texture vertices can be reconstructed from face attribute face_tex or from 
    vertex attribute vertex_tex_coord_matrix. Reconstruction from face texture can accommodate
    multiple texture coordinates per vertex (e.g. for UV maps with seams).
    
    Parameters
    ----------
    mesh : trimesh.Mesh
    reconstruct_texture_from_faces : bool
        Whether to reconstruct texture information from per-face data (True), or
        per-vertex data (False)
    texture_vertex_decimals : int
        Texture vertices are rounded to texture_vertex_decimals decimals.

    Returns
    -------
    tcmesh.ObjMesh
    """
    vertices = mesh.vertices
    normals = mesh.vertex_normals
    normals = (normals.T / np.linalg.norm(normals, axis=-1)).T
    if not hasattr(mesh.visual, 'uv'):
        faces = [[2*[v,] for v in f] for f in mesh.faces]
        return tcmesh.ObjMesh(vertices=vertices, faces=faces, normals=normals)
    if hasattr(mesh.visual, 'uv') and not reconstruct_texture_from_faces:
        faces = [[2*[v,] for v in f] for f in mesh.faces]
        return tcmesh.ObjMesh(vertices=vertices, faces=faces, normals=normals, texture_vertices=mesh.visual.uv)
    # reconstruct texture vertices - big pain.
    texture_vertices = np.vstack([mesh.face_tex[:,i,:] for i in [0,1,2]])
    texture_vertices = np.round(texture_vertices, decimals=texture_vertex_decimals)
    texture_vertices_unique, inverse_index = np.unique(texture_vertices, axis=0, return_inverse=True)

    n_faces = mesh.faces.shape[0]
    faces = [[[v, inverse_index[ifc+iv*n_faces]] for iv, v in enumerate(fc)]
              for ifc, fc in enumerate(mesh.faces)]

    return tcmesh.ObjMesh(vertices=vertices, faces=faces, normals=normals, texture_vertices=texture_vertices_unique)

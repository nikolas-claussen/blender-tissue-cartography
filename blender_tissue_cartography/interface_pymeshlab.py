# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01b_interface_pymeshlab.ipynb.

# %% auto 0
__all__ = ['convert_to_pymeshlab', 'convert_from_pymeshlab']

# %% ../nbs/01b_interface_pymeshlab.ipynb 1
from . import io as tcio
import numpy as np
import pymeshlab
import warnings

# %% ../nbs/01b_interface_pymeshlab.ipynb 8
def convert_to_pymeshlab(mesh: tcio.ObjMesh, add_texture_info=None) -> pymeshlab.Mesh:
    """
    Convert tcio.ObjMesh to pymeshlab.Mesh.
    
    See https://pymeshlab.readthedocs.io/en/latest/classes/mesh.html
    Note: normal information is recalculated by pymeshlab. Discards any non-triangle faces.
    
    Texture is saved as a vertex attribute via v_tex_coords_matrix. Note that this discards
    information since a vertex can have multiple texture coordinates. For this reason,
    we also save it as 3 custom face attributes 'face_tex_vertex_{0/1/2}'.
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
    add_texture_info : None or bool
        Whether to add texture info to the pymeshlab.Mesh. If None, texture is added if
        available for at least one vertex.
    Returns
    -------
    pymeshlab.Mesh

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular. discarding non-triangular faces")
    add_texture_info = ((not mesh.only_vertices and len(mesh.texture_vertices) > 0)
                        if add_texture_info is None else add_texture_info)
    if not add_texture_info:
        return pymeshlab.Mesh(vertex_matrix=mesh.vertices, face_matrix=mesh.tris)
    converted = pymeshlab.Mesh(vertex_matrix=mesh.vertices, face_matrix=mesh.tris,
                               v_tex_coords_matrix=mesh.vertex_textures)
    texture_tris = mesh.texture_tris
    for vertex in [0,1,2]:
        atttrib = np.pad(tcio.index_else_nan(mesh.texture_vertices, texture_tris[:,vertex]),
                         ((0,0), (0,1)), constant_values=0)
        converted.add_face_custom_point_attribute(atttrib, f"face_tex_vertex_{vertex}")
    return converted

# %% ../nbs/01b_interface_pymeshlab.ipynb 15
def convert_from_pymeshlab(mesh: pymeshlab.Mesh, reconstruct_texture_from_faces=True,
                           texture_vertex_decimals=10) -> tcio.ObjMesh:
    """
    Convert pymeshlab mesh to ObjMesh.
    
    Texture vertices can be reconstructed from face attribute face_tex_vertex_{0/1/2} or from
    vertex attribute vertex_tex_coord_matrix. Reconstruction from face texture can accomodate
    multiple texture coordinates per vertex (e.g. for UV maps with seams).
    
    Texture vertices are rounded to texture_vertex_decimals decimals
    """
    vertices = mesh.vertex_matrix()
    normals = mesh.vertex_normal_matrix()
    normals = (normals.T / np.linalg.norm(normals, axis=-1)).T
    if not mesh.has_vertex_tex_coord():
        faces = [[3*[v,] for v in f] for f in mesh.face_matrix()]
        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals)
    if mesh.has_vertex_tex_coord() and not reconstruct_texture_from_faces:
        faces = [[3*[v,] for v in f] for f in mesh.face_matrix()]
        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals,
                           texture_vertices=mesh.vertex_tex_coord_matrix())
    # reconstruct texture vertices - big pain.
    texture_vertices = np.vstack([mesh.face_custom_point_attribute_matrix(f"face_tex_vertex_{i}")[:,:2]
                                  for i in [0,1,2]])
    texture_vertices = np.round(texture_vertices, decimals=texture_vertex_decimals)
    texture_vertices_unique, inverse_index = np.unique(texture_vertices, axis=0, return_inverse=True)
    
    n_faces = mesh.face_matrix().shape[0]
    faces = [[[v, inverse_index[ifc+iv*n_faces], v] for iv, v in enumerate(fc)]
             for ifc, fc in enumerate(mesh.face_matrix())]

    return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals, texture_vertices=texture_vertices_unique)

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01b_interface_pymeshlab.ipynb.

# %% auto 0
__all__ = ['convert_to_pymeshlab', 'convert_from_pymeshlab']

# %% ../nbs/01b_interface_pymeshlab.ipynb 1
from . import io as tcio
import numpy as np
import pymeshlab
import warnings

# %% ../nbs/01b_interface_pymeshlab.ipynb 8
def convert_to_pymeshlab(mesh: tcio.ObjMesh, add_texture_info=None) -> pymeshlab.Mesh:
    """
    Convert tcio.ObjMesh to pymeshlab.Mesh.
    
    See https://pymeshlab.readthedocs.io/en/latest/classes/mesh.html
    Note: normal information is recalculated by pymeshlab. Discards any non-triangle faces.
    
    Texture is saved as a vertex attribute via v_tex_coords_matrix. Note that this discards
    information since a vertex can have multiple texture coordinates. For this reason,
    we also save it as wedge_tex_coord_matrix (i.e. per triangle) .
    
    Parameters
    ----------
    mesh : tcio.ObjMesh
    add_texture_info : None or bool
        Whether to add texture info to the pymeshlab.Mesh. If None, texture is added if
        available for at least one vertex.
    Returns
    -------
    pymeshlab.Mesh

    """
    if not mesh.is_triangular:
        warnings.warn(f"Warning: mesh not triangular. discarding non-triangular faces")
    add_texture_info = ((not mesh.only_vertices and len(mesh.texture_vertices) > 0)
                        if add_texture_info is None else add_texture_info)
    if not add_texture_info:
        return pymeshlab.Mesh(vertex_matrix=mesh.vertices, face_matrix=mesh.tris)
    wedge_coords = mesh.texture_vertices[mesh.texture_tris].reshape((-1,2), order="C")
    converted = pymeshlab.Mesh(vertex_matrix=mesh.vertices, face_matrix=mesh.tris,
                               v_tex_coords_matrix=mesh.vertex_textures,
                               w_tex_coords_matrix=wedge_coords)
    return converted

# %% ../nbs/01b_interface_pymeshlab.ipynb 24
def convert_from_pymeshlab(mesh: pymeshlab.Mesh, reconstruct_texture_from_faces=True,
                           texture_vertex_decimals=10) -> tcio.ObjMesh:
    """
    Convert pymeshlab mesh to ObjMesh.
    
    Texture vertices can be reconstructed from face attribute face_tex_vertex_{0/1/2} or from
    vertex attribute vertex_tex_coord_matrix. Reconstruction from face texture can accomodate
    multiple texture coordinates per vertex (e.g. for UV maps with seams).
    
    Texture vertices are rounded to texture_vertex_decimals decimals
    """
    vertices = mesh.vertex_matrix()
    normals = mesh.vertex_normal_matrix()
    normals = (normals.T / np.linalg.norm(normals, axis=-1)).T
    if not mesh.has_vertex_tex_coord():
        faces = [[2*[v,] for v in f] for f in mesh.face_matrix()]
        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals)
    if mesh.has_vertex_tex_coord() and not reconstruct_texture_from_faces:
        faces = [[2*[v,] for v in f] for f in mesh.face_matrix()]
        return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals,
                            texture_vertices=mesh.vertex_tex_coord_matrix())
    # reconstruct texture vertices - big pain.
    wegde_coords = mesh.wedge_tex_coord_matrix()
    wegde_coords = wegde_coords.reshape((-1,3,2), order="C").reshape((-1,2), order="F")
    wegde_coords = np.round(wegde_coords, decimals=texture_vertex_decimals)
    texture_vertices_unique, index, inverse_index = np.unique(wegde_coords, axis=0,
                                                              return_index=True, return_inverse=True)
    sort_index = index.argsort()
    reorder = {x : i for i, x in enumerate(sort_index)}
    texture_vertices_unique = texture_vertices_unique[sort_index]
    n_faces = mesh.face_matrix().shape[0]
    faces = [[[v, reorder[inverse_index[ifc+iv*n_faces]]] for iv, v in enumerate(fc)]
             for ifc, fc in enumerate(mesh.face_matrix())]

    return tcio.ObjMesh(vertices=vertices, faces=faces, normals=normals, texture_vertices=texture_vertices_unique)

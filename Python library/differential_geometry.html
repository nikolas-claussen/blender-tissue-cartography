<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Tools for surface differential geometry: maps between triangle meshes, map distortion, induced metric, vector calculus">

<title>Surface differential geometry – blender-tissue-cartography</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0652833b129a4aecb7d8777fd89a11f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Surface differential geometry – blender-tissue-cartography">
<meta property="og:description" content="Tools for surface differential geometry: maps between triangle meshes, map distortion, induced metric, vector calculus">
<meta property="og:image" content="https://nikolas-claussen.github.io/blender-tissue-cartography/Python library/03_differential_geometry_files/figure-html/cell-8-output-1.png">
<meta property="og:site_name" content="blender-tissue-cartography">
<meta property="og:image:height" content="415">
<meta property="og:image:width" content="547">
<meta name="twitter:title" content="Surface differential geometry – blender-tissue-cartography">
<meta name="twitter:description" content="Tools for surface differential geometry: maps between triangle meshes, map distortion, induced metric, vector calculus">
<meta name="twitter:image" content="https://nikolas-claussen.github.io/blender-tissue-cartography/Python library/03_differential_geometry_files/figure-html/cell-8-output-1.png">
<meta name="twitter:image-height" content="415">
<meta name="twitter:image-width" content="547">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">blender-tissue-cartography</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Python library/io.html">Python library</a></li><li class="breadcrumb-item"><a href="../Python library/differential_geometry.html">Surface differential geometry</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">blender-tissue-cartography</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../00_tissue_cartography_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tissue cartography with <code>blender_tisssue_cartography</code></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../01_blender_addon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Blender add-on</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Python library</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/io.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image I/O</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01b_mesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh data structure</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01c_interface_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>pymeshlab</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01d_interface_trimesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>trimesh</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01e_morphsnakes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Morphsnakes segmentation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/02_cartographic_interpolation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cartographic interpolation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/differential_geometry.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Surface differential geometry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/remeshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/remeshing_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing with MeshLab</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/04c_smoothing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh smoothing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/registration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rigid-body registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/registration_rotation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3D-rotation registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/05c_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shrink-wrapping</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/06_harmonic_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Harmonic mapping</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/01_segmentation_with_ilastik.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 3d segmentation with Ilastik</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/02_blender_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Blender tutorial</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/03_blender_addon_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. <code>blender_tissue_cartography</code> blender add-on</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/04_btc_python_library.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. <code>blender_tissue_cartography</code> Python library</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/05_UV_maps_with_seams.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Tissue cartography with “seams”</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/06_improving_UV_maps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Iteratively improving cartographic projections</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/07_advanced_segmentation_and_meshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. Advanced segmentation and meshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/08_multiple_recordings_and_reference_meshes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. Consistent cartographic projections across multiple recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/09_movies_and_dynamic_surfaces.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. Time-lapse imaging and dynamic surfaces</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/10_analysis_in_3d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 3D Image analysis with cartographic projections</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mapping-distortion" id="toc-mapping-distortion" class="nav-link active" data-scroll-target="#mapping-distortion">Mapping distortion</a></li>
  <li><a href="#compute_per_vertex_area_distortion" id="toc-compute_per_vertex_area_distortion" class="nav-link" data-scroll-target="#compute_per_vertex_area_distortion">compute_per_vertex_area_distortion</a></li>
  <li><a href="#impute_boundary_values" id="toc-impute_boundary_values" class="nav-link" data-scroll-target="#impute_boundary_values">impute_boundary_values</a></li>
  <li><a href="#get_all_boundary_vertices" id="toc-get_all_boundary_vertices" class="nav-link" data-scroll-target="#get_all_boundary_vertices">get_all_boundary_vertices</a></li>
  <li><a href="#get_area_distortion_in_uv" id="toc-get_area_distortion_in_uv" class="nav-link" data-scroll-target="#get_area_distortion_in_uv">get_area_distortion_in_UV</a></li>
  <li><a href="#compute_per_vertex_angle_distortion" id="toc-compute_per_vertex_angle_distortion" class="nav-link" data-scroll-target="#compute_per_vertex_angle_distortion">compute_per_vertex_angle_distortion</a></li>
  <li><a href="#jacobian" id="toc-jacobian" class="nav-link" data-scroll-target="#jacobian">Jacobian</a></li>
  <li><a href="#compute_per_vertex_jacobian" id="toc-compute_per_vertex_jacobian" class="nav-link" data-scroll-target="#compute_per_vertex_jacobian">compute_per_vertex_jacobian</a></li>
  <li><a href="#compute_per_face_jacobian" id="toc-compute_per_face_jacobian" class="nav-link" data-scroll-target="#compute_per_face_jacobian">compute_per_face_jacobian</a></li>
  <li><a href="#induced-metric-tensor" id="toc-induced-metric-tensor" class="nav-link" data-scroll-target="#induced-metric-tensor">Induced metric tensor</a></li>
  <li><a href="#get_induced_metric" id="toc-get_induced_metric" class="nav-link" data-scroll-target="#get_induced_metric">get_induced_metric</a></li>
  <li><a href="#get_metric_angle" id="toc-get_metric_angle" class="nav-link" data-scroll-target="#get_metric_angle">get_metric_angle</a></li>
  <li><a href="#get_metric_norm" id="toc-get_metric_norm" class="nav-link" data-scroll-target="#get_metric_norm">get_metric_norm</a></li>
  <li><a href="#vector-calculus-on-curved-surfaces" id="toc-vector-calculus-on-curved-surfaces" class="nav-link" data-scroll-target="#vector-calculus-on-curved-surfaces">Vector calculus on curved surfaces</a>
  <ul class="collapse">
  <li><a href="#tri_grad" id="toc-tri_grad" class="nav-link" data-scroll-target="#tri_grad">tri_grad</a></li>
  </ul></li>
  <li><a href="#projection-onto-surface-normal" id="toc-projection-onto-surface-normal" class="nav-link" data-scroll-target="#projection-onto-surface-normal">Projection onto surface normal</a>
  <ul class="collapse">
  <li><a href="#get_normal_projector" id="toc-get_normal_projector" class="nav-link" data-scroll-target="#get_normal_projector">get_normal_projector</a></li>
  <li><a href="#separate_tangential_normal" id="toc-separate_tangential_normal" class="nav-link" data-scroll-target="#separate_tangential_normal">separate_tangential_normal</a></li>
  </ul></li>
  <li><a href="#div-and-rot" id="toc-div-and-rot" class="nav-link" data-scroll-target="#div-and-rot">div and rot</a>
  <ul class="collapse">
  <li><a href="#get_grad_perp" id="toc-get_grad_perp" class="nav-link" data-scroll-target="#get_grad_perp">get_grad_perp</a></li>
  <li><a href="#get_rot" id="toc-get_rot" class="nav-link" data-scroll-target="#get_rot">get_rot</a></li>
  <li><a href="#get_div" id="toc-get_div" class="nav-link" data-scroll-target="#get_div">get_div</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Python library/io.html">Python library</a></li><li class="breadcrumb-item"><a href="../Python library/differential_geometry.html">Surface differential geometry</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Surface differential geometry</h1>
</div>

<div>
  <div class="description">
    Tools for surface differential geometry: maps between triangle meshes, map distortion, induced metric, vector calculus
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>When analyzing data in cartographic projections, we have to make sure we are always accounting for mapping distortion and curvature. This notebook builds the relevant tools, including for vector calculus on curved surfaces.</p>
<p>When analyzing quantities computed in the UV cartographic projection (e.g.&nbsp;cell areas, orientation, tissue flow speed obtained from optical flow), you need to account for the cartographic projection. I generally recommend doing this by <em>mapping every object back to 3d as soon as possible</em>. This will minimize the number of possible errors. Example: you want to evaluate the angle between two edges of a cell. 1. You could do so in the UV map using the induced metric (see below). This is error-prone: did you calculate the metric correctly? Did you use the metric or its inverse? 2. You could map back the location of the cell vertices to 3d, and then calculate the edge vectors in 3d. This minimizes possibilities for confusion.</p>
<section id="mapping-distortion" class="level3">
<h3 class="anchored" data-anchor-id="mapping-distortion">Mapping distortion</h3>
<p>A map between two meshes is defined on a per-triangle basis (i.e.&nbsp;which triangle of the “source” mesh gets mapped to which one of the “target” mesh). The map between a 3d mesh and its UV unwrapping is a special case of this.</p>
<p>The mapping distortion is described by the <em>Jacobian</em>, defined per triangle. For more details, see <a href="https://www.cs.cmu.edu/~kmcrane/Projects/Other/OverviewConformalGeometryProcessing.pdf">here</a>. The simplest kind of mapping distortion is <em>area distortion</em>, which is simply the ratio of (target triangle area) / (source triangle area).</p>
<p>In general, many mapping-related quantities, like area distortion, are most easily computed per triangle. We can “move” them to mesh vertices by interpolation. If we keep all of our quantities of interest defined per vertex, it will simplify bookkeeping.</p>
<p>The tools in this notebook only work for triangular meshes! Only for triangular meshes is the per-face map distortion uniquely defined.</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L22" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="compute_per_vertex_area_distortion" class="level3">
<h3 class="anchored" data-anchor-id="compute_per_vertex_area_distortion">compute_per_vertex_area_distortion</h3>
<blockquote class="blockquote">
<pre><code> compute_per_vertex_area_distortion (source_vertices, source_faces,
                                     target_vertices, target_faces,
                                     evaluate_at='source', cutoff=1e-15)</code></pre>
</blockquote>
<p>*Compute area distortion factor for a map between meshes.</p>
<p>The result is evaluated at the vertices of the source or target mesh. Faces must be such that faces[i] is mapped to target_faces[i]. This function computes (target area / source area).</p>
<p>This can be used to (a) visualize map distortion and (b) correct for it, for example by using it as a weighting factor for averages.</p>
<p>Example (compute distortion of UV map): <code>compute_per_vertex_area_distortion(mesh.texture_vertices, mesh.texture_tris,                                    mesh.vertices, mesh.tris)</code>*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source_vertices</td>
<td>np.array</td>
<td></td>
<td>Source mesh vertices.</td>
</tr>
<tr class="even">
<td>source_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Spurce mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>target_vertices</td>
<td>np.array</td>
<td></td>
<td>Target mesh vertices.</td>
</tr>
<tr class="even">
<td>target_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Target mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>evaluate_at</td>
<td>str</td>
<td>source</td>
<td>Whether to evaluate the result at the source or target<br>mesh vertices.</td>
</tr>
<tr class="even">
<td>cutoff</td>
<td>float</td>
<td>1e-15</td>
<td>Numerical cutoff for small target areas (avoid 0 division error)</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array</strong></td>
<td></td>
<td><strong>Area distortion factor (source area/target area) evaluated on source or target mesh vertices.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L80" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="impute_boundary_values" class="level3">
<h3 class="anchored" data-anchor-id="impute_boundary_values">impute_boundary_values</h3>
<blockquote class="blockquote">
<pre><code> impute_boundary_values (per_vertex_field, tris, fill_value=nan)</code></pre>
</blockquote>
<p><em>Replace values of per_vertex_field at boundary vertices by average of its non-boundary neighbors. If there are no non-boundary neighbors, use fill_value.</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L76" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_all_boundary_vertices" class="level3">
<h3 class="anchored" data-anchor-id="get_all_boundary_vertices">get_all_boundary_vertices</h3>
<blockquote class="blockquote">
<pre><code> get_all_boundary_vertices (tris)</code></pre>
</blockquote>
<p><em>Get list of all boundary vertices. Not guaranteed to be in any order</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L98" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_area_distortion_in_uv" class="level3">
<h3 class="anchored" data-anchor-id="get_area_distortion_in_uv">get_area_distortion_in_UV</h3>
<blockquote class="blockquote">
<pre><code> get_area_distortion_in_UV (mesh, uv_grid_steps=1024, map_back=True)</code></pre>
</blockquote>
<p>*Get area distortion of UV map, interpolated across the UV square.</p>
<p>Used to measure area distortion of your cartographic mapping. This can be used to (a) visualize map distortion and (b) correct for it, for example by using it as a weighting factor for averages.</p>
<p>Assumes the map <span class="math inline">\(x,y,z \mapsto u,v\)</span> to be invertible. This is not guaranteed - you can create overlapping UV coordinates in blender. The provided UV coordinates will be mapped back to [0, 1]^2 if map_back is True. Else, coordinates outside [0,1] are ignored.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mesh</td>
<td>tcmesh.ObjMesh</td>
<td></td>
<td>Input mesh with UV coordinates.</td>
</tr>
<tr class="even">
<td>uv_grid_steps</td>
<td>int</td>
<td>1024</td>
<td>Size of UV grid. Determines resolution of result.</td>
</tr>
<tr class="odd">
<td>map_back</td>
<td>bool</td>
<td>True</td>
<td>Map back the UV coordinates to [0,1]^2. Else, coordinates outside [0,1] are ignored.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (uv_grid_steps, uv_grid_steps)</strong></td>
<td></td>
<td><strong>Area distortion across [0,1]^2 UV grid, with uniform step size. UV positions that don’t<br>correspond to any value are set to np.nan.</strong></td>
</tr>
</tbody>
</table>
<div id="59182d2d" class="cell" data-scrolled="true" data-execution_count="224">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> tcmesh.ObjMesh.read_obj(<span class="st">"datasets/movie_example/initial_uv.obj"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: readOBJ() ignored non-comment line 4:
  o mesh_01_cylinder_seams_uv</code></pre>
</div>
</div>
<div id="79246213" class="cell" data-execution_count="225">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>distortion <span class="op">=</span> compute_per_vertex_area_distortion(mesh.texture_vertices, mesh.texture_tris,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                                                mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f44dab39" class="cell" data-execution_count="226">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(<span class="op">*</span>mesh.texture_vertices.T, c<span class="op">=</span>distortion, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="fl">1e7</span>, s<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"equal"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03_differential_geometry_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="4aa371fe-8209-4938-bacf-fc15310bd1b5" class="cell" data-execution_count="227">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>distortion_interpolated <span class="op">=</span> get_area_distortion_in_UV(mesh)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(distortion_interpolated, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="fl">0.75</span><span class="op">*</span><span class="fl">1e7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/nikolas/Documents/UCSB/streichan/numerics/code/python_code/jupyter_notebooks/blender-tissue-cartography/blender_tissue_cartography/interpolation.py:217: RuntimeWarning: UV map has self-intersections, 33 flipped triangles. Try use_fallback=True?
  warnings.warn("UV map has self-intersections, {} flipped triangles. Try use_fallback=True?".format(</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03_differential_geometry_files/figure-html/cell-9-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L138" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="compute_per_vertex_angle_distortion" class="level3">
<h3 class="anchored" data-anchor-id="compute_per_vertex_angle_distortion">compute_per_vertex_angle_distortion</h3>
<blockquote class="blockquote">
<pre><code> compute_per_vertex_angle_distortion (source_vertices, source_faces,
                                      target_vertices, target_faces,
                                      evaluate_at='source', cutoff=1e-15)</code></pre>
</blockquote>
<p>*Compute angle distortion for a map between meshes.</p>
<p>The result is evaluated at the vertices of the source or target mesh. Faces must be such that faces[i] is mapped to target_faces[i]. This function computes np.abs(target angles - source angles), averaged over each triangle (in radians).</p>
<p>This can be used to visualize map distortion.</p>
<p>Example (compute distortion of UV map): <code>compute_per_vertex_angle_distortion(mesh.texture_vertices, mesh.texture_tris,                                     mesh.vertices, mesh.tris)</code>*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source_vertices</td>
<td>np.array</td>
<td></td>
<td>Source mesh vertices.</td>
</tr>
<tr class="even">
<td>source_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Spurce mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>target_vertices</td>
<td>np.array</td>
<td></td>
<td>Target mesh vertices.</td>
</tr>
<tr class="even">
<td>target_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Target mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>evaluate_at</td>
<td>str</td>
<td>source</td>
<td>Whether to evaluate the result at the source or target<br>mesh vertices.</td>
</tr>
<tr class="even">
<td>cutoff</td>
<td>float</td>
<td>1e-15</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array</strong></td>
<td></td>
<td><strong>Area distortion factor (source area/target area) evaluated on source or target mesh vertices.</strong></td>
</tr>
</tbody>
</table>
<div id="7ac72415" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>compute_per_vertex_angle_distortion(mesh.texture_vertices, mesh.texture_tris,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                                    mesh.vertices, mesh.tris).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>0.19397542576446897</code></pre>
</div>
</div>
</section>
<section id="jacobian" class="level3">
<h3 class="anchored" data-anchor-id="jacobian">Jacobian</h3>
<p>In general, in addition to getting inflated or shrunk, during the mapping process, a triangle is also rotated and sheared. The full transformation properties are encoded by the Jacobian matrix.</p>
<p>You need the Jacobian for example to map vectors (e.g.&nbsp;displacement from optical flow) that you calculated in UV space back into 3d.</p>
<p>Using the <code>tcinterp.interpolate_per_vertex_field_to_UV</code>, you can interpolate the Jacobian from mesh vertices into the whole UV square.</p>
<div id="979fa71e" class="cell" data-execution_count="229">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>source_vertices, source_faces <span class="op">=</span> (mesh.texture_vertices, mesh.texture_tris)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>target_vertices, target_faces <span class="op">=</span> (mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b2c8407c" class="cell" data-execution_count="230">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> source_vertices[source_faces]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> target_vertices[target_faces]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> (A.transpose((<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>)) <span class="op">-</span> A.mean(axis<span class="op">=</span><span class="dv">1</span>)).transpose((<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> (B.transpose((<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>)) <span class="op">-</span> B.mean(axis<span class="op">=</span><span class="dv">1</span>)).transpose((<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>A.shape, B.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="230">
<pre><code>((40420, 3, 2), (40420, 3, 3))</code></pre>
</div>
</div>
<div id="4627083b" class="cell" data-execution_count="231">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>jac <span class="op">=</span> np.stack([np.linalg.lstsq(a, b, rcond<span class="op">=</span><span class="va">None</span>)[<span class="dv">0</span>].T <span class="cf">for</span> a,b <span class="kw">in</span> <span class="bu">zip</span>(A, B)]) <span class="co"># vectorize?</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(A[i] <span class="op">@</span> jac[i].T <span class="op">-</span> B[i], axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">/</span> np.linalg.norm(B[i], axis<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="231">
<pre><code>array([0., 0., 0.])</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L226" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="compute_per_vertex_jacobian" class="level3">
<h3 class="anchored" data-anchor-id="compute_per_vertex_jacobian">compute_per_vertex_jacobian</h3>
<blockquote class="blockquote">
<pre><code> compute_per_vertex_jacobian (source_vertices, source_faces,
                              target_vertices, target_faces,
                              evaluate_at='source')</code></pre>
</blockquote>
<p>*Compute Jacobian factor for a map between meshes.</p>
<p>Faces must be such that faces[i] is mapped to target_faces[i]. This function computes the Jacobian mapping tangent vectors of the source mesh to tangent vectors of the target mesh. The result is evaluated at the vertices of the source mesh.</p>
<p>Important: after you apply the per-vertex Jacobian, you may still need to permute the result, defined per source vertex, so it is defined per target mesh, e.g.&nbsp;using mesh.get_vertex_to_texture_vertex_indices() if mapping from 3d to UV.</p>
<p>Example (compute distortion of UV map): <code>compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris                             mesh.vertices, mesh.tris)</code>*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source_vertices</td>
<td>np.array</td>
<td></td>
<td>Source mesh vertices.</td>
</tr>
<tr class="even">
<td>source_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Spurce mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>target_vertices</td>
<td>np.array</td>
<td></td>
<td>Target mesh vertices.</td>
</tr>
<tr class="even">
<td>target_faces</td>
<td>np.array of shape (…, 3)</td>
<td></td>
<td>Target mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>evaluate_at</td>
<td>str</td>
<td>source</td>
<td>Whether to evaluate the result at the source or target<br>mesh vertices.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array</strong></td>
<td></td>
<td><strong>Jacobian. Shape is (n_vertices, d_target, d_source),<br>where d is the spatial dimension (e.g.&nbsp;2, 3).</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L187" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="compute_per_face_jacobian" class="level3">
<h3 class="anchored" data-anchor-id="compute_per_face_jacobian">compute_per_face_jacobian</h3>
<blockquote class="blockquote">
<pre><code> compute_per_face_jacobian (source_vertices, source_faces,
                            target_vertices, target_faces)</code></pre>
</blockquote>
<p>*Compute Jacobian factor for a map between meshes.</p>
<p>Faces must be such that faces[i] is mapped to target_faces[i]. This function computes the Jacobian mapping tangent vectors of the source mesh to tangent vectors of the target mesh. The result is evaluated at the mesh faces.</p>
<p>Example (compute distortion of UV map): <code>compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris                             mesh.vertices, mesh.tris)</code>*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source_vertices</td>
<td>np.array</td>
<td>Source mesh vertices.</td>
</tr>
<tr class="even">
<td>source_faces</td>
<td>np.array of shape (…, 3)</td>
<td>Spurce mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td>target_vertices</td>
<td>np.array</td>
<td>Target mesh vertices.</td>
</tr>
<tr class="even">
<td>target_faces</td>
<td>np.array of shape (…, 3)</td>
<td>Target mesh faces. Must be triangular.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array</strong></td>
<td><strong>Jacobian. Shape is (n_faces, d_target, d_source),<br>where d is the spatial dimension (e.g.&nbsp;2, 3).</strong></td>
</tr>
</tbody>
</table>
<div id="ca098776" class="cell" data-execution_count="233">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>jac <span class="op">=</span> compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris, mesh.vertices, mesh.tris)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>jac.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="233">
<pre><code>(20623, 3, 2)</code></pre>
</div>
</div>
<div id="ca6d7488" class="cell" data-execution_count="234">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>area_distortion <span class="op">=</span> compute_per_vertex_area_distortion(mesh.texture_vertices, mesh.texture_tris,</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                                                     mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="33299d3a" class="cell" data-execution_count="235">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># the product of the Jacobian singular values will give you the area distortion</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>np.prod(np.linalg.svd(jac).S, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">/</span> np.<span class="bu">abs</span>(area_distortion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="235">
<pre><code>array([0.99769177, 0.99467172, 0.99815593, ..., 1.        , 0.99925048,
       1.        ])</code></pre>
</div>
</div>
<div id="8e90edf8" class="cell" data-execution_count="236">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>jac <span class="op">=</span> impute_boundary_values(jac, mesh.texture_tris, fill_value<span class="op">=</span>np.nan<span class="op">*</span>np.ones((<span class="dv">3</span>,<span class="dv">2</span>)))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>jac_interpolated <span class="op">=</span> tcinterp.interpolate_per_vertex_field_to_UV(mesh, jac, uv_grid_steps<span class="op">=</span><span class="dv">256</span>,</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>                                                               map_back<span class="op">=</span><span class="va">True</span>, domain<span class="op">=</span><span class="st">'per-texture-vertex'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2d6968e9" class="cell" data-execution_count="237">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(jac_interpolated[..., <span class="dv">0</span>,<span class="dv">1</span>], vmin<span class="op">=-</span><span class="fl">1e4</span>, vmax<span class="op">=</span><span class="fl">1e4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03_differential_geometry_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="induced-metric-tensor" class="level3">
<h3 class="anchored" data-anchor-id="induced-metric-tensor">Induced metric tensor</h3>
<p>The induced metric is defined via <span class="math inline">\(g = J^T \cdot J\)</span> where <span class="math inline">\(J\)</span> is the Jacobian of the map from UV-space to 3d space.</p>
<p>Note: when doing calculations like those shown below, <code>np.einsum</code> is invaluable.</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L287" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_induced_metric" class="level3">
<h3 class="anchored" data-anchor-id="get_induced_metric">get_induced_metric</h3>
<blockquote class="blockquote">
<pre><code> get_induced_metric (mesh)</code></pre>
</blockquote>
<p>*Compute induced metric, evaluated at textures vertices.</p>
<p>See https://en.wikipedia.org/wiki/Induced_metric.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mesh</td>
<td>tcmesh.ObjMesh</td>
<td>Mesh. Must have texture map defined</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (n_texture_vertices, 2, 2)</strong></td>
<td><strong>Induced metric.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L279" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_metric_angle" class="level3">
<h3 class="anchored" data-anchor-id="get_metric_angle">get_metric_angle</h3>
<blockquote class="blockquote">
<pre><code> get_metric_angle (vf1, vf2, g)</code></pre>
</blockquote>
<p><em>Compute angle in radians between two vector fields (shape (…, d)) in degrees using metric g (shape (…, d, d)).</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L275" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_metric_norm" class="level3">
<h3 class="anchored" data-anchor-id="get_metric_norm">get_metric_norm</h3>
<blockquote class="blockquote">
<pre><code> get_metric_norm (vf, g)</code></pre>
</blockquote>
<p><em>Compute norm of vector field vf (shape (…, d)) using metric g (shape (…, d, d)).</em></p>
<div id="4bdfc568" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is how you calculate the induced metric</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>jac <span class="op">=</span> compute_per_vertex_jacobian(mesh.texture_vertices, mesh.texture_tris, mesh.vertices, mesh.tris)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> np.einsum(<span class="st">'via,vib-&gt;vab'</span>, jac, jac)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d293f4b7" class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The determinant of the metric gives the local area distortion</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>np.sqrt(np.linalg.det(g)) <span class="op">/</span> np.<span class="bu">abs</span>(area_distortion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([0.99769177, 0.99467172, 0.99815593, ..., 1.        , 0.99925048,
       1.        ])</code></pre>
</div>
</div>
<div id="84427222" class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the metric, and np.einsum, you can calculate norms and angles of vectors</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>vf <span class="op">=</span> np.random.normal(size<span class="op">=</span>jac[:,<span class="dv">0</span>].shape, scale<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>np.sqrt(np.einsum(<span class="st">'...i,...ij,...j-&gt;...'</span>, vf, g, vf))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([  501.87392309,   393.09353282,   829.11721834, ...,
       25007.79899916, 56659.93322926, 97498.61554437])</code></pre>
</div>
</div>
<div id="aef6851e" class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>mapped_to_3d <span class="op">=</span> np.einsum(<span class="st">'vij,vj-&gt;vi'</span>, jac, vf)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(mapped_to_3d, axis<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([  501.87392309,   393.09353282,   829.11721834, ...,
       25007.79899916, 56659.93322926, 97498.61554437])</code></pre>
</div>
</div>
<div id="3ecb7539" class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>jac.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(20623, 3, 2)</code></pre>
</div>
</div>
</section>
<section id="vector-calculus-on-curved-surfaces" class="level2">
<h2 class="anchored" data-anchor-id="vector-calculus-on-curved-surfaces">Vector calculus on curved surfaces</h2>
<p>How to generalize the familiar operations of vector calculus (div, rot, grad, etc) to curved surfaces is a key part of differential geometry. There are different approaches for doing surface differential geometry numerically:</p>
<ol type="1">
<li>Using local coordinates/parametrizations (i.e.&nbsp;the way physicists learn it in GR). This is prone to errors and numerically unfavorable</li>
<li>Using “intrinsic” discretization schemes like <a href="https://www.cs.cmu.edu/~kmcrane/Projects/DDG/paper.pdf">Discrete Exterior Calculus</a>. These are elegant and numerically efficient, but difficult to use and understand for non-experts.</li>
</ol>
<p>Here, we take a less elegant, but simpler approach that takes advantage of the fact that our surfaces are embedded in 3d cartesian space. All vector and tensor fields are mapped back into 3d so that their components are defined in <span class="math inline">\(x,y,z\)</span> coordinates. Then we can imagine “extending” from the surface into full 3d space by defining them to be constant along the local surface normal. Then we are back to normal vector calculus!</p>
<p>In practice, we don’t need to do this extension explicitly. We can compute the derivative of any quantity defined on mesh vertices in such a way that the derivative along the normal direction is 0. This is implemented by standard “finite-element” gradient operators. See here: https://libigl.github.io/libigl-python-bindings/tut-chapter1/#gradient</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L309" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="tri_grad" class="level3">
<h3 class="anchored" data-anchor-id="tri_grad">tri_grad</h3>
<blockquote class="blockquote">
<pre><code> tri_grad (field, vertices, faces, grad_matrix=None)</code></pre>
</blockquote>
<p>*Calculate the gradient of a function defined on vertices of a triangular mesh.</p>
<p>If a vector or tensor field is passed, the gradient is applied to each component individually.</p>
<p>See https://libigl.github.io/libigl-python-bindings/tut-chapter1/#gradient*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>field</td>
<td>np.array of shape (#vertices,…)</td>
<td></td>
<td>scalar, vector, or tensor field defined at mesh vertices</td>
</tr>
<tr class="even">
<td>vertices</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vertices.</td>
</tr>
<tr class="odd">
<td>faces</td>
<td>np.array of shape (#faces, 3)</td>
<td></td>
<td>Triangular faces.</td>
</tr>
<tr class="even">
<td>grad_matrix</td>
<td>NoneType</td>
<td>None</td>
<td>Gradient operator. The default is None (calculate from vertices, faces).</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (#vertices, dim, …)</strong></td>
<td></td>
<td><strong>Gradient of scalar function/tensor, defined on vertices.<br>Axis 1 comprises the gradients along x,y,z.</strong></td>
</tr>
</tbody>
</table>
<div id="8d68456e" class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> tcmesh.ObjMesh.read_obj(<span class="st">"datasets/movie_example/initial_uv.obj"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: readOBJ() ignored non-comment line 4:
  o mesh_01_cylinder_seams_uv</code></pre>
</div>
</div>
<div id="a344d10e" class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get some random fields - eigenfunctions of the laplacian</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>laplacian <span class="op">=</span> igl.cotmatrix(mesh.vertices, mesh.tris)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>mass <span class="op">=</span> igl.massmatrix(mesh.vertices, mesh.tris)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>eigen_vals, eigen_vecs <span class="op">=</span> sparse.linalg.eigsh(<span class="op">-</span>laplacian, M<span class="op">=</span>mass, k<span class="op">=</span><span class="dv">10</span>, which<span class="op">=</span><span class="st">"SM"</span>)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>eigen_vals, eigen_vecs <span class="op">=</span> (eigen_vals[<span class="dv">1</span>:], eigen_vecs[:, <span class="dv">1</span>:])</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>eigen_vals <span class="op">=</span> eigen_vals <span class="op">/</span> eigen_vals[<span class="dv">0</span>]</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>eigen_vecs <span class="op">=</span> eigen_vecs <span class="op">/</span> np.<span class="bu">abs</span>(eigen_vecs).mean()</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>scalar_field <span class="op">=</span> eigen_vecs[:,<span class="dv">0</span>]</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>vector_field <span class="op">=</span> eigen_vecs[:,:<span class="dv">3</span>]</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>tensor_field <span class="op">=</span> eigen_vecs.reshape((<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="298d7836" class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>tri_grad(tensor_field, mesh.vertices, mesh.tris, ).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(20212, 3, 3, 3)</code></pre>
</div>
</div>
<div id="13e14b06" class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>scalar_gradient <span class="op">=</span> tri_grad(scalar_field, mesh.vertices, mesh.tris,)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>normals <span class="op">=</span> igl.per_vertex_normals(mesh.vertices, mesh.tris)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>normals <span class="op">=</span> (normals.T<span class="op">/</span>np.linalg.norm(normals, axis<span class="op">=-</span><span class="dv">1</span>)).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ff194e99" class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>normal_component <span class="op">=</span> (np.<span class="bu">abs</span>(np.einsum(<span class="st">'vi,vi-&gt;v'</span>, normals, scalar_gradient))</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>                    <span class="op">/</span> np.linalg.norm(scalar_gradient, axis<span class="op">=-</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fe9ffe0f" class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>np.mean(normal_component)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>0.0011230080906213756</code></pre>
</div>
</div>
<div id="82d0ed0d" class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Here is how you would map the gradients to 2d. You first need to apply the Jacobian,</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co"># and then you still need to reindex.</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>jac <span class="op">=</span> compute_per_vertex_jacobian(mesh.vertices, mesh.tris, mesh.texture_vertices, mesh.texture_tris, )</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>scalar_gradient_projected <span class="op">=</span> np.einsum(<span class="st">'vij,vj-&gt;vi'</span>, jac, scalar_gradient)[mesh.get_vertex_to_texture_vertex_indices()]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d18e504c" class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(<span class="op">*</span>mesh.texture_vertices.T, c<span class="op">=</span>scalar_field[mesh.get_vertex_to_texture_vertex_indices()])</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>sk <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>plt.quiver(mesh.texture_vertices[::sk, <span class="dv">0</span>], mesh.texture_vertices[::sk, <span class="dv">1</span>],</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>           scalar_gradient_projected[::sk, <span class="dv">0</span>], scalar_gradient_projected[::sk, <span class="dv">1</span>])</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"equal"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03_differential_geometry_files/figure-html/cell-38-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="projection-onto-surface-normal" class="level2">
<h2 class="anchored" data-anchor-id="projection-onto-surface-normal">Projection onto surface normal</h2>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L352" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="get_normal_projector" class="level3">
<h3 class="anchored" data-anchor-id="get_normal_projector">get_normal_projector</h3>
<blockquote class="blockquote">
<pre><code> get_normal_projector (vertices=None, faces=None, normals=None)</code></pre>
</blockquote>
<p>*Get projection matrix that removes components normal to the surface</p>
<p>Mathematically, 1-n.n^T where n is the unit surface normal. Defined per vertex.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>vertices</td>
<td>NoneType</td>
<td>None</td>
<td>vertices. If None, must supply normals</td>
</tr>
<tr class="even">
<td>faces</td>
<td>NoneType</td>
<td>None</td>
<td>Triangular faces. If None, must supply normals</td>
</tr>
<tr class="odd">
<td>normals</td>
<td>NoneType</td>
<td>None</td>
<td>If None, recompute normals from vertices and faces</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (#vertices, dim, dim)</strong></td>
<td></td>
<td><strong>Projector</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L380" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="separate_tangential_normal" class="level3">
<h3 class="anchored" data-anchor-id="separate_tangential_normal">separate_tangential_normal</h3>
<blockquote class="blockquote">
<pre><code> separate_tangential_normal (field, vertices=None, faces=None,
                             normals=None)</code></pre>
</blockquote>
<p>*Separate tangential and normal components of field defined at vertices.</p>
<p>Vector and rank-2 tensor fields are supported. For a rank-2 tensor, normal-tangential cross components are discarded.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>field</td>
<td>np.array of shape (#vertices, dim) or (#vertices, dim, dim)</td>
<td></td>
<td>Vector or rank-2 tensor field defined at vertices</td>
</tr>
<tr class="even">
<td>vertices</td>
<td>NoneType</td>
<td>None</td>
<td>vertices. If None, must supply normals</td>
</tr>
<tr class="odd">
<td>faces</td>
<td>NoneType</td>
<td>None</td>
<td>Triangular faces. If None, must supply normals</td>
</tr>
<tr class="even">
<td>normals</td>
<td>NoneType</td>
<td>None</td>
<td>If None, recompute normals from vertices and faces</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array, np.array</strong></td>
<td></td>
<td><strong>tangential_component : np.array of shape (#vertices, dim) or (#vertices, dim, dim)<br>normal_component : np.array of shape (#vertices, dim) or (#vertices, dim, dim)</strong></td>
</tr>
</tbody>
</table>
<div id="577371f0" class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> get_normal_projector(mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="32105984" class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>tangential, normal <span class="op">=</span> separate_tangential_normal(vector_field, normals<span class="op">=</span>mesh.normals)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="33e7c4dc" class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>np.einsum(<span class="st">'vi,vi-&gt;v'</span>, tangential, mesh.normals), np.einsum(<span class="st">'vi,vi-&gt;v'</span>, normal, mesh.normals)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(array([-0.00080435, -0.000788  , -0.00274249, ...,  0.00730656,
         0.0039478 ,  0.00005069]),
 array([-0.09762832, -0.09401892, -0.10817697, ...,  2.10673152,
         2.12017993,  0.08589414]))</code></pre>
</div>
</div>
</section>
</section>
<section id="div-and-rot" class="level2">
<h2 class="anchored" data-anchor-id="div-and-rot">div and rot</h2>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L481" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="get_grad_perp" class="level3">
<h3 class="anchored" data-anchor-id="get_grad_perp">get_grad_perp</h3>
<blockquote class="blockquote">
<pre><code> get_grad_perp (field, vertices, faces, normals=None)</code></pre>
</blockquote>
<p>*Calculate the gradient of a scalar field, rotated by 90 deg around the surface normal.</p>
<p>As occurs e.g.&nbsp;when calculating vector field from stream function.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>field</td>
<td>np.array of shape (#vertices,)</td>
<td></td>
<td>Scalar field defined at mesh vertices</td>
</tr>
<tr class="even">
<td>vertices</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vertices.</td>
</tr>
<tr class="odd">
<td>faces</td>
<td>np.array of shape (#faces, 3)</td>
<td></td>
<td>Triangular faces.</td>
</tr>
<tr class="even">
<td>normals</td>
<td>NoneType</td>
<td>None</td>
<td>If None, recompute normals from vertices and faces.<br>sign of normals determines sense of rotation.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (#vertices, dim)</strong></td>
<td></td>
<td><strong>90-degree rotated gradient of scalar field. </strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L444" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_rot" class="level3">
<h3 class="anchored" data-anchor-id="get_rot">get_rot</h3>
<blockquote class="blockquote">
<pre><code> get_rot (field, vertices, faces, normals=None)</code></pre>
</blockquote>
<p>*Calculate tangent-plane rotation of vector field defined on vertices of triangular mesh.</p>
<p>This result is a scalar, equal to (Nabla x field).normals*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>field</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vector field defined at mesh vertices</td>
</tr>
<tr class="even">
<td>vertices</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vertices.</td>
</tr>
<tr class="odd">
<td>faces</td>
<td>np.array of shape (#faces, 3)</td>
<td></td>
<td>Triangular faces.</td>
</tr>
<tr class="even">
<td>normals</td>
<td>NoneType</td>
<td>None</td>
<td>If None, recompute normals from vertices and faces</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (#vertices,)</strong></td>
<td></td>
<td><strong>Curl of vector field. </strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/diffgeo.py#L418" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_div" class="level3">
<h3 class="anchored" data-anchor-id="get_div">get_div</h3>
<blockquote class="blockquote">
<pre><code> get_div (field, vertices, faces, normals=None)</code></pre>
</blockquote>
<p><em>Calculate tangent-plane divergence of vector field defined on vertices of triangular mesh.</em></p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>field</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vector field defined at mesh vertices</td>
</tr>
<tr class="even">
<td>vertices</td>
<td>np.array of shape (#vertices, dim)</td>
<td></td>
<td>vertices.</td>
</tr>
<tr class="odd">
<td>faces</td>
<td>np.array of shape (#faces, 3)</td>
<td></td>
<td>Triangular faces.</td>
</tr>
<tr class="even">
<td>normals</td>
<td>NoneType</td>
<td>None</td>
<td>If None, recompute normals from vertices and faces</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (#vertices,)</strong></td>
<td></td>
<td><strong>Divergence of vector field.</strong></td>
</tr>
</tbody>
</table>
<div id="b6018747" class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>get_div(vector_field, mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-0.00132147, -0.00133631, -0.00139445, ..., -0.01190545,
       -0.01149585, -0.00547986])</code></pre>
</div>
</div>
<div id="1f8d8711" class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>get_rot(vector_field, mesh.vertices, mesh.tris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-0.00019284, -0.00021695, -0.00021081, ..., -0.00062418,
       -0.00052652,  0.00221077])</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nikolas-claussen\.github\.io\/blender-tissue-cartography");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>
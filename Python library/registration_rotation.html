<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Find the 3D rotation that aligns data on the sphere. Part of pipeline for multiple recordings.">

<title>3D-rotation registration – blender-tissue-cartography</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0652833b129a4aecb7d8777fd89a11f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="3D-rotation registration – blender-tissue-cartography">
<meta property="og:description" content="Find the 3D rotation that aligns data on the sphere. Part of pipeline for multiple recordings.">
<meta property="og:image" content="https://nikolas-claussen.github.io/blender-tissue-cartography/Python library/05b_registration_rotation_files/figure-html/cell-6-output-1.png">
<meta property="og:site_name" content="blender-tissue-cartography">
<meta property="og:image:height" content="413">
<meta property="og:image:width" content="546">
<meta name="twitter:title" content="3D-rotation registration – blender-tissue-cartography">
<meta name="twitter:description" content="Find the 3D rotation that aligns data on the sphere. Part of pipeline for multiple recordings.">
<meta name="twitter:image" content="https://nikolas-claussen.github.io/blender-tissue-cartography/Python library/05b_registration_rotation_files/figure-html/cell-6-output-1.png">
<meta name="twitter:image-height" content="413">
<meta name="twitter:image-width" content="546">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">blender-tissue-cartography</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Python library/io.html">Python library</a></li><li class="breadcrumb-item"><a href="../Python library/registration_rotation.html">3D-rotation registration</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">blender-tissue-cartography</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../00_tissue_cartography_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tissue cartography with <code>blender_tisssue_cartography</code></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../01_blender_addon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Blender add-on</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Python library</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/io.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image I/O</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01b_mesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh data structure</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01c_interface_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>pymeshlab</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01d_interface_trimesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>trimesh</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/01e_morphsnakes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Morphsnakes segmentation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/02_cartographic_interpolation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cartographic interpolation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/differential_geometry.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Surface differential geometry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/remeshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/remeshing_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing with MeshLab</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/04c_smoothing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh smoothing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/registration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rigid-body registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/registration_rotation.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">3D-rotation registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/05c_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shrink-wrapping</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Python library/06_harmonic_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Harmonic mapping</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/01_segmentation_with_ilastik.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 3d segmentation with Ilastik</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/02_blender_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Blender tutorial</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/03_blender_addon_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. <code>blender_tissue_cartography</code> blender add-on</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/04_btc_python_library.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. <code>blender_tissue_cartography</code> Python library</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/05_UV_maps_with_seams.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Tissue cartography with “seams”</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/06_improving_UV_maps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Iteratively improving cartographic projections</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/07_advanced_segmentation_and_meshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. Advanced segmentation and meshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/08_multiple_recordings_and_reference_meshes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. Consistent cartographic projections across multiple recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/09_movies_and_dynamic_surfaces.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. Time-lapse imaging and dynamic surfaces</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Tutorials/10_analysis_in_3d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 3D Image analysis with cartographic projections</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#spherical-harmonics" id="toc-spherical-harmonics" class="nav-link active" data-scroll-target="#spherical-harmonics">Spherical harmonics</a>
  <ul class="collapse">
  <li><a href="#spherical_to_cartesian" id="toc-spherical_to_cartesian" class="nav-link" data-scroll-target="#spherical_to_cartesian">spherical_to_cartesian</a></li>
  <li><a href="#cartesian_to_spherical" id="toc-cartesian_to_spherical" class="nav-link" data-scroll-target="#cartesian_to_spherical">cartesian_to_spherical</a></li>
  <li><a href="#compute_spherical_harmonics_coeffs" id="toc-compute_spherical_harmonics_coeffs" class="nav-link" data-scroll-target="#compute_spherical_harmonics_coeffs">compute_spherical_harmonics_coeffs</a></li>
  <li><a href="#spherical_harmonics_to_grid" id="toc-spherical_harmonics_to_grid" class="nav-link" data-scroll-target="#spherical_harmonics_to_grid">spherical_harmonics_to_grid</a></li>
  </ul></li>
  <li><a href="#rotational-alignment" id="toc-rotational-alignment" class="nav-link" data-scroll-target="#rotational-alignment">Rotational alignment</a>
  <ul class="collapse">
  <li><a href="#inference-of-the-rotation-matrix-from-the-spherical-harmonics" id="toc-inference-of-the-rotation-matrix-from-the-spherical-harmonics" class="nav-link" data-scroll-target="#inference-of-the-rotation-matrix-from-the-spherical-harmonics">Inference of the rotation matrix from the spherical harmonics</a></li>
  <li><a href="#quaternion_power" id="toc-quaternion_power" class="nav-link" data-scroll-target="#quaternion_power">quaternion_power</a></li>
  <li><a href="#multiply_quaternions" id="toc-multiply_quaternions" class="nav-link" data-scroll-target="#multiply_quaternions">multiply_quaternions</a></li>
  <li><a href="#invert_quaternion" id="toc-invert_quaternion" class="nav-link" data-scroll-target="#invert_quaternion">invert_quaternion</a></li>
  <li><a href="#conjugate_quaternion" id="toc-conjugate_quaternion" class="nav-link" data-scroll-target="#conjugate_quaternion">conjugate_quaternion</a></li>
  <li><a href="#quaternion_to_complex_pair" id="toc-quaternion_to_complex_pair" class="nav-link" data-scroll-target="#quaternion_to_complex_pair">quaternion_to_complex_pair</a></li>
  <li><a href="#rot_mat_to_quaternion" id="toc-rot_mat_to_quaternion" class="nav-link" data-scroll-target="#rot_mat_to_quaternion">rot_mat_to_quaternion</a></li>
  <li><a href="#quaternion_to_rot_max" id="toc-quaternion_to_rot_max" class="nav-link" data-scroll-target="#quaternion_to_rot_max">quaternion_to_rot_max</a></li>
  <li><a href="#wigner-d-matrix-as-a-function-of-quaternions" id="toc-wigner-d-matrix-as-a-function-of-quaternions" class="nav-link" data-scroll-target="#wigner-d-matrix-as-a-function-of-quaternions">Wigner D-matrix as a function of quaternions</a></li>
  <li><a href="#get_binomial_matrix" id="toc-get_binomial_matrix" class="nav-link" data-scroll-target="#get_binomial_matrix">get_binomial_matrix</a></li>
  <li><a href="#get_wigner_d_matrix" id="toc-get_wigner_d_matrix" class="nav-link" data-scroll-target="#get_wigner_d_matrix">get_wigner_D_matrix</a></li>
  <li><a href="#overlap_spherical_harmonics" id="toc-overlap_spherical_harmonics" class="nav-link" data-scroll-target="#overlap_spherical_harmonics">overlap_spherical_harmonics</a></li>
  <li><a href="#rotate_spherical_harmonics_coeffs" id="toc-rotate_spherical_harmonics_coeffs" class="nav-link" data-scroll-target="#rotate_spherical_harmonics_coeffs">rotate_spherical_harmonics_coeffs</a></li>
  <li><a href="#parity_spherical_harmonics_coeffs" id="toc-parity_spherical_harmonics_coeffs" class="nav-link" data-scroll-target="#parity_spherical_harmonics_coeffs">parity_spherical_harmonics_coeffs</a></li>
  <li><a href="#cross-correlation-analysis" id="toc-cross-correlation-analysis" class="nav-link" data-scroll-target="#cross-correlation-analysis">Cross-correlation analysis</a></li>
  <li><a href="#sampling-the-sphere" id="toc-sampling-the-sphere" class="nav-link" data-scroll-target="#sampling-the-sphere">Sampling the sphere</a></li>
  <li><a href="#get_icosphere" id="toc-get_icosphere" class="nav-link" data-scroll-target="#get_icosphere">get_icosphere</a></li>
  <li><a href="#rotation_alignment_brute_force" id="toc-rotation_alignment_brute_force" class="nav-link" data-scroll-target="#rotation_alignment_brute_force">rotation_alignment_brute_force</a></li>
  <li><a href="#rotation_alignment_refined" id="toc-rotation_alignment_refined" class="nav-link" data-scroll-target="#rotation_alignment_refined">rotation_alignment_refined</a></li>
  <li><a href="#rotational_alignment" id="toc-rotational_alignment" class="nav-link" data-scroll-target="#rotational_alignment">rotational_alignment</a></li>
  <li><a href="#how-well-does-this-work" id="toc-how-well-does-this-work" class="nav-link" data-scroll-target="#how-well-does-this-work">How well does this work?</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Python library/io.html">Python library</a></li><li class="breadcrumb-item"><a href="../Python library/registration_rotation.html">3D-rotation registration</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">3D-rotation registration</h1>
</div>

<div>
  <div class="description">
    Find the 3D rotation that aligns data on the sphere. Part of pipeline for multiple recordings.
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>Here, we build tools to rotationally align data defined on a 2d-sphere using spherical harmonics. We consider the following problem: given two scalar functions <span class="math inline">\(f,h: S^2 \rightarrow \mathbb{R}\)</span> on the sphere, find the rotation <span class="math inline">\(g\in O(3)\)</span> that best aligns them, in the sense that it maximizes <span class="math inline">\(\int d\Omega f(x) h(g^{-1}x)\)</span>. We call <span class="math inline">\(f\)</span> the source and <span class="math inline">\(h\)</span> the target signal.</p>
<p>We expand the functions in terms of spherical harmonics, use the Wigner D-matrices to compute the effect of rotation, and find the best possible rotation via optimization.</p>
<p>In principle, the above could be done more efficiently using the fast spherical harmonics transform and the fast inverse Wigner transform. To minimize dependencies and keep the code simple, we won’t do that here, .</p>
<section id="spherical-harmonics" class="level2">
<h2 class="anchored" data-anchor-id="spherical-harmonics">Spherical harmonics</h2>
<p>We will represent spherical harmonics coefficients as <code>dict</code>s, indexed by total angular momentum <span class="math inline">\(l\)</span>, with an entry being a vector for the different <span class="math inline">\(m=-l,..., l\)</span>. Since we have real signals, we can get negative <span class="math inline">\(m\)</span> from the positive ones.</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L52" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="spherical_to_cartesian" class="level3">
<h3 class="anchored" data-anchor-id="spherical_to_cartesian">spherical_to_cartesian</h3>
<blockquote class="blockquote">
<pre><code> spherical_to_cartesian (r, theta, phi)</code></pre>
</blockquote>
<p>*Convert spherical coordinates to cartesian coordinates.</p>
<p>Uses en.wikipedia.org/wiki/Spherical_coordinate_system convention.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>theta</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>phi</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array of shape (…, 3)</strong></td>
<td><strong>array of x/y/z coordinates. Last axis indexes coordinate axes.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L29" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="cartesian_to_spherical" class="level3">
<h3 class="anchored" data-anchor-id="cartesian_to_spherical">cartesian_to_spherical</h3>
<blockquote class="blockquote">
<pre><code> cartesian_to_spherical (arr)</code></pre>
</blockquote>
<p>*Convert cartesian coordinates to spherical coordinates.</p>
<p>Uses en.wikipedia.org/wiki/Spherical_coordinate_system convention.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>arr</td>
<td>np.array of shape (…, 3)</td>
<td>array of x/y/z coordinates. last axis indexes coordinate axes.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array, np.array, np.array</strong></td>
<td><strong>r, theta, phi spherical coordinates</strong></td>
</tr>
</tbody>
</table>
<div id="b73af330" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let's get a test case - a mesh obtained by mapping a mesh conformally to the sphere</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> tcmesh.ObjMesh.read_obj(<span class="st">"datasets/movie_example/map_to_sphere.obj"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>mesh_3d <span class="op">=</span> tcmesh.ObjMesh.read_obj(<span class="st">"datasets/movie_example/final_uv.obj"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9c1db653" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># as test signal, let's use the log(areas) of the mesh triangles</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>areas_sphere <span class="op">=</span> igl.doublearea(mesh.vertices, mesh.tris)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>areas_3d <span class="op">=</span> igl.doublearea(mesh_3d.vertices, mesh_3d.tris)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>signal <span class="op">=</span> np.log(areas_sphere<span class="op">/</span>areas_3d)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>signal <span class="op">-=</span> signal.mean()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>centroids <span class="op">=</span> mesh.vertices[mesh.tris].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>r, theta, phi <span class="op">=</span> cartesian_to_spherical(centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6101c42c" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(phi, theta, c<span class="op">=</span>signal, s<span class="op">=</span><span class="dv">1</span>, vmin<span class="op">=-</span><span class="dv">3</span>, vmax<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"equal"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="bdc04a92" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>np.allclose(spherical_to_cartesian(r, theta, phi), centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div id="a5b777b0" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Interpolate onto a grid as a check</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>n_grid <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>phi_grid, theta_grid <span class="op">=</span> np.meshgrid(np.linspace(<span class="op">-</span>np.pi,np.pi, <span class="dv">2</span><span class="op">*</span>n_grid), np.linspace(<span class="dv">0</span>, np.pi, n_grid)[::<span class="op">-</span><span class="dv">1</span>], )</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>interpolated <span class="op">=</span> interpolate.griddata(np.stack([phi, theta], axis<span class="op">=-</span><span class="dv">1</span>), signal,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                                    (phi_grid, theta_grid), method<span class="op">=</span><span class="st">'linear'</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>dTheta <span class="op">=</span> np.pi<span class="op">/</span>(n_grid<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>dPhi <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>n_grid<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>interpolated <span class="op">=</span> np.nan_to_num(interpolated)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6a3da0ac" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(interpolated, vmin<span class="op">=-</span><span class="fl">2.75</span>, vmax<span class="op">=</span><span class="fl">2.75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/cell-9-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="4846270a" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check normalization and orthogonality of spherical harmonics for grid</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(special.sph_harm(<span class="dv">1</span>, <span class="dv">2</span>, phi_grid, theta_grid))<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.sin(theta_grid) <span class="op">*</span> dTheta <span class="op">*</span> dPhi))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.<span class="bu">abs</span>(np.<span class="bu">sum</span>(special.sph_harm(<span class="dv">2</span>, <span class="dv">3</span>, phi_grid, theta_grid)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span>np.conjugate(special.sph_harm(<span class="dv">2</span>, <span class="dv">4</span>, phi_grid, theta_grid))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span>np.sin(theta_grid)<span class="op">*</span>dTheta<span class="op">*</span>dPhi)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1.0019569486052557
1.0290434898119816e-16</code></pre>
</div>
</div>
<div id="f89eba33" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the relation between negative and positive m. Keep in mind (-1)^m factor</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>l, m <span class="op">=</span> (<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>np.allclose((<span class="op">-</span><span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span>m) <span class="op">*</span> np.conjugate(special.sph_harm(m, l, phi_grid,theta_grid)),</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            special.sph_harm(<span class="op">-</span>m, l, phi_grid,theta_grid))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div id="08b42a47" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now let's do the direct calculation without extra interpolation. Check orthonormality</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> igl.doublearea(mesh.vertices, mesh.tris)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(special.sph_harm(<span class="dv">1</span>, <span class="dv">2</span>, phi, theta))<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> weights))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.<span class="bu">abs</span>(np.<span class="bu">sum</span>(special.sph_harm(<span class="dv">2</span>, <span class="dv">3</span>, phi, theta)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span>np.conjugate(special.sph_harm(<span class="dv">2</span>, <span class="dv">4</span>, phi, theta))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span>weights)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.999525046106509
0.00010996886047295266</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L71" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="compute_spherical_harmonics_coeffs" class="level3">
<h3 class="anchored" data-anchor-id="compute_spherical_harmonics_coeffs">compute_spherical_harmonics_coeffs</h3>
<blockquote class="blockquote">
<pre><code> compute_spherical_harmonics_coeffs (f, phi, theta, weights, max_l)</code></pre>
</blockquote>
<p>*Compute spherical harmonic coefficients for a scalar real-valued function defined on the unit sphere.</p>
<p>Takes as input values of the function at sample points (and sample weights), and computes the overlap with each spherical harmonic by “naive” numerical integration.</p>
<p>Since the function is assumed real, we have f^{l}<em>{-m} = np.conjugate(f^{l}</em>{m}).*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f</td>
<td>np.array</td>
<td>Sample values</td>
</tr>
<tr class="even">
<td>phi</td>
<td>np.array of shape</td>
<td>Sample point azimuthal coordinates</td>
</tr>
<tr class="odd">
<td>theta</td>
<td>np.array of shape</td>
<td>Sample point longditudinal coordinates</td>
</tr>
<tr class="even">
<td>weights</td>
<td>np.array</td>
<td>Sample weights. For instance, if you have a function sampled on a regular phi-theta grid,<br>this should be dTheta<em>dPhi</em>np.sin(theta)</td>
</tr>
<tr class="odd">
<td>max_l</td>
<td>int</td>
<td>Maximum angular momentum</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>dict of np.array</strong></td>
<td>**Dictionary, indexed by total angular momentum l=0 ,…, max_l-1. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l**</td>
</tr>
</tbody>
</table>
<div id="87ed80fe" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>weights_grid <span class="op">=</span> np.sin(theta_grid)<span class="op">*</span>dTheta<span class="op">*</span>dPhi</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>spherical_harmonics_coeffs <span class="op">=</span> compute_spherical_harmonics_coeffs(interpolated, phi_grid, theta_grid,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                                                                weights_grid, max_l<span class="op">=</span><span class="dv">15</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 1.81 s, sys: 3.1 ms, total: 1.82 s
Wall time: 1.81 s</code></pre>
</div>
</div>
<div id="32ad6755" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>spherical_harmonics_coeffs[<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-0.24842273+0.41967878j,  0.32333336-0.37140101j,
        0.24521225-0.18171839j, -0.38792664-0.j        ,
       -0.24521225-0.18171839j,  0.32333336+0.37140101j,
        0.24842273+0.41967878j])</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L112" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="spherical_harmonics_to_grid" class="level3">
<h3 class="anchored" data-anchor-id="spherical_harmonics_to_grid">spherical_harmonics_to_grid</h3>
<blockquote class="blockquote">
<pre><code> spherical_harmonics_to_grid (coeffs, n_grid=256)</code></pre>
</blockquote>
<p>*Compute signal on rectangular phi-theta grid given spherical harmonics coefficients.</p>
<p>Assumes underlying function is real-valued*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>coeffs</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l</td>
</tr>
<tr class="even">
<td>n_grid</td>
<td>int</td>
<td>256</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>2d np.array</strong></td>
<td></td>
<td><strong>Reconstructed signal interpolated on rectangular phi-theta grid</strong></td>
</tr>
</tbody>
</table>
<div id="182bf1a6" class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>reconstructed <span class="op">=</span> spherical_harmonics_to_grid(spherical_harmonics_coeffs, n_grid<span class="op">=</span><span class="dv">256</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="04ce7c81" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">abs</span>(reconstructed.imag).mean(), np.<span class="bu">abs</span>(reconstructed.real).mean() <span class="co"># as</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2.2578012798576635e-17, 1.7509102818359779)</code></pre>
</div>
</div>
<div id="9ee04476" class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(reconstructed.real, vmin<span class="op">=-</span><span class="fl">2.75</span>, vmax<span class="op">=</span><span class="fl">2.75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="92d7663e" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">## now without the extra interpolation step</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>max_l <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> igl.doublearea(mesh.vertices, mesh.tris)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>spherical_harmonics_coeffs_direct <span class="op">=</span> compute_spherical_harmonics_coeffs(signal, phi, theta, weights,</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                                                                       max_l<span class="op">=</span>max_l)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="50ca215e" class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>reconstructed_direct <span class="op">=</span> spherical_harmonics_to_grid(spherical_harmonics_coeffs_direct, n_grid<span class="op">=</span><span class="dv">256</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6a101770" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(reconstructed_direct.real, vmin<span class="op">=-</span><span class="fl">2.75</span>, vmax<span class="op">=</span><span class="fl">2.75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/cell-22-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="rotational-alignment" class="level2">
<h2 class="anchored" data-anchor-id="rotational-alignment">Rotational alignment</h2>
<p>As a test, let’s randomly rotate our signal.</p>
<div id="33f90201" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>rot_mat <span class="op">=</span> stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>rot_mat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[ 0.01887775,  0.81035922, -0.5856292 ],
       [ 0.89941855,  0.24206006,  0.36394121],
       [ 0.43668055, -0.53359616, -0.72428256]])</code></pre>
</div>
</div>
<div id="b54e0ac8" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>mesh_rotated <span class="op">=</span> deepcopy(mesh)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>mesh_rotated.vertices <span class="op">=</span> mesh_rotated.vertices <span class="op">@</span> rot_mat.T</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>areas_sphere_rotated  <span class="op">=</span> igl.doublearea(mesh_rotated.vertices , mesh.tris)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>signal_rotated <span class="op">=</span> np.log(areas_sphere_rotated<span class="op">/</span>areas_3d)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>signal_rotated <span class="op">-=</span> signal_rotated.mean()</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>centroids_rotated <span class="op">=</span> mesh_rotated.vertices[mesh_rotated.tris].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>_, theta_rotated, phi_rotated <span class="op">=</span> cartesian_to_spherical(centroids_rotated)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="31276274" class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(phi_rotated, theta_rotated, c<span class="op">=</span>signal_rotated , s<span class="op">=</span><span class="dv">1</span>, vmin<span class="op">=-</span><span class="dv">3</span>, vmax<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"equal"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/cell-25-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="46bce13a" class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>weights_rotated <span class="op">=</span> igl.doublearea(mesh_rotated.vertices, mesh.tris)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>spherical_harmonics_coeffs_rotated <span class="op">=</span> compute_spherical_harmonics_coeffs(signal_rotated,</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                                                                        phi_rotated, theta_rotated,</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>                                                                        weights_rotated, max_l<span class="op">=</span>max_l)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b6c137b5" class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let's check that the power per band is conserved</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>power_direct <span class="op">=</span> {key: np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(val)<span class="op">**</span><span class="dv">2</span>) <span class="cf">for</span> key, val <span class="kw">in</span> spherical_harmonics_coeffs_direct.items()}</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>power_rotated <span class="op">=</span> {key: np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(val)<span class="op">**</span><span class="dv">2</span>) <span class="cf">for</span> key, val <span class="kw">in</span> spherical_harmonics_coeffs_rotated.items()}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e384611b" class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>power_direct</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>{0: 31.75093316228961,
 1: 1.0569845383858716,
 2: 7.656637801049782,
 3: 1.2934800832192117,
 4: 1.1934413112502484,
 5: 0.16200066481681066,
 6: 0.050219817507973934,
 7: 0.03481762596812547,
 8: 0.01422448292437451,
 9: 0.04835575407817688,
 10: 0.01666320569699937,
 11: 0.04036958829270747,
 12: 0.0241966285740686,
 13: 0.024417478492580472,
 14: 0.015292984314499655}</code></pre>
</div>
</div>
<div id="cdb8186b" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>power_rotated</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>{0: 31.75093316228961,
 1: 1.0569845383858694,
 2: 7.656637801049786,
 3: 1.29348008321921,
 4: 1.1934413112502456,
 5: 0.16200066481681097,
 6: 0.05021981750797396,
 7: 0.034817625968125335,
 8: 0.014224482924374391,
 9: 0.048355754078175966,
 10: 0.016663205696999295,
 11: 0.04036958829270838,
 12: 0.02419662857406937,
 13: 0.024417478492580014,
 14: 0.015292984314499138}</code></pre>
</div>
</div>
<section id="inference-of-the-rotation-matrix-from-the-spherical-harmonics" class="level3">
<h3 class="anchored" data-anchor-id="inference-of-the-rotation-matrix-from-the-spherical-harmonics">Inference of the rotation matrix from the spherical harmonics</h3>
<p>Now for the difficult part. We need to infer the rotation matrix. The spherical harmonics will transform as blocks for each <span class="math inline">\(l\)</span>. Wigner D-matrices describe how. The code below is based on https://github.com/moble/spherical.</p>
<div id="567d0cf0" class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the spherical module for comparison, even though we will re-implement it to minimize dependencies</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> quaternionic</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> spherical</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6b6478f5" class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Indeed, using the correct Wigner matrix can undo our rotation</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>wigner <span class="op">=</span> spherical.Wigner(<span class="dv">15</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> wigner.D(quaternionic.array.from_rotation_matrix(rot_mat))</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>mp <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>([D[wigner.Dindex(l, mp, m)]<span class="op">*</span>spherical_harmonics_coeffs_direct[l][l<span class="op">+</span>m]</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>l, l<span class="op">+</span><span class="dv">1</span>)]), spherical_harmonics_coeffs_rotated[l][l<span class="op">+</span>mp]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>((0.0014361876877559377+0.11925102266293089j),
 (0.0014361876877558369+0.11925102266292989j))</code></pre>
</div>
</div>
<section id="quaternions-and-rotation" class="level4">
<h4 class="anchored" data-anchor-id="quaternions-and-rotation">Quaternions and rotation</h4>
<p>Rotations can be respresensted by unit quaternion <span class="math inline">\(\mathbf{q}=(q_1, q_i, q_j, q_k)\)</span>. The spatial part <span class="math inline">\((q_i,q_j,q_k)\)</span> defines the orientation of the rotation axis, and <span class="math inline">\(\alpha=2\arccos(u_1)\)</span> is the rotation angle. For a unit vector <span class="math inline">\(\mathbf{u}\)</span> defining the orientation of rotation and rotation angle <span class="math inline">\(\alpha\)</span>: <span class="math display">\[q = \sin(\alpha/2) \mathbf{u} + \cos(\alpha/2)\]</span> See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L196" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="quaternion_power" class="level3">
<h3 class="anchored" data-anchor-id="quaternion_power">quaternion_power</h3>
<blockquote class="blockquote">
<pre><code> quaternion_power (q, n)</code></pre>
</blockquote>
<p><em>Raise quaternion to an integer power, potentially negative</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L190" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="multiply_quaternions" class="level3">
<h3 class="anchored" data-anchor-id="multiply_quaternions">multiply_quaternions</h3>
<blockquote class="blockquote">
<pre><code> multiply_quaternions (q, p)</code></pre>
</blockquote>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L186" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="invert_quaternion" class="level3">
<h3 class="anchored" data-anchor-id="invert_quaternion">invert_quaternion</h3>
<blockquote class="blockquote">
<pre><code> invert_quaternion (q)</code></pre>
</blockquote>
<p><em>Invert a quaternion</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L182" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="conjugate_quaternion" class="level3">
<h3 class="anchored" data-anchor-id="conjugate_quaternion">conjugate_quaternion</h3>
<blockquote class="blockquote">
<pre><code> conjugate_quaternion (q)</code></pre>
</blockquote>
<p><em>Conjugate a quaternion</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L178" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="quaternion_to_complex_pair" class="level3">
<h3 class="anchored" data-anchor-id="quaternion_to_complex_pair">quaternion_to_complex_pair</h3>
<blockquote class="blockquote">
<pre><code> quaternion_to_complex_pair (q)</code></pre>
</blockquote>
<p><em>Convert quaternion to pair of complex numbers q0+iq3, q2+iq1</em></p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L154" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rot_mat_to_quaternion" class="level3">
<h3 class="anchored" data-anchor-id="rot_mat_to_quaternion">rot_mat_to_quaternion</h3>
<blockquote class="blockquote">
<pre><code> rot_mat_to_quaternion (Q)</code></pre>
</blockquote>
<p>*Convert 3d rotation matrix into unit quaternion.</p>
<p>If determinant(Q) = -1, returns the unit quaternion corresponding to -Q</p>
<p>See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace*</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L142" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="quaternion_to_rot_max" class="level3">
<h3 class="anchored" data-anchor-id="quaternion_to_rot_max">quaternion_to_rot_max</h3>
<blockquote class="blockquote">
<pre><code> quaternion_to_rot_max (q)</code></pre>
</blockquote>
<p>*Convert unit quaternion into a 3d rotation matrix.</p>
<p>See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace*</p>
<div id="72ed0b68" class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[-0.1132397  -0.71935166 -0.6853539 ]
 [-0.98651227  0.16346272 -0.00857196]
 [ 0.11819607  0.67513934 -0.7281597 ]]</code></pre>
</div>
</div>
<div id="43e20894" class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>np.array(quaternionic.array.from_rotation_matrix(Q))<span class="op">/</span>rot_mat_to_quaternion(Q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-1., -1., -1., -1.])</code></pre>
</div>
</div>
<div id="ae6757bf" class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> rot_mat_to_quaternion(Q)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>Q_back <span class="op">=</span> quaternion_to_rot_max(q)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>np.allclose(Q_back, Q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div id="034fd573" class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>Q1 <span class="op">=</span> stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>Q2 <span class="op">=</span> stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>R1 <span class="op">=</span> quaternionic.array.from_rotation_matrix(Q1)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>R2 <span class="op">=</span> quaternionic.array.from_rotation_matrix(Q2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7d57b858" class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>R1 <span class="op">*</span> R2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>quaternionic.array([-0.55563224, -0.13607597,  0.55312392, -0.60564847])</code></pre>
</div>
</div>
<div id="4fc2b919" class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>multiply_quaternions(rot_mat_to_quaternion(Q1), rot_mat_to_quaternion(Q2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-0.55563224, -0.13607597,  0.55312392, -0.60564847])</code></pre>
</div>
</div>
<div id="6ec7d562" class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>R1<span class="op">**</span><span class="dv">4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>quaternionic.array([ 0.97660873, -0.05627274, -0.19008602,  0.08328306])</code></pre>
</div>
</div>
<div id="380a799f" class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> rot_mat_to_quaternion(Q1)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>quaternion_power(q, <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([ 0.97660873, -0.05627274, -0.19008602,  0.08328306])</code></pre>
</div>
</div>
</section>
<section id="wigner-d-matrix-as-a-function-of-quaternions" class="level3">
<h3 class="anchored" data-anchor-id="wigner-d-matrix-as-a-function-of-quaternions">Wigner D-matrix as a function of quaternions</h3>
<p>We use this formula: https://spherical.readthedocs.io/en/main/WignerDMatrices/:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="05b_registration_rotation_files/figure-html/fc05f26b-1-image.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p>To execute it rapidly, it is best to pre-compute the combinatorial coefficients via a recursion.</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L214" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_binomial_matrix" class="level3">
<h3 class="anchored" data-anchor-id="get_binomial_matrix">get_binomial_matrix</h3>
<blockquote class="blockquote">
<pre><code> get_binomial_matrix (N_max)</code></pre>
</blockquote>
<p>*Get N_max by N_max matrix with entries binomial_matrix[i, j] = (i choose j).</p>
<p>Computed via Pascal’s triangle.*</p>
<div id="42f942f1" class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>get_binomial_matrix(<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>46.9 μs ± 604 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</code></pre>
</div>
</div>
<div id="6d95db74" class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>get_binomial_matrix(<span class="dv">20</span>)[<span class="dv">12</span>, <span class="dv">3</span>], special.comb(<span class="dv">12</span>, <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(220.0, 220.0)</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L263" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_wigner_d_matrix" class="level3">
<h3 class="anchored" data-anchor-id="get_wigner_d_matrix">get_wigner_D_matrix</h3>
<blockquote class="blockquote">
<pre><code> get_wigner_D_matrix (q, l, binomial_matrix=None)</code></pre>
</blockquote>
<p><em>Get (2</em>l+1, 2<em>l+1) Wigner D matrix for angular momentum l and rotation (unit quatertion) q</em></p>
<div id="bc142300" class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>mat <span class="op">=</span> get_wigner_D_matrix(q, l<span class="op">=</span><span class="dv">10</span>) </span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 30 ms. all. down to 2 by binomial recursion</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3.73 ms ± 32.9 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<div id="c48bb44c" class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>get_wigner_D_matrix(q, l<span class="op">=</span><span class="dv">10</span>)[<span class="dv">12</span>, <span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(0.3103085067597108-0.1994583649968599j)</code></pre>
</div>
</div>
<div id="138f6a0e" class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> rot_mat_to_quaternion(Q)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co"># q = np.array([ 0.99950656,  0.        ,  0.        , -0.03141076]) # special case: important to check</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6bb32001" class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># compare with the spherical package. looks pretty good, small diff if q[0]==0</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>wigner <span class="op">=</span> spherical.Wigner(<span class="dv">15</span>)</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="co">#D = wigner.D(quaternionic.array.from_rotation_matrix(Q))</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> wigner.D(q)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>binomial_matrix <span class="op">=</span> get_binomial_matrix(<span class="dv">2</span><span class="op">*</span>l)</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>mp, m <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>(D[wigner.Dindex(l, mp, m)],</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a> _get_wigner_D_element(<span class="op">*</span>quaternion_to_complex_pair(q), l, mp, m, binomial_matrix),)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>((-0.2254678510932408+0j), (-0.22546785109324072+0j))</code></pre>
</div>
</div>
<div id="8cd1664a" class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>mat <span class="op">=</span> get_wigner_D_matrix(q, l<span class="op">=</span><span class="dv">10</span>) </span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="co"># a little slow</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 3.44 ms, sys: 85 μs, total: 3.53 ms
Wall time: 3.52 ms</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L327" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="overlap_spherical_harmonics" class="level3">
<h3 class="anchored" data-anchor-id="overlap_spherical_harmonics">overlap_spherical_harmonics</h3>
<blockquote class="blockquote">
<pre><code> overlap_spherical_harmonics (coeffsA, coeffsB, normalized=False)</code></pre>
</blockquote>
<p>*Compute overlap (L2 inner product) between two sets of spherical harmonics.</p>
<p>Optionally, normalize by the norm of coeffsA, coeffsB.*</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L299" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rotate_spherical_harmonics_coeffs" class="level3">
<h3 class="anchored" data-anchor-id="rotate_spherical_harmonics_coeffs">rotate_spherical_harmonics_coeffs</h3>
<blockquote class="blockquote">
<pre><code> rotate_spherical_harmonics_coeffs (R, coeffs)</code></pre>
</blockquote>
<p>*Rotate spherical harmonics by the given (improper or proper) rotation matrix.</p>
<p>Uses Wigner-D matrices. Don’t use this function in an optimization context - you can in general save a bunch of time by reusing D-matrices etc.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R</td>
<td>np.array of shape (3, 3)</td>
<td>Rotation matrix, may be improper. If you have a quaternion,<br> use quaternion_to_rot_mat.</td>
</tr>
<tr class="even">
<td>coeffs</td>
<td>dict of np.array</td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l-1. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>dict of np.array</strong></td>
<td><strong>Rotated spherical harmonics coefficients.</strong></td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L278" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="parity_spherical_harmonics_coeffs" class="level3">
<h3 class="anchored" data-anchor-id="parity_spherical_harmonics_coeffs">parity_spherical_harmonics_coeffs</h3>
<blockquote class="blockquote">
<pre><code> parity_spherical_harmonics_coeffs (coeffs)</code></pre>
</blockquote>
<p>*Apply parity operator to spherical harmonics coefficients.</p>
<p>Parity means (x,y,z) -&gt; (-x,-y,-z) and f^l_m -&gt; (-1)^m * f^l_m.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>coeffs</td>
<td>dict of np.array</td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l-1. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>dict of np.array</strong></td>
<td><strong>Parity-transformed spherical harmonics coefficients.</strong></td>
</tr>
</tbody>
</table>
<div id="09ddadf9" class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check that the Wigner D correctly re-aligns our harmonic coefficients</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>D_matrix <span class="op">=</span> get_wigner_D_matrix(rot_mat_to_quaternion(rot_mat), l<span class="op">=</span>l)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>np.allclose(D_matrix<span class="op">@</span>spherical_harmonics_coeffs_direct[l], spherical_harmonics_coeffs_rotated[l])</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="co"># success!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div id="c6d0bfa3" class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># before alignment, the coefficients are different</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="kw">not</span> np.allclose(spherical_harmonics_coeffs_direct[l], spherical_harmonics_coeffs_rotated[l])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
</section>
<section id="cross-correlation-analysis" class="level3">
<h3 class="anchored" data-anchor-id="cross-correlation-analysis">Cross-correlation analysis</h3>
<p>We now want to find the rotation that maximizes the cross-correlation between the two signals. To do so, we compute the overlap for several trial rotations to get an initial guess and refine it by optimization.</p>
<div id="639624b4" class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is how you compute the overlap, here using my code</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>max_l <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>binomial_matrix <span class="op">=</span> get_binomial_matrix(<span class="dv">2</span><span class="op">*</span>max_l)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.copy(rot_mat)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>corr_coeff <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, max_l):</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    D_matrix <span class="op">=</span> get_wigner_D_matrix(rot_mat_to_quaternion(R), l<span class="op">=</span>l, binomial_matrix<span class="op">=</span>binomial_matrix)</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    corr_coeff <span class="op">+=</span> np.<span class="bu">sum</span>(D_matrix<span class="op">@</span>spherical_harmonics_coeffs_direct[l]</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>                         <span class="op">*</span>np.conjugate(spherical_harmonics_coeffs_rotated[l]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 10.6 ms, sys: 18 μs, total: 10.6 ms
Wall time: 10.4 ms</code></pre>
</div>
</div>
<div id="14d10498" class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>corr_coeff</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(43.26109524149018+2.5746956649943757e-16j)</code></pre>
</div>
</div>
<p>Now let’s consider multiple rotations. we can save time by minimizing the number of times we compute the D-matrix by using the fact that <span class="math inline">\(D(R^n) = D(R)^n\)</span> - hence, for every rotation axis, we can try out a large number of rotation angles efficiently.</p>
<div id="6a273df1" class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>D_mat <span class="op">=</span> get_wigner_D_matrix(rot_mat_to_quaternion(R), l<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>D_mat_of_square <span class="op">=</span> get_wigner_D_matrix(rot_mat_to_quaternion(R<span class="op">@</span>R), l<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>np.allclose(D_mat<span class="op">@</span>D_mat, D_mat_of_square)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
</section>
<section id="sampling-the-sphere" class="level3">
<h3 class="anchored" data-anchor-id="sampling-the-sphere">Sampling the sphere</h3>
<p>How do we get a good sampling of unit vectors on the sphere as rotation axes for our initial guess? Let’s use an “icosphere” https://en.wikipedia.org/wiki/Geodesic_polyhedron</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L343" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_icosphere" class="level3">
<h3 class="anchored" data-anchor-id="get_icosphere">get_icosphere</h3>
<blockquote class="blockquote">
<pre><code> get_icosphere (subdivide=0)</code></pre>
</blockquote>
<p>*Return the icosphere triangle mesh with 42 regularly spaced vertices on the unit sphere.</p>
<p>Optionally, subdivide mesh n times, increasing vertex count by factor 4^n.*</p>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L396" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rotation_alignment_brute_force" class="level3">
<h3 class="anchored" data-anchor-id="rotation_alignment_brute_force">rotation_alignment_brute_force</h3>
<blockquote class="blockquote">
<pre><code> rotation_alignment_brute_force (sph_harmonics_source,
                                 sph_harmonics_target, max_l=None,
                                 n_angle=100, n_subdiv_axes=1,
                                 allow_flip=False)</code></pre>
</blockquote>
<p>*Compute rotational alignment between two signals on the sphere by brute force.</p>
<p>The two signals have to be represented by their spherical harmonics coefficients. Uses Wigner-D matrices to calculate the overlap between the two signals for a set of rotations and finds the rotation that maximizes the overlap.</p>
<p>The trial rotations are generated by taking a set of approx. equidistant points on the 2d sphere as rotation axes, and a set of equally spaced angles [0,…, 2*pi] as rotation angles.</p>
<p>The rotation is such that it transforms the source signal to match the target.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sph_harmonics_source</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Source signal, to be<br>transformed.</td>
</tr>
<tr class="even">
<td>sph_harmonics_target</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Target signal.</td>
</tr>
<tr class="odd">
<td>max_l</td>
<td>NoneType</td>
<td>None</td>
<td>Maximum angular momentum. If None, the maximum value available in the input<br>spherical harmonics is used.</td>
</tr>
<tr class="even">
<td>n_angle</td>
<td>int</td>
<td>100</td>
<td>Number of trial rotation angles [0,…, 2*pi]</td>
</tr>
<tr class="odd">
<td>n_subdiv_axes</td>
<td>int</td>
<td>1</td>
<td>Controls the number of trial rotation axes. Rotation axes are vertices of<br>the icosphere which can be subdivided. There will be roughly<br>40*4**n_subdiv_axes trial axes. This parameter has the strongest influence<br>on the run time.</td>
</tr>
<tr class="even">
<td>allow_flip</td>
<td>bool</td>
<td>False</td>
<td>Whether to allow improper rotations with determinant -1. In this case, <br>we return <em>two</em> sets of overlaps and rotation matrices, one for the best<br>proper, and one for the best improper rotation.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.array, float or (np.array, float), (np.array, float)</strong></td>
<td></td>
<td><strong>optimal_trial_rotation : (3,3) np.array<br> Best trial rotation as rotation matrix.<br>overlap : float<br> Normalized overlap. 1=perfect alignment.</strong></td>
</tr>
</tbody>
</table>
<div id="adfbbbfa" class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co"># let's set up our example</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="co">#rot_mat = -np.eye(3)</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="co">#rot_mat = stats.special_ortho_group.rvs(3)</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>rot_mat <span class="op">=</span> <span class="op">-</span>stats.special_ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>rot_mat, np.linalg.det(rot_mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(array([[ 0.93858452, -0.25998611, -0.22686191],
        [ 0.29335272,  0.94740493,  0.12793776],
        [-0.18166805,  0.18663096, -0.96548724]]),
 -1.0000000000000004)</code></pre>
</div>
</div>
<div id="167596b9" class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>mesh_rotated <span class="op">=</span> deepcopy(mesh)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>mesh_rotated.vertices <span class="op">=</span> mesh_rotated.vertices <span class="op">@</span> rot_mat.T</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>signal_rotated <span class="op">=</span> np.copy(signal)</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>centroids_rotated <span class="op">=</span> mesh_rotated.vertices[mesh_rotated.tris].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>_, theta_rotated, phi_rotated <span class="op">=</span> cartesian_to_spherical(centroids_rotated)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>weights_rotated <span class="op">=</span> igl.doublearea(mesh_rotated.vertices, mesh.tris)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>spherical_harmonics_coeffs_rotated <span class="op">=</span> compute_spherical_harmonics_coeffs(signal_rotated,</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>                                                                        phi_rotated, theta_rotated,</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>                                                                        weights_rotated, max_l<span class="op">=</span>max_l)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6ffc594e" class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>R_opt, overlap, R_opt_flipped, overlap_flipped <span class="op">=</span> rotation_alignment_brute_force(spherical_harmonics_coeffs_direct,</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>                                                                                 spherical_harmonics_coeffs_rotated,</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>                                                            max_l<span class="op">=</span><span class="dv">10</span>, n_angle<span class="op">=</span><span class="dv">100</span>, n_subdiv_axes<span class="op">=</span><span class="dv">2</span>, allow_flip<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>rot_mat_to_quaternion(R_opt_flipped), rot_mat_to_quaternion(rot_mat), overlap, overlap_flipped</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 3.62 s, sys: 0 ns, total: 3.62 s
Wall time: 3.62 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>(array([ 0.15643447, -0.07492257,  0.13505986, -0.97553765]),
 array([ 0.14097676, -0.10408312,  0.08014416, -0.98125897]),
 (0.9910003623902994+7.84107514069421e-17j),
 (0.9931975537491813+6.548624948738893e-17j))</code></pre>
</div>
</div>
<div id="5bad2c2b" class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(R_opt<span class="op">-</span>rot_mat), np.linalg.norm(R_opt_flipped<span class="op">-</span>rot_mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2.0000958259305763, 0.18184532747844342)</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L502" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rotation_alignment_refined" class="level3">
<h3 class="anchored" data-anchor-id="rotation_alignment_refined">rotation_alignment_refined</h3>
<blockquote class="blockquote">
<pre><code> rotation_alignment_refined (sph_harmonics_source, sph_harmonics_target,
                             R_initial, max_l=None, maxfev=100)</code></pre>
</blockquote>
<p>*Refine rotational alignment between two signals on the sphere by optimization.</p>
<p>The two signals have to be represented by their spherical harmonics coefficients. Uses Wigner-D matrices to calculate the overlap between the two signals and uses Nelder-Mead optimization to find the best one.</p>
<p>Requires a good initial guess for the rotation, as created by rotation_alignment_brute_force.</p>
<p>The rotation is such that it transforms the source signal to match the target.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sph_harmonics_source</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Source signal, to be<br>transformed.</td>
</tr>
<tr class="even">
<td>sph_harmonics_target</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Target signal.</td>
</tr>
<tr class="odd">
<td>R_initial</td>
<td>(3, 3) np.array</td>
<td></td>
<td>Initial rotation as a rotation matrix</td>
</tr>
<tr class="even">
<td>max_l</td>
<td>NoneType</td>
<td>None</td>
<td>Maximum angular momentum. If None, the maximum value available in the input<br>spherical harmonics is used.</td>
</tr>
<tr class="odd">
<td>maxfev</td>
<td>int</td>
<td>100</td>
<td>Number of function evaluations during optimization. This parameter has<br>the strongest influence on the run time.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array, float</strong></td>
<td></td>
<td><strong>optimal_rotation : (3, 3) np.array<br> Best rotation as rotation matrix. Will always have the same determinant (i.e.&nbsp;-1, 1)<br> as the initial guess.<br>overlap : float<br> Normalized overlap. 1=perfect alignment.</strong></td>
</tr>
</tbody>
</table>
<div id="89338eb7" class="cell">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>R_refined, overlap_refined <span class="op">=</span> rotation_alignment_refined(spherical_harmonics_coeffs_direct,</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>                                                        spherical_harmonics_coeffs_rotated, R_opt_flipped,</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>                                                        max_l<span class="op">=</span><span class="dv">10</span>, maxfev<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>rot_mat_to_quaternion(R_refined), np.linalg.det(R_refined), overlap_refined</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 1.74 s, sys: 20 ms, total: 1.76 s
Wall time: 1.75 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>(array([ 0.14097678, -0.10408313,  0.08014421, -0.98125896]),
 -0.9999999999999999,
 0.9999999999999993)</code></pre>
</div>
</div>
<div id="17bb0c4f" class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(R_refined<span class="op">-</span>rot_mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>1.5330429766260706e-07</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_tissue_cartography/rotation.py#L561" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rotational_alignment" class="level3">
<h3 class="anchored" data-anchor-id="rotational_alignment">rotational_alignment</h3>
<blockquote class="blockquote">
<pre><code> rotational_alignment (sph_harmonics_source, sph_harmonics_target,
                       allow_flip=False, max_l=None, n_angle=100,
                       n_subdiv_axes=1, maxfev=100)</code></pre>
</blockquote>
<p>*Rotational alignment between two signals on the sphere.</p>
<p>The two signals have to be represented by their spherical harmonics coefficients. Uses Wigner-D matrices to calculate the overlap between the two signals.</p>
<p>Alignment happens in two steps: first, a coarse alignment using a large number of trial rotation axes and angles, and then refinement via optimization.</p>
<p>The rotation is such that it transforms the source signal to match the target.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sph_harmonics_source</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Source signal, to be<br>transformed.</td>
</tr>
<tr class="even">
<td>sph_harmonics_target</td>
<td>dict of np.array</td>
<td></td>
<td>Dictionary, indexed by total angular momentum l=0 ,…, max_l. Each entry is a vector<br>of coefficients for the different values of m=-2l,…,2*l. Target signal.</td>
</tr>
<tr class="odd">
<td>allow_flip</td>
<td>bool</td>
<td>False</td>
<td>Whether to allow improper rotations with determinant -1.</td>
</tr>
<tr class="even">
<td>max_l</td>
<td>NoneType</td>
<td>None</td>
<td>Maximum angular momentum. If None, the maximum value available in the input<br>spherical harmonics is used.</td>
</tr>
<tr class="odd">
<td>n_angle</td>
<td>int</td>
<td>100</td>
<td>Number of trial rotation angles [0,…, 2*pi]</td>
</tr>
<tr class="even">
<td>n_subdiv_axes</td>
<td>int</td>
<td>1</td>
<td>Controls the number of trial rotation axes. Rotation axes are vertices of<br>the icosphere which can be subdivided. There will be roughly<br>40*4**n_subdiv_axes trial axes. This parameter has the strongest influence<br>on the run time.</td>
</tr>
<tr class="odd">
<td>maxfev</td>
<td>int</td>
<td>100</td>
<td>Number of function evaluations during fine optimization.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.array, float</strong></td>
<td></td>
<td><strong>optimal_rotation : (3, 3) np.array<br> Best rotation as rotation matrix. Will always have the same determinant (i.e.&nbsp;-1, 1)<br> as the initial guess.<br>overlap : float<br> Normalized overlap. 1=perfect alignment.</strong></td>
</tr>
</tbody>
</table>
<div id="60609bad" class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>R_refined, overlap <span class="op">=</span> rotational_alignment(spherical_harmonics_coeffs_direct, spherical_harmonics_coeffs_rotated,</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>                                          max_l<span class="op">=</span><span class="dv">10</span>, n_angle<span class="op">=</span><span class="dv">100</span>, n_subdiv_axes<span class="op">=</span><span class="dv">1</span>, maxfev<span class="op">=</span><span class="dv">200</span>,</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>                                          allow_flip<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(R_refined<span class="op">-</span>rot_mat), np.<span class="bu">round</span>(np.linalg.det(R_refined)), overlap</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 4.49 s, sys: 35 μs, total: 4.49 s
Wall time: 4.48 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>(1.5571961945381298e-07, -1.0, 0.999999999999998)</code></pre>
</div>
</div>
</section>
<section id="how-well-does-this-work" class="level3">
<h3 class="anchored" data-anchor-id="how-well-does-this-work">How well does this work?</h3>
<p>Looks pretty good! I find that using about 160 trial rotation axes in the brute force step (<code>subdiv=1</code>) is a good choice - fewer trial axes lead to poor initial guesses.</p>
<p>However, the first guess can often get the parity wrong! Therefore, it is best to run brute force and fine alignment for both parities, and then choose which one is better.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nikolas-claussen\.github\.io\/blender-tissue-cartography");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>
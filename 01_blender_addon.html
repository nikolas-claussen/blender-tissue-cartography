<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Blender add-on – blender-tissue-cartography</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-0652833b129a4aecb7d8777fd89a11f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Blender add-on – blender-tissue-cartography">
<meta property="og:description" content="Pipeline for tissue extraction and analysis of surfaces from volumetric mircroscopy data using blender">
<meta property="og:site_name" content="blender-tissue-cartography">
<meta name="twitter:title" content="Blender add-on – blender-tissue-cartography">
<meta name="twitter:description" content="Pipeline for tissue extraction and analysis of surfaces from volumetric mircroscopy data using blender">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">blender-tissue-cartography</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01_blender_addon.html">Blender add-on</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">blender-tissue-cartography</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_tissue_cartography_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tissue cartography with <code>blender_tisssue_cartography</code></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_blender_addon.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Blender add-on</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Python library</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/io.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image I/O</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/01b_mesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh data structure</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/01c_interface_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>pymeshlab</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/01d_interface_trimesh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><code>trimesh</code> interface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/01e_morphsnakes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Morphsnakes segmentation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/02_cartographic_interpolation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cartographic interpolation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/differential_geometry.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Surface differential geometry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/remeshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/remeshing_pymeshlab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh creation and remeshing with MeshLab</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/04c_smoothing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mesh smoothing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/registration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rigid-body registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/registration_rotation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3D-rotation registration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/05c_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shrink-wrapping</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Python library/06_harmonic_wrapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Harmonic mapping</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/01_segmentation_with_ilastik.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 3d segmentation with Ilastik</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/02_blender_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Blender tutorial</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/03_blender_addon_tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. <code>blender_tissue_cartography</code> blender add-on</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/04_btc_python_library.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. <code>blender_tissue_cartography</code> Python library</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/05_UV_maps_with_seams.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Tissue cartography with “seams”</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/06_improving_UV_maps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Iteratively improving cartographic projections</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/07_advanced_segmentation_and_meshing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. Advanced segmentation and meshing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/08_multiple_recordings_and_reference_meshes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. Consistent cartographic projections across multiple recordings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/09_movies_and_dynamic_surfaces.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. Time-lapse imaging and dynamic surfaces</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Tutorials/10_analysis_in_3d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 3D Image analysis with cartographic projections</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#add-on-design" id="toc-add-on-design" class="nav-link active" data-scroll-target="#add-on-design">Add-on design</a></li>
  <li><a href="#add-on-code" id="toc-add-on-code" class="nav-link" data-scroll-target="#add-on-code">Add-on code</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Blender add-on</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>Blender add-on for loading and visualizing volumetric data into blender and projecting image intensities onto a mesh surface</p>
</blockquote>
<p><strong>Note</strong> This module is <em>not</em> for use in a standard python environment, but must be run as an add-on within Blender. For documentation of the add-on user interface, see tutorial 3. This page documents the add-on code.</p>
<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="add-on-design" class="level3">
<h3 class="anchored" data-anchor-id="add-on-design">Add-on design</h3>
<p>The add-on code comprises three parts:</p>
<ol type="1">
<li><p>Functions for carrying out key tissue cartography operations. These are based on the <code>blender_tissue_cartography</code> python library, edited to reflect the constraints of python scripting in blender (e.g.&nbsp;the <code>igl</code> library is not available).</p></li>
<li><p>A class (inherting from <code>bpy.types.Operator</code>) defining each add-on button, with an <code>execute</code> function defining what happens when you click it.</p></li>
<li><p>The <code>TissueCartographyPanel(Panel)</code> class and the <code>register</code> function defining all user input fields and how user input fields and buttons from part 2 are laid out in the Tissue Cartography Panel.</p></li>
</ol>
<p>All functions and classes are documented below.</p>
<p>To allow the user to load multiple 3D datasets and meshes into the same blender file, image data is associated with mesh objects. Which data any operation is applied to is determined by the currently selected mesh.</p>
<p>The <code>bpy</code> library allows the add-on to interact with blender. It is only available within blender’s python scripting interface, which is why you cannot run the add-on in a normal python interpreter. See this tutorial for an introduction into scripting Blender: https://docs.blender.org/manual/en/latest/advanced/scripting/addon_tutorial.html</p>
<p>If you want to edit/extend the add-on, be aware of the following <strong>hacks</strong> used:</p>
<ol type="1">
<li><p><em>Associating data with meshes</em>: In the add-on, tissue cartography data is associated with blender meshes. For example, loaded volumetric image data (represented as a <code>numpy</code> array) is associated with a <code>BoundingBox</code> rectangular cuboid showing the volume covered by the image data (see tutorial 3). Unfortunately, blender does not allow adding arbitrary attributes to meshes. The functions <code>set_numpy_attribute</code>/<code>get_numpy_attribute</code> circumvent this by representing array data as binary buffer + shape. To associate functions with a mesh (e.g.&nbsp;interpolators), a global dictionary is used.</p></li>
<li><p><em>UV layout</em>: To obtain the part of the UV square covered by an unwrapped mesh, a <code>.png</code> of the layout is exported to disk and re-read.</p></li>
</ol>
<p>The add-on makes use of the following libraries which are included with the add-ons using wheels: <code>numpy, tifffile, scipy, skimage</code>.</p>
</section>
<section id="add-on-code" class="level3">
<h3 class="anchored" data-anchor-id="add-on-code">Add-on code</h3>
<p>The code below is shown for completeness of the documentation webpage. Please download the add-on code from GitHub <a href="https://github.com/nikolas-claussen/blender-tissue-cartography/blob/main/blender_addon/blender_addon.py">here</a>.</p>
<div id="7593c93b-e3d2-4bd7-9ec1-feff5b950615" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>bl_info <span class="op">=</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"name"</span>: <span class="st">"Tissue Cartography"</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"blender"</span>: (<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">0</span>),</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"category"</span>: <span class="st">"Scene"</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bpy</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bpy.props <span class="im">import</span> StringProperty, FloatProperty, FloatVectorProperty, IntProperty, IntVectorProperty, BoolProperty, EnumProperty</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bpy.types <span class="im">import</span> Operator, Panel</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mathutils</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bmesh</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> difflib</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> subprocess</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tifffile</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> interpolate, ndimage, spatial, stats, linalg</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage <span class="im">import</span> measure</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">### Installing dependencies</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> install_dependencies():</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> scipy</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> skimage</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        python_executable <span class="op">=</span> sys.executable</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        subprocess.check_call([python_executable, <span class="st">"-m"</span>, <span class="st">"pip"</span>, <span class="st">"install"</span>, <span class="st">"scipy"</span>, <span class="st">"scikit-image"</span>, <span class="st">"tifffile"</span>])</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">### I/O and image handling</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_png(image_path):</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Load .png into numpy array."""</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> bpy.data.images.load(image_path)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    width, height <span class="op">=</span> image.size</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    pixels <span class="op">=</span> np.array(image.pixels[:], dtype<span class="op">=</span>np.float32)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pixels.reshape((height, width, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize_quantiles(image, quantiles<span class="op">=</span>(<span class="fl">0.01</span>, <span class="fl">0.99</span>), channel_axis<span class="op">=</span><span class="va">None</span>, clip<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>                        data_type<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">    Normalize a multi-dimensional image by setting given quantiles to 0 and 1.</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co">    image : np.array</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="co">        Multi-dimensional image.</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="co">    quantiles : tuple</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a><span class="co">        Image quantile to set to 0 and 1.</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co">    channel_axis : int or None</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co">        If None, the image is assumed to have only a single channel.</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="co">        If int, indicates the position of the channel axis. </span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="co">        Each channel is normalized separately.</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="co">    clip : bool</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="co">        Whether to clip image to 0-1. Automatically enabled if converting to int dtype.</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="co">    data_type : None, np.unit8 or np.uint16</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="co">        If not None, image is converted to give data type.</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a><span class="co">    image_normalized : np.array</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="co">        Normalized image, the same shape as input</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> channel_axis <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> image <span class="op">-</span> np.nanquantile(image, quantiles[<span class="dv">0</span>])</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">/=</span> np.nanquantile(image_normalized, quantiles[<span class="dv">1</span>])</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.nan_to_num(image_normalized)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.moveaxis(image, channel_axis, <span class="dv">0</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.stack([ch <span class="op">-</span> np.nanquantile(ch, quantiles[<span class="dv">0</span>]) <span class="cf">for</span> ch <span class="kw">in</span> image_normalized])</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.stack([ch <span class="op">/</span> np.nanquantile(ch, quantiles[<span class="dv">1</span>]) <span class="cf">for</span> ch <span class="kw">in</span> image_normalized])</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.moveaxis(np.nan_to_num(image_normalized), <span class="dv">0</span>, channel_axis)</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> clip <span class="kw">or</span> (data_type <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>):</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.clip(image_normalized, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data_type <span class="kw">is</span> np.uint8:</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.<span class="bu">round</span>((<span class="dv">2</span><span class="op">**</span><span class="dv">8</span><span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>image_normalized).astype(np.uint8)</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data_type <span class="kw">is</span> np.uint16:</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        image_normalized <span class="op">=</span> np.<span class="bu">round</span>((<span class="dv">2</span><span class="op">**</span><span class="dv">16</span><span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>image_normalized).astype(np.uint16)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> image_normalized</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> axis_order_to_transpose(axis_order_string):</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert string describing axis order into tuple for use in np.transpose."""</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="st">''</span>.join(<span class="bu">sorted</span>(axis_order_string)) <span class="kw">in</span> [<span class="st">'xyz'</span>, <span class="st">'cxyz'</span>], <span class="st">"Must be xyz, cxyz, or permutation thereof"</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'c'</span> <span class="kw">in</span> axis_order_string:</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        transpose <span class="op">=</span> [axis_order_string.index(k) <span class="cf">for</span> k <span class="kw">in</span> <span class="st">'cxyz'</span>]</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        transpose <span class="op">=</span> [axis_order_string.index(k) <span class="cf">for</span> k <span class="kw">in</span> <span class="st">'xyz'</span>]</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transpose</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="co">### Tissue cartography - projecting 3d images to UV textures</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_uv_layout(obj, uv_layout_path, image_resolution):</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Get UV layout mask for obj object as a np.array. As a side effect, saves layout to disk and deselects everything except obj."""</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> os.path.exists(uv_layout_path):</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        os.remove(uv_layout_path)</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    bpy.ops.<span class="bu">object</span>.select_all(action<span class="op">=</span><span class="st">'DESELECT'</span>)  <span class="co"># Deselect all objects</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>    obj.select_set(<span class="va">True</span>)  <span class="co"># Select the specific object</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>    bpy.context.view_layer.objects.active <span class="op">=</span> obj</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>    bpy.ops.<span class="bu">object</span>.mode_set(mode<span class="op">=</span><span class="st">'EDIT'</span>)</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set all faces to selected for the UV layout</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> bmesh.from_edit_mesh(obj.data)</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> face <span class="kw">in</span> mesh.faces:</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        face.select <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    bmesh.update_edit_mesh(obj.data)</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    bpy.ops.uv.export_layout(filepath<span class="op">=</span>uv_layout_path, size<span class="op">=</span>(image_resolution, image_resolution), opacity<span class="op">=</span><span class="dv">1</span>, export_all<span class="op">=</span><span class="va">False</span>, check_existing<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    bpy.ops.<span class="bu">object</span>.mode_set(mode<span class="op">=</span><span class="st">'OBJECT'</span>)</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    UV_layout <span class="op">=</span> load_png(uv_layout_path)</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (UV_layout.<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">&gt;</span> <span class="dv">0</span>)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_uv_normal_world_per_loop(mesh_obj, filter_unique<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="co">    Get UV, normals, and world and normal for each loop (half-edge) as np.array.</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a><span class="co">    If filter_unique, remove "duplicate" loops (for which UV, normals and position</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a><span class="co">    are identical).</span></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> mesh_obj:</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"No object selected"</span>)</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mesh_obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Selected object is not a mesh"</span>)</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    world_matrix <span class="op">=</span> mesh_obj.matrix_world</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>    uv_layer <span class="op">=</span> mesh_obj.data.uv_layers.active</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> uv_layer:</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">"Mesh does not have an active UV map"</span>)</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>    loop_uvs <span class="op">=</span> np.zeros((<span class="bu">len</span>(mesh_obj.data.loops), <span class="dv">2</span>), dtype<span class="op">=</span>np.float32)</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    loop_normals <span class="op">=</span> np.zeros((<span class="bu">len</span>(mesh_obj.data.loops), <span class="dv">3</span>), dtype<span class="op">=</span>np.float32)</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    loop_world_positions <span class="op">=</span> np.zeros((<span class="bu">len</span>(mesh_obj.data.loops), <span class="dv">3</span>), dtype<span class="op">=</span>np.float32)</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> loop <span class="kw">in</span> mesh_obj.data.loops:</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>        loop_uvs[loop.index] <span class="op">=</span> uv_layer.data[loop.index].uv</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>        loop_normals[loop.index] <span class="op">=</span> world_matrix.to_3x3() <span class="op">@</span> mesh_obj.data.vertices[loop.vertex_index].normal</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>        loop_world_positions[loop.index] <span class="op">=</span> world_matrix <span class="op">@</span> mesh_obj.data.vertices[loop.vertex_index].co</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> filter_unique:</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>        unqiue_loops <span class="op">=</span> np.unique(np.hstack([loop_uvs, loop_normals, loop_world_positions]), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>        loop_uvs, loop_normals, loop_world_positions <span class="op">=</span> (unqiue_loops[:,:<span class="dv">2</span>], unqiue_loops[:,<span class="dv">2</span>:<span class="dv">5</span>], unqiue_loops[:,<span class="dv">5</span>:])</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>    loop_normals <span class="op">=</span> np.<span class="bu">round</span>((loop_normals.T<span class="op">/</span>np.linalg.norm(loop_normals, axis<span class="op">=</span><span class="dv">1</span>)).T, decimals<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loop_uvs, loop_normals, loop_world_positions</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bake_per_loop_values_to_uv(loop_uvs, loop_values, image_resolution):</span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a><span class="co">    Bake (interpolate) values (normals or world position) defined per loop into the UV square.</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a><span class="co">    UV coordinates outside [0,1] are ignored.</span></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a><span class="co">    loop_uvs : np.array of shape (n_loops, 2)</span></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a><span class="co">        UV coordinates of loop.</span></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a><span class="co">    loop_values : np.array of shape (n_loops, ...)</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="co">        Input field. Can be an array with any number of axes (e.g. scalar or vector field).</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a><span class="co">    image_resolution : int, default 256</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a><span class="co">        Size of UV grid. Determines resolution of result.</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a><span class="co">    interpolated : np.array of shape (uv_grid_steps, uv_grid_steps, ...)</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a><span class="co">        Field across [0,1]**2 UV grid, with a uniform step size. UV positions that don't</span></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a><span class="co">        correspond to any value are set to np.nan.</span></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>    U, V <span class="op">=</span> np.meshgrid(<span class="op">*</span>(<span class="dv">2</span><span class="op">*</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, image_resolution),)))</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>    interpolated <span class="op">=</span> interpolate.griddata(loop_uvs, loop_values, (U, V), method<span class="op">=</span><span class="st">'linear'</span>)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> interpolated</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bake_volumetric_data_to_uv(image, baked_world_positions, resolution, baked_normals, normal_offsets<span class="op">=</span>(<span class="dv">0</span>,), affine_matrix<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" </span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a><span class="co">    Interpolate volumetric image data onto UV coordinate grid.</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses baked 3d world positions corresponding to each UV grid point (see bake_per_loop_values_to_UV).</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a><span class="co">    3d coordinates (in microns) are converted into image coordinates via the resolution scaling factor.</span></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a><span class="co">    The resolution of the bake (number of pixels) is determined by the shape of baked_world_positions.</span></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a><span class="co">    normal_offsets moves the 3d positions whose volumetric voxel values will be baked inwards or outwards</span></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a><span class="co">    along the surface normal. Providing a list of offsets results in a multi-layer pullback</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a><span class="co">    image : 4d np.array</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a><span class="co">        Image, axis 0  is assumed to be the channel axis</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a><span class="co">    baked_world_positions : np.array of shape (image_resolution, image_resolution, uv_grid_steps, 3)</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a><span class="co">        3d world positions baked to UV grid, with uniform step size. UV positions that don't correspond to </span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a><span class="co">        any value are set to np.nan.</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a><span class="co">    resolution : np.array of shape (3,)</span></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a><span class="co">        Resolution in pixels/microns for each of the three spatial axes.</span></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a><span class="co">    baked_normals : np.array of shape (image_resolution, image_resolution, uv_grid_steps, 3)</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a><span class="co">        3d world normals baked to UV grid, with uniform step size. UV positions that don't correspond to </span></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a><span class="co">        any value are set to np.nan.</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a><span class="co">    normal_offsets : np.array of shape (n_layers,), default (0,)</span></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a><span class="co">        Offsets along normal direction, in same units as interpolated_3d_positions (i.e. microns).</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a><span class="co">        0 corresponds to no shift.</span></span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a><span class="co">    affine_matrix : np.array of shape (4, 4) or None</span></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="co">        If not None, transform coordinates by affine trafor before calling interpolator</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a><span class="co">    aked_data : np.array of shape (n_channels, n_layers, image_resolution, image_resolution)</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a><span class="co">        Multi-layer 3d volumetric data baked onto UV.</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>    x, y, z <span class="op">=</span> [np.arange(ni) <span class="cf">for</span> ni <span class="kw">in</span> image.shape[<span class="dv">1</span>:]]</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>    baked_data <span class="op">=</span> []</span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> o <span class="kw">in</span> normal_offsets:</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>        position <span class="op">=</span> (baked_world_positions<span class="op">+</span>o<span class="op">*</span>baked_normals)</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> affine_matrix <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>            position <span class="op">=</span> position <span class="op">@</span> affine_matrix[:<span class="dv">3</span>, :<span class="dv">3</span>].T <span class="op">+</span> affine_matrix[:<span class="dv">3</span>,<span class="dv">3</span>]</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>        position <span class="op">=</span>  position<span class="op">/</span>resolution</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>        baked_layer_data <span class="op">=</span> np.stack([interpolate.interpn((x, y, z), channel, position,</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>                                     method<span class="op">=</span><span class="st">"linear"</span>, bounds_error<span class="op">=</span><span class="va">False</span>) <span class="cf">for</span> channel <span class="kw">in</span> image])</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>        baked_data.append(baked_layer_data)</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>    baked_data <span class="op">=</span> np.stack(baked_data, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> baked_data</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a><span class="co">### Bounding box and orthoslices for visualizing the 3d data</span></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_box(length, width, height, name<span class="op">=</span><span class="st">"RectangularBox"</span>, hide<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a rectangular box using Blender's default cube.</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a><span class="co">    One corner is positioned at the origin, and the box lies in the positive x/y/z quadrant.</span></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a><span class="co">        length (float): Length of the box along the X-axis.</span></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a><span class="co">        width (float): Width of the box along the Y-axis.</span></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a><span class="co">        height (float): Height of the box along the Z-axis.</span></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the current active object</span></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>    current_active <span class="op">=</span> bpy.context.active_object</span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>    bpy.ops.mesh.primitive_cube_add(size<span class="op">=</span><span class="dv">2</span>, location<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>    obj <span class="op">=</span> bpy.context.active_object</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>    obj.name <span class="op">=</span> name</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>    obj.scale <span class="op">=</span> (length <span class="op">/</span> <span class="dv">2</span>, width <span class="op">/</span> <span class="dv">2</span>, height <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>    obj.location <span class="op">=</span> (length <span class="op">/</span> <span class="dv">2</span>, width <span class="op">/</span> <span class="dv">2</span>, height <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>    bpy.ops.<span class="bu">object</span>.transform_apply(location<span class="op">=</span><span class="va">True</span>, scale<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>    obj.hide_set(hide)</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>    <span class="co"># re-select the currently active object</span></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_active:</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>        bpy.context.view_layer.objects.active <span class="op">=</span> current_active</span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> obj</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_slice_plane(length, width, height, axis<span class="op">=</span><span class="st">'z'</span>, position<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a 2D plane as a slice of a rectangular box along a specified axis.</span></span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a><span class="co">    The plane lies within the bounds of the box.</span></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a><span class="co">        length (float): Length of the box along the X-axis.</span></span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a><span class="co">        width (float): Width of the box along the Y-axis.</span></span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a><span class="co">        height (float): Height of the box along the Z-axis.</span></span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a><span class="co">        axis (str): Axis along which to slice ('x', 'y', or 'z').</span></span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a><span class="co">        position (float): Position along the chosen axis for the slice plane.</span></span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a><span class="co">                          Should be within the range of the box dimensions.</span></span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>    current_active <span class="op">=</span> bpy.context.active_object</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate axis and position</span></span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axis <span class="kw">not</span> <span class="kw">in</span> {<span class="st">'x'</span>, <span class="st">'y'</span>, <span class="st">'z'</span>}:</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Axis must be 'x', 'y', or 'z'."</span>)</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a>    axis_limits <span class="op">=</span> {<span class="st">'x'</span>: length, <span class="st">'y'</span>: width, <span class="st">'z'</span>: height}</span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> (<span class="fl">0.0</span> <span class="op">&lt;=</span> position <span class="op">&lt;=</span> axis_limits[axis]):</span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Position must be within [0, </span><span class="sc">{</span>axis_limits[axis]<span class="sc">}</span><span class="ss">] for axis </span><span class="sc">{</span>axis<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create the plane's dimensions based on the slicing axis</span></span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axis <span class="op">==</span> <span class="st">'x'</span>:</span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>        plane_size <span class="op">=</span> (height, width) <span class="co">#(width, height)</span></span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a>        location <span class="op">=</span>  (position, width <span class="op">/</span> <span class="dv">2</span>, height <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a>        rotation <span class="op">=</span> (<span class="dv">0</span>, <span class="fl">1.5708</span>, <span class="dv">0</span>)  <span class="co"># Rotate to align with the YZ-plane</span></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> axis <span class="op">==</span> <span class="st">'y'</span>:</span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a>        plane_size <span class="op">=</span> (length, height)</span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a>        location <span class="op">=</span> (length <span class="op">/</span> <span class="dv">2</span>, position, height <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>        rotation <span class="op">=</span> (<span class="fl">1.5708</span>, <span class="dv">0</span>, <span class="dv">0</span>)  <span class="co"># Rotate to align with the XZ-plane</span></span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># 'z'</span></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>        plane_size <span class="op">=</span> (length, width)</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>        location <span class="op">=</span> (length <span class="op">/</span> <span class="dv">2</span>, width <span class="op">/</span> <span class="dv">2</span>, position)</span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a>        rotation <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)  <span class="co"># No rotation needed for the XY-plane</span></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add a plane</span></span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a>    bpy.ops.mesh.primitive_plane_add(size<span class="op">=</span><span class="dv">2</span>, location<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a>    plane <span class="op">=</span> bpy.context.active_object</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a>    plane.name <span class="op">=</span> <span class="ss">f"SlicePlane_</span><span class="sc">{</span>axis<span class="sc">.</span>upper()<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>position<span class="sc">:.2f}</span><span class="ss">"</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale and position the plane</span></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>    plane.scale <span class="op">=</span> (plane_size[<span class="dv">0</span>] <span class="op">/</span> <span class="dv">2</span>, plane_size[<span class="dv">1</span>] <span class="op">/</span> <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a>    plane.location <span class="op">=</span> location</span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a>    plane.rotation_euler <span class="op">=</span> rotation</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply transformations (scale, location, rotation)</span></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a>    bpy.ops.<span class="bu">object</span>.transform_apply(location<span class="op">=</span><span class="va">True</span>, scale<span class="op">=</span><span class="va">True</span>, rotation<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Restore the previously active object</span></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_active:</span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a>        bpy.context.view_layer.objects.active <span class="op">=</span> current_active</span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> plane</span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_slice_image(image_3d, resolution, axis<span class="op">=</span><span class="st">'z'</span>, position<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Get slice of 3d image along axis for ortho-slice visualization.</span></span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a><span class="co">    image_3d must be a 4d array (channels, x, y, z). Position in microns."""</span></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axis <span class="op">==</span> <span class="st">'x'</span>:</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a>        ind <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">round</span>(position <span class="op">/</span> resolution[<span class="dv">0</span>]))</span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a>        slice_img <span class="op">=</span> image_3d[:,ind,:,::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> axis <span class="op">==</span> <span class="st">'y'</span>:</span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a>        ind <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">round</span>(position <span class="op">/</span> resolution[<span class="dv">1</span>]))</span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a>        slice_img <span class="op">=</span> image_3d[:,:,ind,:].transpose((<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> axis <span class="op">==</span> <span class="st">'z'</span>: </span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a>        ind <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">round</span>(position <span class="op">/</span> resolution[<span class="dv">0</span>]))</span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a>        slice_img <span class="op">=</span> image_3d[:,:,:,ind].transpose((<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> slice_img</span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_material_from_array(slice_plane, array, material_name<span class="op">=</span><span class="st">"SliceMaterial"</span>):</span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a material for a ortho-slice plane using a 2D numpy array as a texture.</span></span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a><span class="co">        slice_plane (bpy.types.Object): The plane object to which the material will be applied.</span></span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a><span class="co">        array (numpy.ndarray): 2D array representing grayscale values (0-1), or 3D array representing RGBA values (0-1).</span></span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a><span class="co">        material_name (str): Name of the new material.</span></span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate input array</span></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(array.shape) <span class="kw">in</span> [<span class="dv">2</span>,<span class="dv">3</span>]:</span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input array must be 2D."</span>)</span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize array to range [0, 1] and convert to a flat list</span></span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a>    image_height, image_width <span class="op">=</span> array.shape[:<span class="dv">2</span>]</span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a>    pixel_data <span class="op">=</span> np.zeros((image_height, image_width, <span class="dv">4</span>), dtype<span class="op">=</span>np.float32)  <span class="co"># RGBA</span></span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(array.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a>        pixel_data[..., <span class="dv">0</span>] <span class="op">=</span>  pixel_data[..., <span class="dv">1</span>] <span class="op">=</span> pixel_data[..., <span class="dv">2</span>] <span class="op">=</span> array</span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a>        pixel_data[..., <span class="dv">3</span>] <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Alpha</span></span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a>        pixel_data[...] <span class="op">=</span> array</span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a>    pixel_data <span class="op">=</span> pixel_data.flatten()</span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new image in Blender</span></span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> bpy.data.images.new(name<span class="op">=</span><span class="st">"SliceTexture"</span>, width<span class="op">=</span>image_width, height<span class="op">=</span>image_height)</span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a>    image.pixels <span class="op">=</span> pixel_data.tolist()</span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new material</span></span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a>    material <span class="op">=</span> bpy.data.materials.new(name<span class="op">=</span>material_name)</span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a>    material.use_nodes <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> material.node_tree.nodes</span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a>    links <span class="op">=</span> material.node_tree.links</span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clear default nodesx</span></span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a>        nodes.remove(node)</span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add required nodes</span></span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a>    texture_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeTexImage"</span>)</span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a>    texture_node.image <span class="op">=</span> image</span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a>    bsdf_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeBsdfPrincipled"</span>)</span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a>    output_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeOutputMaterial"</span>)</span>
<span id="cb1-375"><a href="#cb1-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-376"><a href="#cb1-376" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Arrange nodes</span></span>
<span id="cb1-377"><a href="#cb1-377" aria-hidden="true" tabindex="-1"></a>    texture_node.location <span class="op">=</span> (<span class="op">-</span><span class="dv">400</span>, <span class="dv">0</span>)</span>
<span id="cb1-378"><a href="#cb1-378" aria-hidden="true" tabindex="-1"></a>    bsdf_node.location <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-379"><a href="#cb1-379" aria-hidden="true" tabindex="-1"></a>    output_node.location <span class="op">=</span> (<span class="dv">400</span>, <span class="dv">0</span>)</span>
<span id="cb1-380"><a href="#cb1-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-381"><a href="#cb1-381" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Connect nodes</span></span>
<span id="cb1-382"><a href="#cb1-382" aria-hidden="true" tabindex="-1"></a>    links.new(texture_node.outputs[<span class="st">"Color"</span>], bsdf_node.inputs[<span class="st">"Base Color"</span>])</span>
<span id="cb1-383"><a href="#cb1-383" aria-hidden="true" tabindex="-1"></a>    links.new(bsdf_node.outputs[<span class="st">"BSDF"</span>], output_node.inputs[<span class="st">"Surface"</span>])</span>
<span id="cb1-384"><a href="#cb1-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-385"><a href="#cb1-385" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign the material to the plane</span></span>
<span id="cb1-386"><a href="#cb1-386" aria-hidden="true" tabindex="-1"></a>    slice_plane.active_material <span class="op">=</span> material</span>
<span id="cb1-387"><a href="#cb1-387" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-388"><a href="#cb1-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-389"><a href="#cb1-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-390"><a href="#cb1-390" aria-hidden="true" tabindex="-1"></a><span class="co">### Pullback shading</span></span>
<span id="cb1-391"><a href="#cb1-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-392"><a href="#cb1-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-393"><a href="#cb1-393" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_material_from_multilayer_array(mesh, array, material_name<span class="op">=</span><span class="st">"ProjectedMaterial"</span>):</span>
<span id="cb1-394"><a href="#cb1-394" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-395"><a href="#cb1-395" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a material for a mesh using multi-channel, multi-layer projection.</span></span>
<span id="cb1-396"><a href="#cb1-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-397"><a href="#cb1-397" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-398"><a href="#cb1-398" aria-hidden="true" tabindex="-1"></a><span class="co">        obj (bpy.types.Object): The mesh object to which the material will be applied.</span></span>
<span id="cb1-399"><a href="#cb1-399" aria-hidden="true" tabindex="-1"></a><span class="co">        array (numpy.ndarray): 4D array of shape (channels, layers, U, V)</span></span>
<span id="cb1-400"><a href="#cb1-400" aria-hidden="true" tabindex="-1"></a><span class="co">        material_name (str): Name of the new material.</span></span>
<span id="cb1-401"><a href="#cb1-401" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-402"><a href="#cb1-402" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate and normalize input array</span></span>
<span id="cb1-403"><a href="#cb1-403" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(array.shape) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb1-404"><a href="#cb1-404" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input array must have 4 axes."</span>)</span>
<span id="cb1-405"><a href="#cb1-405" aria-hidden="true" tabindex="-1"></a>    array_normalized <span class="op">=</span> normalize_quantiles(array, quantiles<span class="op">=</span>(<span class="fl">0.01</span>, <span class="fl">0.99</span>), channel_axis<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-406"><a href="#cb1-406" aria-hidden="true" tabindex="-1"></a>                                           clip<span class="op">=</span><span class="va">True</span>, data_type<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb1-407"><a href="#cb1-407" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new image in Blender for each layer and channel</span></span>
<span id="cb1-408"><a href="#cb1-408" aria-hidden="true" tabindex="-1"></a>    image_height, image_width <span class="op">=</span> array.shape[<span class="op">-</span><span class="dv">2</span>:]</span>
<span id="cb1-409"><a href="#cb1-409" aria-hidden="true" tabindex="-1"></a>    n_channels, n_layers <span class="op">=</span> array.shape[:<span class="dv">2</span>]</span>
<span id="cb1-410"><a href="#cb1-410" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> {}</span>
<span id="cb1-411"><a href="#cb1-411" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ic, chanel <span class="kw">in</span> <span class="bu">enumerate</span>(array_normalized):</span>
<span id="cb1-412"><a href="#cb1-412" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> il, layer <span class="kw">in</span> <span class="bu">enumerate</span>(chanel):</span>
<span id="cb1-413"><a href="#cb1-413" aria-hidden="true" tabindex="-1"></a>            pixel_data <span class="op">=</span> np.zeros((image_height, image_width, <span class="dv">4</span>), dtype<span class="op">=</span>np.float32)</span>
<span id="cb1-414"><a href="#cb1-414" aria-hidden="true" tabindex="-1"></a>            pixel_data[..., <span class="dv">0</span>] <span class="op">=</span>  pixel_data[..., <span class="dv">1</span>] <span class="op">=</span> pixel_data[..., <span class="dv">2</span>] <span class="op">=</span> layer[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-415"><a href="#cb1-415" aria-hidden="true" tabindex="-1"></a>            pixel_data[..., <span class="dv">3</span>] <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Alpha</span></span>
<span id="cb1-416"><a href="#cb1-416" aria-hidden="true" tabindex="-1"></a>            pixel_data <span class="op">=</span> pixel_data.flatten()</span>
<span id="cb1-417"><a href="#cb1-417" aria-hidden="true" tabindex="-1"></a>            images[(ic, il)] <span class="op">=</span> bpy.data.images.new(name<span class="op">=</span><span class="ss">f"Channel_</span><span class="sc">{</span>ic<span class="sc">}</span><span class="ss">_Layer_</span><span class="sc">{</span>il<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb1-418"><a href="#cb1-418" aria-hidden="true" tabindex="-1"></a>                                                   width<span class="op">=</span>image_width, height<span class="op">=</span>image_height)</span>
<span id="cb1-419"><a href="#cb1-419" aria-hidden="true" tabindex="-1"></a>            images[(ic, il)].pixels <span class="op">=</span> pixel_data.tolist()</span>
<span id="cb1-420"><a href="#cb1-420" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new material</span></span>
<span id="cb1-421"><a href="#cb1-421" aria-hidden="true" tabindex="-1"></a>    material <span class="op">=</span> bpy.data.materials.new(name<span class="op">=</span>material_name)</span>
<span id="cb1-422"><a href="#cb1-422" aria-hidden="true" tabindex="-1"></a>    material.use_nodes <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-423"><a href="#cb1-423" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> material.node_tree.nodes</span>
<span id="cb1-424"><a href="#cb1-424" aria-hidden="true" tabindex="-1"></a>    links <span class="op">=</span> material.node_tree.links</span>
<span id="cb1-425"><a href="#cb1-425" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clear default nodesx</span></span>
<span id="cb1-426"><a href="#cb1-426" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb1-427"><a href="#cb1-427" aria-hidden="true" tabindex="-1"></a>        nodes.remove(node)</span>
<span id="cb1-428"><a href="#cb1-428" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add required nodes</span></span>
<span id="cb1-429"><a href="#cb1-429" aria-hidden="true" tabindex="-1"></a>    texture_nodes <span class="op">=</span> {}</span>
<span id="cb1-430"><a href="#cb1-430" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (ic, il), image <span class="kw">in</span> images.items():</span>
<span id="cb1-431"><a href="#cb1-431" aria-hidden="true" tabindex="-1"></a>        texture_nodes[(ic, il)] <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeTexImage"</span>)</span>
<span id="cb1-432"><a href="#cb1-432" aria-hidden="true" tabindex="-1"></a>        texture_nodes[(ic, il)].image <span class="op">=</span> image</span>
<span id="cb1-433"><a href="#cb1-433" aria-hidden="true" tabindex="-1"></a>        texture_nodes[(ic, il)].location <span class="op">=</span> (<span class="op">-</span><span class="dv">400</span>, ic<span class="op">*</span><span class="dv">400</span> <span class="op">+</span> il<span class="op">*</span><span class="dv">300</span>)</span>
<span id="cb1-434"><a href="#cb1-434" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-435"><a href="#cb1-435" aria-hidden="true" tabindex="-1"></a>    bsdf_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeBsdfPrincipled"</span>)</span>
<span id="cb1-436"><a href="#cb1-436" aria-hidden="true" tabindex="-1"></a>    output_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeOutputMaterial"</span>)</span>
<span id="cb1-437"><a href="#cb1-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-438"><a href="#cb1-438" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Arrange nodes</span></span>
<span id="cb1-439"><a href="#cb1-439" aria-hidden="true" tabindex="-1"></a>    bsdf_node.location <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-440"><a href="#cb1-440" aria-hidden="true" tabindex="-1"></a>    output_node.location <span class="op">=</span> (<span class="dv">400</span>, <span class="dv">0</span>)</span>
<span id="cb1-441"><a href="#cb1-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-442"><a href="#cb1-442" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Connect nodes</span></span>
<span id="cb1-443"><a href="#cb1-443" aria-hidden="true" tabindex="-1"></a>    links.new(texture_nodes[(<span class="dv">0</span>,<span class="dv">0</span>)].outputs[<span class="st">"Color"</span>], bsdf_node.inputs[<span class="st">"Base Color"</span>])</span>
<span id="cb1-444"><a href="#cb1-444" aria-hidden="true" tabindex="-1"></a>    links.new(bsdf_node.outputs[<span class="st">"BSDF"</span>], output_node.inputs[<span class="st">"Surface"</span>])</span>
<span id="cb1-445"><a href="#cb1-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-446"><a href="#cb1-446" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign the material to the mesh</span></span>
<span id="cb1-447"><a href="#cb1-447" aria-hidden="true" tabindex="-1"></a>    mesh.active_material <span class="op">=</span> material</span>
<span id="cb1-448"><a href="#cb1-448" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-449"><a href="#cb1-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-450"><a href="#cb1-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-451"><a href="#cb1-451" aria-hidden="true" tabindex="-1"></a><span class="co">### Vertex shading</span></span>
<span id="cb1-452"><a href="#cb1-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-453"><a href="#cb1-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-454"><a href="#cb1-454" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_edge_lengths(obj):</span>
<span id="cb1-455"><a href="#cb1-455" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-456"><a href="#cb1-456" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the lengths of all edges in a mesh object as a numpy array.</span></span>
<span id="cb1-457"><a href="#cb1-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-458"><a href="#cb1-458" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-459"><a href="#cb1-459" aria-hidden="true" tabindex="-1"></a><span class="co">        obj (bpy.types.Object): The mesh object to compute edge lengths for.</span></span>
<span id="cb1-460"><a href="#cb1-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-461"><a href="#cb1-461" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-462"><a href="#cb1-462" aria-hidden="true" tabindex="-1"></a><span class="co">        numpy.ndarray: A 1D array containing the lengths of all edges in the mesh.</span></span>
<span id="cb1-463"><a href="#cb1-463" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-464"><a href="#cb1-464" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure the object is a mesh</span></span>
<span id="cb1-465"><a href="#cb1-465" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-466"><a href="#cb1-466" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"The selected object is not a mesh."</span>)</span>
<span id="cb1-467"><a href="#cb1-467" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure the mesh is in edit mode for accurate vertex data</span></span>
<span id="cb1-468"><a href="#cb1-468" aria-hidden="true" tabindex="-1"></a>    bpy.context.view_layer.objects.active <span class="op">=</span> obj</span>
<span id="cb1-469"><a href="#cb1-469" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> obj.mode <span class="op">!=</span> <span class="st">'OBJECT'</span>:</span>
<span id="cb1-470"><a href="#cb1-470" aria-hidden="true" tabindex="-1"></a>        bpy.ops.<span class="bu">object</span>.mode_set(mode<span class="op">=</span><span class="st">'OBJECT'</span>)</span>
<span id="cb1-471"><a href="#cb1-471" aria-hidden="true" tabindex="-1"></a>    edge_lengths <span class="op">=</span> []</span>
<span id="cb1-472"><a href="#cb1-472" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> obj.data.edges:</span>
<span id="cb1-473"><a href="#cb1-473" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> obj.data.vertices[edge.vertices[<span class="dv">0</span>]].co</span>
<span id="cb1-474"><a href="#cb1-474" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> obj.data.vertices[edge.vertices[<span class="dv">1</span>]].co</span>
<span id="cb1-475"><a href="#cb1-475" aria-hidden="true" tabindex="-1"></a>        edge_lengths.append((v1 <span class="op">-</span> v2).length)</span>
<span id="cb1-476"><a href="#cb1-476" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(edge_lengths)</span>
<span id="cb1-477"><a href="#cb1-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-478"><a href="#cb1-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-479"><a href="#cb1-479" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_image_to_vertex_interpolator(obj, image_3d, resolution_array, quantiles<span class="op">=</span>(<span class="fl">0.01</span>, <span class="fl">0.99</span>)):</span>
<span id="cb1-480"><a href="#cb1-480" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-481"><a href="#cb1-481" aria-hidden="true" tabindex="-1"></a><span class="co">    Get interpolator that maps vertex position -&gt; image intensity.</span></span>
<span id="cb1-482"><a href="#cb1-482" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-483"><a href="#cb1-483" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns a list of interpolators, one for each channel.</span></span>
<span id="cb1-484"><a href="#cb1-484" aria-hidden="true" tabindex="-1"></a><span class="co">    To avoid aliasing, the 3d image is smoothed with</span></span>
<span id="cb1-485"><a href="#cb1-485" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma=median edge length /2. The image data is also normalized to</span></span>
<span id="cb1-486"><a href="#cb1-486" aria-hidden="true" tabindex="-1"></a><span class="co">    range from 0-1 using the provided quantiles.</span></span>
<span id="cb1-487"><a href="#cb1-487" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-488"><a href="#cb1-488" aria-hidden="true" tabindex="-1"></a>    anti_aliasing_scale <span class="op">=</span> np.median(compute_edge_lengths(obj))<span class="op">/</span><span class="dv">2</span></span>
<span id="cb1-489"><a href="#cb1-489" aria-hidden="true" tabindex="-1"></a>    image_3d_smoothed <span class="op">=</span> np.stack([ndimage.gaussian_filter(ch, anti_aliasing_scale<span class="op">/</span>resolution_array)</span>
<span id="cb1-490"><a href="#cb1-490" aria-hidden="true" tabindex="-1"></a>                                  <span class="cf">for</span> ch <span class="kw">in</span> image_3d])</span>
<span id="cb1-491"><a href="#cb1-491" aria-hidden="true" tabindex="-1"></a>    image_3d_smoothed <span class="op">=</span> normalize_quantiles(image_3d_smoothed,</span>
<span id="cb1-492"><a href="#cb1-492" aria-hidden="true" tabindex="-1"></a>                                            quantiles<span class="op">=</span>quantiles, clip<span class="op">=</span><span class="va">True</span>, data_type<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb1-493"><a href="#cb1-493" aria-hidden="true" tabindex="-1"></a>    x, y, z <span class="op">=</span> [np.arange(ni)<span class="op">*</span>resolution_array[i]</span>
<span id="cb1-494"><a href="#cb1-494" aria-hidden="true" tabindex="-1"></a>               <span class="cf">for</span> i, ni <span class="kw">in</span> <span class="bu">enumerate</span>(image_3d.shape[<span class="dv">1</span>:])]</span>
<span id="cb1-495"><a href="#cb1-495" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-496"><a href="#cb1-496" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [interpolate.RegularGridInterpolator((x,y,z), ch, method<span class="op">=</span><span class="st">'linear'</span>, bounds_error<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-497"><a href="#cb1-497" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch <span class="kw">in</span> image_3d_smoothed]</span>
<span id="cb1-498"><a href="#cb1-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-499"><a href="#cb1-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-500"><a href="#cb1-500" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> assign_vertex_colors(obj, colors):</span>
<span id="cb1-501"><a href="#cb1-501" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-502"><a href="#cb1-502" aria-hidden="true" tabindex="-1"></a><span class="co">    Assigns an RGB color to each vertex in the given object.</span></span>
<span id="cb1-503"><a href="#cb1-503" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-504"><a href="#cb1-504" aria-hidden="true" tabindex="-1"></a><span class="co">        obj: The mesh object.</span></span>
<span id="cb1-505"><a href="#cb1-505" aria-hidden="true" tabindex="-1"></a><span class="co">        colors: A list or dict of (R, G, B) tuples for each vertex.</span></span>
<span id="cb1-506"><a href="#cb1-506" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-507"><a href="#cb1-507" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-508"><a href="#cb1-508" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Object is not a mesh!"</span>)</span>
<span id="cb1-509"><a href="#cb1-509" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb1-510"><a href="#cb1-510" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obj.data.vertex_colors:</span>
<span id="cb1-511"><a href="#cb1-511" aria-hidden="true" tabindex="-1"></a>        obj.data.vertex_colors.new()</span>
<span id="cb1-512"><a href="#cb1-512" aria-hidden="true" tabindex="-1"></a>    color_layer <span class="op">=</span> obj.data.vertex_colors.active</span>
<span id="cb1-513"><a href="#cb1-513" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign colors to each loop (face corner)</span></span>
<span id="cb1-514"><a href="#cb1-514" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> loop <span class="kw">in</span> obj.data.loops:    </span>
<span id="cb1-515"><a href="#cb1-515" aria-hidden="true" tabindex="-1"></a>        color_layer.data[loop.index].color <span class="op">=</span> (<span class="op">*</span>colors[loop.vertex_index], <span class="fl">1.0</span>)  <span class="co"># RGBA</span></span>
<span id="cb1-516"><a href="#cb1-516" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-517"><a href="#cb1-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-518"><a href="#cb1-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-519"><a href="#cb1-519" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_vertex_color_material(<span class="bu">object</span>, material_name<span class="op">=</span><span class="st">"VertexColorMaterial"</span>):</span>
<span id="cb1-520"><a href="#cb1-520" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-521"><a href="#cb1-521" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a material for an object that uses vertex colors.</span></span>
<span id="cb1-522"><a href="#cb1-522" aria-hidden="true" tabindex="-1"></a><span class="co">    The R, G, and B channels are processed through separate "Map Range" nodes</span></span>
<span id="cb1-523"><a href="#cb1-523" aria-hidden="true" tabindex="-1"></a><span class="co">    to edit their brightness, and then combined into a Principled BSDF.</span></span>
<span id="cb1-524"><a href="#cb1-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-525"><a href="#cb1-525" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-526"><a href="#cb1-526" aria-hidden="true" tabindex="-1"></a><span class="co">        object (bpy.types.Object): The object to which the material will be applied.</span></span>
<span id="cb1-527"><a href="#cb1-527" aria-hidden="true" tabindex="-1"></a><span class="co">        material_name (str): Name of the new material.</span></span>
<span id="cb1-528"><a href="#cb1-528" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-529"><a href="#cb1-529" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure the object has a vertex color layer</span></span>
<span id="cb1-530"><a href="#cb1-530" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">object</span>.data.vertex_colors:</span>
<span id="cb1-531"><a href="#cb1-531" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"The object has no vertex color layers."</span>)</span>
<span id="cb1-532"><a href="#cb1-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-533"><a href="#cb1-533" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new material</span></span>
<span id="cb1-534"><a href="#cb1-534" aria-hidden="true" tabindex="-1"></a>    material <span class="op">=</span> bpy.data.materials.new(name<span class="op">=</span>material_name)</span>
<span id="cb1-535"><a href="#cb1-535" aria-hidden="true" tabindex="-1"></a>    material.use_nodes <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-536"><a href="#cb1-536" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> material.node_tree.nodes</span>
<span id="cb1-537"><a href="#cb1-537" aria-hidden="true" tabindex="-1"></a>    links <span class="op">=</span> material.node_tree.links</span>
<span id="cb1-538"><a href="#cb1-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-539"><a href="#cb1-539" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clear default nodes</span></span>
<span id="cb1-540"><a href="#cb1-540" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb1-541"><a href="#cb1-541" aria-hidden="true" tabindex="-1"></a>        nodes.remove(node)</span>
<span id="cb1-542"><a href="#cb1-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-543"><a href="#cb1-543" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add nodes</span></span>
<span id="cb1-544"><a href="#cb1-544" aria-hidden="true" tabindex="-1"></a>    vertex_color_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeVertexColor"</span>)</span>
<span id="cb1-545"><a href="#cb1-545" aria-hidden="true" tabindex="-1"></a>    vertex_color_node.layer_name <span class="op">=</span> <span class="bu">object</span>.data.vertex_colors[<span class="dv">0</span>].name</span>
<span id="cb1-546"><a href="#cb1-546" aria-hidden="true" tabindex="-1"></a>    vertex_color_node.location <span class="op">=</span> (<span class="op">-</span><span class="dv">1000</span>, <span class="dv">0</span>)</span>
<span id="cb1-547"><a href="#cb1-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-548"><a href="#cb1-548" aria-hidden="true" tabindex="-1"></a>    separate_color_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeSeparateRGB"</span>)</span>
<span id="cb1-549"><a href="#cb1-549" aria-hidden="true" tabindex="-1"></a>    separate_color_node.location <span class="op">=</span> (<span class="op">-</span><span class="dv">800</span>, <span class="dv">0</span>)</span>
<span id="cb1-550"><a href="#cb1-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-551"><a href="#cb1-551" aria-hidden="true" tabindex="-1"></a>    map_range_r <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeMapRange"</span>)</span>
<span id="cb1-552"><a href="#cb1-552" aria-hidden="true" tabindex="-1"></a>    map_range_r.label <span class="op">=</span> <span class="st">"Map Range R"</span></span>
<span id="cb1-553"><a href="#cb1-553" aria-hidden="true" tabindex="-1"></a>    map_range_r.location <span class="op">=</span> (<span class="op">-</span><span class="dv">600</span>, <span class="dv">300</span>)</span>
<span id="cb1-554"><a href="#cb1-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-555"><a href="#cb1-555" aria-hidden="true" tabindex="-1"></a>    map_range_g <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeMapRange"</span>)</span>
<span id="cb1-556"><a href="#cb1-556" aria-hidden="true" tabindex="-1"></a>    map_range_g.label <span class="op">=</span> <span class="st">"Map Range G"</span></span>
<span id="cb1-557"><a href="#cb1-557" aria-hidden="true" tabindex="-1"></a>    map_range_g.location <span class="op">=</span> (<span class="op">-</span><span class="dv">600</span>, <span class="dv">0</span>)</span>
<span id="cb1-558"><a href="#cb1-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-559"><a href="#cb1-559" aria-hidden="true" tabindex="-1"></a>    map_range_b <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeMapRange"</span>)</span>
<span id="cb1-560"><a href="#cb1-560" aria-hidden="true" tabindex="-1"></a>    map_range_b.label <span class="op">=</span> <span class="st">"Map Range B"</span></span>
<span id="cb1-561"><a href="#cb1-561" aria-hidden="true" tabindex="-1"></a>    map_range_b.location <span class="op">=</span> (<span class="op">-</span><span class="dv">600</span>, <span class="op">-</span><span class="dv">300</span>)</span>
<span id="cb1-562"><a href="#cb1-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-563"><a href="#cb1-563" aria-hidden="true" tabindex="-1"></a>    combine_rgb <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeCombineRGB"</span>)</span>
<span id="cb1-564"><a href="#cb1-564" aria-hidden="true" tabindex="-1"></a>    combine_rgb.location <span class="op">=</span> (<span class="op">-</span><span class="dv">200</span>, <span class="dv">0</span>)</span>
<span id="cb1-565"><a href="#cb1-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-566"><a href="#cb1-566" aria-hidden="true" tabindex="-1"></a>    bsdf_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeBsdfPrincipled"</span>)</span>
<span id="cb1-567"><a href="#cb1-567" aria-hidden="true" tabindex="-1"></a>    bsdf_node.location <span class="op">=</span> (<span class="dv">000</span>, <span class="dv">0</span>)</span>
<span id="cb1-568"><a href="#cb1-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-569"><a href="#cb1-569" aria-hidden="true" tabindex="-1"></a>    output_node <span class="op">=</span> nodes.new(<span class="bu">type</span><span class="op">=</span><span class="st">"ShaderNodeOutputMaterial"</span>)</span>
<span id="cb1-570"><a href="#cb1-570" aria-hidden="true" tabindex="-1"></a>    output_node.location <span class="op">=</span> (<span class="dv">400</span>, <span class="dv">0</span>)</span>
<span id="cb1-571"><a href="#cb1-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-572"><a href="#cb1-572" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Connect nodes</span></span>
<span id="cb1-573"><a href="#cb1-573" aria-hidden="true" tabindex="-1"></a>    links.new(vertex_color_node.outputs[<span class="st">"Color"</span>], separate_color_node.inputs[<span class="st">"Image"</span>])</span>
<span id="cb1-574"><a href="#cb1-574" aria-hidden="true" tabindex="-1"></a>    links.new(separate_color_node.outputs[<span class="st">"R"</span>], map_range_r.inputs[<span class="st">"Value"</span>])</span>
<span id="cb1-575"><a href="#cb1-575" aria-hidden="true" tabindex="-1"></a>    links.new(separate_color_node.outputs[<span class="st">"G"</span>], map_range_g.inputs[<span class="st">"Value"</span>])</span>
<span id="cb1-576"><a href="#cb1-576" aria-hidden="true" tabindex="-1"></a>    links.new(separate_color_node.outputs[<span class="st">"B"</span>], map_range_b.inputs[<span class="st">"Value"</span>])</span>
<span id="cb1-577"><a href="#cb1-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-578"><a href="#cb1-578" aria-hidden="true" tabindex="-1"></a>    links.new(map_range_r.outputs[<span class="st">"Result"</span>], combine_rgb.inputs[<span class="st">"R"</span>])</span>
<span id="cb1-579"><a href="#cb1-579" aria-hidden="true" tabindex="-1"></a>    links.new(map_range_g.outputs[<span class="st">"Result"</span>], combine_rgb.inputs[<span class="st">"G"</span>])</span>
<span id="cb1-580"><a href="#cb1-580" aria-hidden="true" tabindex="-1"></a>    links.new(map_range_b.outputs[<span class="st">"Result"</span>], combine_rgb.inputs[<span class="st">"B"</span>])</span>
<span id="cb1-581"><a href="#cb1-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-582"><a href="#cb1-582" aria-hidden="true" tabindex="-1"></a>    links.new(combine_rgb.outputs[<span class="st">"Image"</span>], bsdf_node.inputs[<span class="st">"Base Color"</span>])</span>
<span id="cb1-583"><a href="#cb1-583" aria-hidden="true" tabindex="-1"></a>    links.new(bsdf_node.outputs[<span class="st">"BSDF"</span>], output_node.inputs[<span class="st">"Surface"</span>])</span>
<span id="cb1-584"><a href="#cb1-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-585"><a href="#cb1-585" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set default map range values for each channel</span></span>
<span id="cb1-586"><a href="#cb1-586" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> map_range_node <span class="kw">in</span> [map_range_r, map_range_g, map_range_b]:</span>
<span id="cb1-587"><a href="#cb1-587" aria-hidden="true" tabindex="-1"></a>        map_range_node.inputs[<span class="st">"From Min"</span>].default_value <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-588"><a href="#cb1-588" aria-hidden="true" tabindex="-1"></a>        map_range_node.inputs[<span class="st">"From Max"</span>].default_value <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb1-589"><a href="#cb1-589" aria-hidden="true" tabindex="-1"></a>        map_range_node.inputs[<span class="st">"To Min"</span>].default_value <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-590"><a href="#cb1-590" aria-hidden="true" tabindex="-1"></a>        map_range_node.inputs[<span class="st">"To Max"</span>].default_value <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb1-591"><a href="#cb1-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-592"><a href="#cb1-592" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign the material to the object</span></span>
<span id="cb1-593"><a href="#cb1-593" aria-hidden="true" tabindex="-1"></a>    <span class="bu">object</span>.active_material <span class="op">=</span> material</span>
<span id="cb1-594"><a href="#cb1-594" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-595"><a href="#cb1-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-596"><a href="#cb1-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-597"><a href="#cb1-597" aria-hidden="true" tabindex="-1"></a><span class="co">### Marching cubes</span></span>
<span id="cb1-598"><a href="#cb1-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-599"><a href="#cb1-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-600"><a href="#cb1-600" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_mesh_from_numpy(name, verts, faces):</span>
<span id="cb1-601"><a href="#cb1-601" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-602"><a href="#cb1-602" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a Blender mesh object from NumPy arrays of vertices and faces.</span></span>
<span id="cb1-603"><a href="#cb1-603" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-604"><a href="#cb1-604" aria-hidden="true" tabindex="-1"></a><span class="co">    :param name: Name of the new mesh object.</span></span>
<span id="cb1-605"><a href="#cb1-605" aria-hidden="true" tabindex="-1"></a><span class="co">    :param verts: NumPy array of shape (n, 3) containing vertex coordinates.</span></span>
<span id="cb1-606"><a href="#cb1-606" aria-hidden="true" tabindex="-1"></a><span class="co">    :param faces: NumPy array of shape (m, 3 or 4) containing face indices.</span></span>
<span id="cb1-607"><a href="#cb1-607" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: The created mesh object.</span></span>
<span id="cb1-608"><a href="#cb1-608" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-609"><a href="#cb1-609" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> bpy.data.meshes.new(name)</span>
<span id="cb1-610"><a href="#cb1-610" aria-hidden="true" tabindex="-1"></a>    obj <span class="op">=</span> bpy.data.objects.new(name, mesh)</span>
<span id="cb1-611"><a href="#cb1-611" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Link the object to the scene</span></span>
<span id="cb1-612"><a href="#cb1-612" aria-hidden="true" tabindex="-1"></a>    bpy.context.collection.objects.link(obj)</span>
<span id="cb1-613"><a href="#cb1-613" aria-hidden="true" tabindex="-1"></a>    mesh.from_pydata(verts.tolist(), [], faces.tolist())</span>
<span id="cb1-614"><a href="#cb1-614" aria-hidden="true" tabindex="-1"></a>    mesh.update()</span>
<span id="cb1-615"><a href="#cb1-615" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> obj</span>
<span id="cb1-616"><a href="#cb1-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-617"><a href="#cb1-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-618"><a href="#cb1-618" aria-hidden="true" tabindex="-1"></a><span class="co">### Iterative closest point alignment</span></span>
<span id="cb1-619"><a href="#cb1-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-620"><a href="#cb1-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-621"><a href="#cb1-621" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> package_affine_transformation(matrix, vector):</span>
<span id="cb1-622"><a href="#cb1-622" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Package matrix transformation &amp; translation into (d+1,d+1) matrix representation of affine transformation."""</span></span>
<span id="cb1-623"><a href="#cb1-623" aria-hidden="true" tabindex="-1"></a>    matrix_rep <span class="op">=</span> np.hstack([matrix, vector[:, np.newaxis]])</span>
<span id="cb1-624"><a href="#cb1-624" aria-hidden="true" tabindex="-1"></a>    matrix_rep <span class="op">=</span> np.pad(matrix_rep, ((<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">0</span>)), constant_values<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-625"><a href="#cb1-625" aria-hidden="true" tabindex="-1"></a>    matrix_rep[<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-626"><a href="#cb1-626" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix_rep</span>
<span id="cb1-627"><a href="#cb1-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-628"><a href="#cb1-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-629"><a href="#cb1-629" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_inertia(pts):</span>
<span id="cb1-630"><a href="#cb1-630" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Get inertia tensor of 3d point cloud."""</span></span>
<span id="cb1-631"><a href="#cb1-631" aria-hidden="true" tabindex="-1"></a>    pts_nomean <span class="op">=</span> pts <span class="op">-</span> np.mean(pts, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-632"><a href="#cb1-632" aria-hidden="true" tabindex="-1"></a>    x, y, z <span class="op">=</span> pts_nomean.T</span>
<span id="cb1-633"><a href="#cb1-633" aria-hidden="true" tabindex="-1"></a>    Ixx <span class="op">=</span> np.mean(x<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-634"><a href="#cb1-634" aria-hidden="true" tabindex="-1"></a>    Ixy <span class="op">=</span> np.mean(x<span class="op">*</span>y)</span>
<span id="cb1-635"><a href="#cb1-635" aria-hidden="true" tabindex="-1"></a>    Ixz <span class="op">=</span> np.mean(x<span class="op">*</span>z)</span>
<span id="cb1-636"><a href="#cb1-636" aria-hidden="true" tabindex="-1"></a>    Iyy <span class="op">=</span> np.mean(y<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-637"><a href="#cb1-637" aria-hidden="true" tabindex="-1"></a>    Iyz <span class="op">=</span> np.mean(y<span class="op">*</span>z)</span>
<span id="cb1-638"><a href="#cb1-638" aria-hidden="true" tabindex="-1"></a>    Izz <span class="op">=</span> np.mean(z<span class="op">*</span>z)</span>
<span id="cb1-639"><a href="#cb1-639" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([[Ixx, Ixy, Ixz], [Ixy,Iyy, Iyz], [Ixz, Iyz, Izz]])</span>
<span id="cb1-640"><a href="#cb1-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-641"><a href="#cb1-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-642"><a href="#cb1-642" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> align_by_centroid_and_intertia(source, target, scale<span class="op">=</span><span class="va">True</span>, shear<span class="op">=</span><span class="va">True</span>, improper<span class="op">=</span><span class="va">False</span>, n_samples<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb1-643"><a href="#cb1-643" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-644"><a href="#cb1-644" aria-hidden="true" tabindex="-1"></a><span class="co">    Align source point cloud to target point cloud using affine transformation.</span></span>
<span id="cb1-645"><a href="#cb1-645" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-646"><a href="#cb1-646" aria-hidden="true" tabindex="-1"></a><span class="co">    Align by matching centroids and axes of inertia tensor. Since the inertia tensor is invariant</span></span>
<span id="cb1-647"><a href="#cb1-647" aria-hidden="true" tabindex="-1"></a><span class="co">    under reflections along its principal axes, all 2^3 reflections are tried and the one leading</span></span>
<span id="cb1-648"><a href="#cb1-648" aria-hidden="true" tabindex="-1"></a><span class="co">    to the best agreement with the target is chosen.</span></span>
<span id="cb1-649"><a href="#cb1-649" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-650"><a href="#cb1-650" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-651"><a href="#cb1-651" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-652"><a href="#cb1-652" aria-hidden="true" tabindex="-1"></a><span class="co">    source : np.array of shape (n_source, 3)</span></span>
<span id="cb1-653"><a href="#cb1-653" aria-hidden="true" tabindex="-1"></a><span class="co">        Point cloud to be aligned.</span></span>
<span id="cb1-654"><a href="#cb1-654" aria-hidden="true" tabindex="-1"></a><span class="co">    target : np.array of shape (n_target, 3)</span></span>
<span id="cb1-655"><a href="#cb1-655" aria-hidden="true" tabindex="-1"></a><span class="co">        Point cloud to align to.</span></span>
<span id="cb1-656"><a href="#cb1-656" aria-hidden="true" tabindex="-1"></a><span class="co">    scale : bool, default True</span></span>
<span id="cb1-657"><a href="#cb1-657" aria-hidden="true" tabindex="-1"></a><span class="co">        Whether to allow scale transformation (True) or rotations only (False)</span></span>
<span id="cb1-658"><a href="#cb1-658" aria-hidden="true" tabindex="-1"></a><span class="co">    shear : bool, default False</span></span>
<span id="cb1-659"><a href="#cb1-659" aria-hidden="true" tabindex="-1"></a><span class="co">        Whether to allow shear transformation (True) or rotations/scale only (False)</span></span>
<span id="cb1-660"><a href="#cb1-660" aria-hidden="true" tabindex="-1"></a><span class="co">    improper : bool, default False</span></span>
<span id="cb1-661"><a href="#cb1-661" aria-hidden="true" tabindex="-1"></a><span class="co">        Whether to allow transfomations with determinant -1</span></span>
<span id="cb1-662"><a href="#cb1-662" aria-hidden="true" tabindex="-1"></a><span class="co">    n_samples : int, optional</span></span>
<span id="cb1-663"><a href="#cb1-663" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of samples of source to use when estimating distances.</span></span>
<span id="cb1-664"><a href="#cb1-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-665"><a href="#cb1-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-666"><a href="#cb1-666" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-667"><a href="#cb1-667" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-668"><a href="#cb1-668" aria-hidden="true" tabindex="-1"></a><span class="co">    np.array, np.array</span></span>
<span id="cb1-669"><a href="#cb1-669" aria-hidden="true" tabindex="-1"></a><span class="co">        affine_matrix_rep : np.array of shape (4, 4)</span></span>
<span id="cb1-670"><a href="#cb1-670" aria-hidden="true" tabindex="-1"></a><span class="co">            Affine transformation source -&gt; target</span></span>
<span id="cb1-671"><a href="#cb1-671" aria-hidden="true" tabindex="-1"></a><span class="co">        aligned : np.array of shape (n_source, 3)</span></span>
<span id="cb1-672"><a href="#cb1-672" aria-hidden="true" tabindex="-1"></a><span class="co">            Aligned coordinates</span></span>
<span id="cb1-673"><a href="#cb1-673" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-674"><a href="#cb1-674" aria-hidden="true" tabindex="-1"></a>    target_centroid <span class="op">=</span> np.mean(target, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-675"><a href="#cb1-675" aria-hidden="true" tabindex="-1"></a>    target_inertia <span class="op">=</span> get_inertia(target)</span>
<span id="cb1-676"><a href="#cb1-676" aria-hidden="true" tabindex="-1"></a>    target_eig <span class="op">=</span> np.linalg.eigh(target_inertia)</span>
<span id="cb1-677"><a href="#cb1-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-678"><a href="#cb1-678" aria-hidden="true" tabindex="-1"></a>    source_centroid <span class="op">=</span> np.mean(source, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-679"><a href="#cb1-679" aria-hidden="true" tabindex="-1"></a>    source_inertia <span class="op">=</span> get_inertia(source)</span>
<span id="cb1-680"><a href="#cb1-680" aria-hidden="true" tabindex="-1"></a>    source_eig <span class="op">=</span> np.linalg.eigh(source_inertia)</span>
<span id="cb1-681"><a href="#cb1-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-682"><a href="#cb1-682" aria-hidden="true" tabindex="-1"></a>    flips <span class="op">=</span> [np.diag([i,j,k]) <span class="cf">for</span> i, j, k <span class="kw">in</span> itertools.product(<span class="op">*</span>(<span class="dv">3</span><span class="op">*</span>[[<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>]]))]</span>
<span id="cb1-683"><a href="#cb1-683" aria-hidden="true" tabindex="-1"></a>    trafo_matrix_candidates <span class="op">=</span> []</span>
<span id="cb1-684"><a href="#cb1-684" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> spatial.cKDTree(target)</span>
<span id="cb1-685"><a href="#cb1-685" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> source[np.random.randint(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span>source.shape[<span class="dv">0</span>], size<span class="op">=</span><span class="bu">min</span>([n_samples, source.shape[<span class="dv">0</span>]])),:]</span>
<span id="cb1-686"><a href="#cb1-686" aria-hidden="true" tabindex="-1"></a>    distances <span class="op">=</span> []</span>
<span id="cb1-687"><a href="#cb1-687" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> flip <span class="kw">in</span> flips:</span>
<span id="cb1-688"><a href="#cb1-688" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> shear:</span>
<span id="cb1-689"><a href="#cb1-689" aria-hidden="true" tabindex="-1"></a>            trafo_matrix <span class="op">=</span> (source_eig.eigenvectors</span>
<span id="cb1-690"><a href="#cb1-690" aria-hidden="true" tabindex="-1"></a>                            <span class="op">@</span> np.diag(np.sqrt(target_eig.eigenvalues<span class="op">/</span>source_eig.eigenvalues))</span>
<span id="cb1-691"><a href="#cb1-691" aria-hidden="true" tabindex="-1"></a>                            <span class="op">@</span> flip <span class="op">@</span> target_eig.eigenvectors.T)</span>
<span id="cb1-692"><a href="#cb1-692" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> scale <span class="kw">and</span> <span class="kw">not</span> shear:</span>
<span id="cb1-693"><a href="#cb1-693" aria-hidden="true" tabindex="-1"></a>            scale_fact <span class="op">=</span> np.sqrt(stats.gmean(target_eig.eigenvalues)<span class="op">/</span>stats.gmean(source_eig.eigenvalues))</span>
<span id="cb1-694"><a href="#cb1-694" aria-hidden="true" tabindex="-1"></a>            trafo_matrix <span class="op">=</span> scale_fact<span class="op">*</span>source_eig.eigenvectors<span class="op">@</span>flip<span class="op">@</span>target_eig.eigenvectors.T</span>
<span id="cb1-695"><a href="#cb1-695" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="kw">not</span> scale <span class="kw">and</span> <span class="kw">not</span> shear:</span>
<span id="cb1-696"><a href="#cb1-696" aria-hidden="true" tabindex="-1"></a>            trafo_matrix <span class="op">=</span> source_eig.eigenvectors<span class="op">@</span>flip<span class="op">@</span>target_eig.eigenvectors.T</span>
<span id="cb1-697"><a href="#cb1-697" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> improper <span class="kw">and</span> np.linalg.det(trafo_matrix) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb1-698"><a href="#cb1-698" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb1-699"><a href="#cb1-699" aria-hidden="true" tabindex="-1"></a>        trafo_matrix <span class="op">=</span> trafo_matrix.T</span>
<span id="cb1-700"><a href="#cb1-700" aria-hidden="true" tabindex="-1"></a>        trafo_matrix_candidates.append(trafo_matrix)</span>
<span id="cb1-701"><a href="#cb1-701" aria-hidden="true" tabindex="-1"></a>        trafo_translate <span class="op">=</span> target_centroid <span class="op">-</span> trafo_matrix<span class="op">@</span>source_centroid</span>
<span id="cb1-702"><a href="#cb1-702" aria-hidden="true" tabindex="-1"></a>        aligned <span class="op">=</span> samples<span class="op">@</span>trafo_matrix.T <span class="op">+</span> trafo_translate</span>
<span id="cb1-703"><a href="#cb1-703" aria-hidden="true" tabindex="-1"></a>        distances.append(np.mean(tree.query(aligned)[<span class="dv">0</span>]))</span>
<span id="cb1-704"><a href="#cb1-704" aria-hidden="true" tabindex="-1"></a>    trafo_matrix <span class="op">=</span> trafo_matrix_candidates[np.argmin(distances)]</span>
<span id="cb1-705"><a href="#cb1-705" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'inferred rotation/scale'</span>, trafo_matrix)</span>
<span id="cb1-706"><a href="#cb1-706" aria-hidden="true" tabindex="-1"></a>    trafo_translate <span class="op">=</span> target_centroid <span class="op">-</span> trafo_matrix<span class="op">@</span>source_centroid</span>
<span id="cb1-707"><a href="#cb1-707" aria-hidden="true" tabindex="-1"></a>    aligned <span class="op">=</span> source<span class="op">@</span>trafo_matrix.T <span class="op">+</span> trafo_translate</span>
<span id="cb1-708"><a href="#cb1-708" aria-hidden="true" tabindex="-1"></a>    affine_matrix_rep <span class="op">=</span> package_affine_transformation(trafo_matrix, trafo_translate)</span>
<span id="cb1-709"><a href="#cb1-709" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-710"><a href="#cb1-710" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'inferred translation'</span>, trafo_translate)</span>
<span id="cb1-711"><a href="#cb1-711" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> affine_matrix_rep, aligned</span>
<span id="cb1-712"><a href="#cb1-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-713"><a href="#cb1-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-714"><a href="#cb1-714" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> procrustes(source, target, scale<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb1-715"><a href="#cb1-715" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-716"><a href="#cb1-716" aria-hidden="true" tabindex="-1"></a><span class="co">    Procrustes analysis, a similarity test for two data sets.</span></span>
<span id="cb1-717"><a href="#cb1-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-718"><a href="#cb1-718" aria-hidden="true" tabindex="-1"></a><span class="co">    Copied from scipy.spatial.procrustes, modified to return the transform</span></span>
<span id="cb1-719"><a href="#cb1-719" aria-hidden="true" tabindex="-1"></a><span class="co">    as an affine matrix, and return the transformed source data in the original,</span></span>
<span id="cb1-720"><a href="#cb1-720" aria-hidden="true" tabindex="-1"></a><span class="co">    non-normalized coordinates.</span></span>
<span id="cb1-721"><a href="#cb1-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-722"><a href="#cb1-722" aria-hidden="true" tabindex="-1"></a><span class="co">    Each input matrix is a set of points or vectors (the rows of the matrix).</span></span>
<span id="cb1-723"><a href="#cb1-723" aria-hidden="true" tabindex="-1"></a><span class="co">    The dimension of the space is the number of columns of each matrix. Given</span></span>
<span id="cb1-724"><a href="#cb1-724" aria-hidden="true" tabindex="-1"></a><span class="co">    two identically sized matrices, procrustes standardizes both such that:</span></span>
<span id="cb1-725"><a href="#cb1-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-726"><a href="#cb1-726" aria-hidden="true" tabindex="-1"></a><span class="co">    - tr(AA^T) = 1.</span></span>
<span id="cb1-727"><a href="#cb1-727" aria-hidden="true" tabindex="-1"></a><span class="co">    - Both sets of points are centered around the origin.</span></span>
<span id="cb1-728"><a href="#cb1-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-729"><a href="#cb1-729" aria-hidden="true" tabindex="-1"></a><span class="co">    Procrustes then applies the optimal transform to the source matrix</span></span>
<span id="cb1-730"><a href="#cb1-730" aria-hidden="true" tabindex="-1"></a><span class="co">    (including scaling/dilation, rotations, and reflections) to minimize the</span></span>
<span id="cb1-731"><a href="#cb1-731" aria-hidden="true" tabindex="-1"></a><span class="co">    sum of the squares of the pointwise differences between the two input datasets.</span></span>
<span id="cb1-732"><a href="#cb1-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-733"><a href="#cb1-733" aria-hidden="true" tabindex="-1"></a><span class="co">    This function is not designed to handle datasets with different numbers of</span></span>
<span id="cb1-734"><a href="#cb1-734" aria-hidden="true" tabindex="-1"></a><span class="co">    datapoints (rows).  If two data sets have different dimensionality</span></span>
<span id="cb1-735"><a href="#cb1-735" aria-hidden="true" tabindex="-1"></a><span class="co">    (different number of columns), simply add columns of zeros to the smaller</span></span>
<span id="cb1-736"><a href="#cb1-736" aria-hidden="true" tabindex="-1"></a><span class="co">    of the two.</span></span>
<span id="cb1-737"><a href="#cb1-737" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-738"><a href="#cb1-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-739"><a href="#cb1-739" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-740"><a href="#cb1-740" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-741"><a href="#cb1-741" aria-hidden="true" tabindex="-1"></a><span class="co">    source : array_like</span></span>
<span id="cb1-742"><a href="#cb1-742" aria-hidden="true" tabindex="-1"></a><span class="co">        Matrix, n rows represent points in k (columns) space. The data from</span></span>
<span id="cb1-743"><a href="#cb1-743" aria-hidden="true" tabindex="-1"></a><span class="co">        source will be transformed to fit the pattern in target.</span></span>
<span id="cb1-744"><a href="#cb1-744" aria-hidden="true" tabindex="-1"></a><span class="co">    target : array_like</span></span>
<span id="cb1-745"><a href="#cb1-745" aria-hidden="true" tabindex="-1"></a><span class="co">        Maxtrix, n rows represent points in k (columns) space. </span></span>
<span id="cb1-746"><a href="#cb1-746" aria-hidden="true" tabindex="-1"></a><span class="co">        target is the reference data. </span></span>
<span id="cb1-747"><a href="#cb1-747" aria-hidden="true" tabindex="-1"></a><span class="co">    scale : bool, default True</span></span>
<span id="cb1-748"><a href="#cb1-748" aria-hidden="true" tabindex="-1"></a><span class="co">        Whether to allow scaling transformations</span></span>
<span id="cb1-749"><a href="#cb1-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-750"><a href="#cb1-750" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-751"><a href="#cb1-751" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-752"><a href="#cb1-752" aria-hidden="true" tabindex="-1"></a><span class="co">    trafo_affine : array_like</span></span>
<span id="cb1-753"><a href="#cb1-753" aria-hidden="true" tabindex="-1"></a><span class="co">        (4,4) array representing the affine transformation from source to target.</span></span>
<span id="cb1-754"><a href="#cb1-754" aria-hidden="true" tabindex="-1"></a><span class="co">    aligned : array_like</span></span>
<span id="cb1-755"><a href="#cb1-755" aria-hidden="true" tabindex="-1"></a><span class="co">        The orientation of source that best fits target.</span></span>
<span id="cb1-756"><a href="#cb1-756" aria-hidden="true" tabindex="-1"></a><span class="co">    disparity : float</span></span>
<span id="cb1-757"><a href="#cb1-757" aria-hidden="true" tabindex="-1"></a><span class="co">        np.linalg.norm(aligned-target, axis=1).mean()</span></span>
<span id="cb1-758"><a href="#cb1-758" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-759"><a href="#cb1-759" aria-hidden="true" tabindex="-1"></a>    mtx1 <span class="op">=</span> np.array(target, dtype<span class="op">=</span>np.float64, copy<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-760"><a href="#cb1-760" aria-hidden="true" tabindex="-1"></a>    mtx2 <span class="op">=</span> np.array(source, dtype<span class="op">=</span>np.float64, copy<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-761"><a href="#cb1-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-762"><a href="#cb1-762" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mtx1.ndim <span class="op">!=</span> <span class="dv">2</span> <span class="kw">or</span> mtx2.ndim <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb1-763"><a href="#cb1-763" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input matrices must be two-dimensional"</span>)</span>
<span id="cb1-764"><a href="#cb1-764" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mtx1.shape <span class="op">!=</span> mtx2.shape:</span>
<span id="cb1-765"><a href="#cb1-765" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input matrices must be of same shape"</span>)</span>
<span id="cb1-766"><a href="#cb1-766" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mtx1.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-767"><a href="#cb1-767" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input matrices must be &gt;0 rows and &gt;0 cols"</span>)</span>
<span id="cb1-768"><a href="#cb1-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-769"><a href="#cb1-769" aria-hidden="true" tabindex="-1"></a>    <span class="co"># translate all the data to the origin</span></span>
<span id="cb1-770"><a href="#cb1-770" aria-hidden="true" tabindex="-1"></a>    centroid1, centroid2 <span class="op">=</span> (np.mean(mtx1, <span class="dv">0</span>), np.mean(mtx2, <span class="dv">0</span>))</span>
<span id="cb1-771"><a href="#cb1-771" aria-hidden="true" tabindex="-1"></a>    mtx1 <span class="op">-=</span> centroid1</span>
<span id="cb1-772"><a href="#cb1-772" aria-hidden="true" tabindex="-1"></a>    mtx2 <span class="op">-=</span> centroid2</span>
<span id="cb1-773"><a href="#cb1-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-774"><a href="#cb1-774" aria-hidden="true" tabindex="-1"></a>    <span class="co"># change scaling of data (in rows) such that trace(mtx*mtx') = 1</span></span>
<span id="cb1-775"><a href="#cb1-775" aria-hidden="true" tabindex="-1"></a>    norm1 <span class="op">=</span> np.linalg.norm(mtx1)</span>
<span id="cb1-776"><a href="#cb1-776" aria-hidden="true" tabindex="-1"></a>    norm2 <span class="op">=</span> np.linalg.norm(mtx2)</span>
<span id="cb1-777"><a href="#cb1-777" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> norm1 <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> norm2 <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-778"><a href="#cb1-778" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input matrices must contain &gt;1 unique points"</span>)</span>
<span id="cb1-779"><a href="#cb1-779" aria-hidden="true" tabindex="-1"></a>    mtx1 <span class="op">/=</span> norm1</span>
<span id="cb1-780"><a href="#cb1-780" aria-hidden="true" tabindex="-1"></a>    mtx2 <span class="op">/=</span> norm2</span>
<span id="cb1-781"><a href="#cb1-781" aria-hidden="true" tabindex="-1"></a>    <span class="co"># transform mtx2 to minimize disparity</span></span>
<span id="cb1-782"><a href="#cb1-782" aria-hidden="true" tabindex="-1"></a>    R, s <span class="op">=</span> linalg.orthogonal_procrustes(mtx1, mtx2)</span>
<span id="cb1-783"><a href="#cb1-783" aria-hidden="true" tabindex="-1"></a>    mtx2 <span class="op">=</span> np.dot(mtx2, R.T) <span class="op">*</span> s</span>
<span id="cb1-784"><a href="#cb1-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-785"><a href="#cb1-785" aria-hidden="true" tabindex="-1"></a>    <span class="co"># retranslate and scale</span></span>
<span id="cb1-786"><a href="#cb1-786" aria-hidden="true" tabindex="-1"></a>    aligned <span class="op">=</span> norm1 <span class="op">*</span> mtx2 <span class="op">+</span> centroid1</span>
<span id="cb1-787"><a href="#cb1-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-788"><a href="#cb1-788" aria-hidden="true" tabindex="-1"></a>    <span class="co"># measure the dissimilarity between the two datasets</span></span>
<span id="cb1-789"><a href="#cb1-789" aria-hidden="true" tabindex="-1"></a>    disparity <span class="op">=</span> np.mean(np.linalg.norm(aligned<span class="op">-</span>target, axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb1-790"><a href="#cb1-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-791"><a href="#cb1-791" aria-hidden="true" tabindex="-1"></a>    <span class="co"># assemble the linear transformation</span></span>
<span id="cb1-792"><a href="#cb1-792" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> scale:</span>
<span id="cb1-793"><a href="#cb1-793" aria-hidden="true" tabindex="-1"></a>        trafo_matrix <span class="op">=</span> (norm1<span class="op">/</span>norm2)<span class="op">*</span>s<span class="op">*</span>R</span>
<span id="cb1-794"><a href="#cb1-794" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-795"><a href="#cb1-795" aria-hidden="true" tabindex="-1"></a>        trafo_matrix <span class="op">=</span> (norm1<span class="op">/</span>norm2)<span class="op">*</span>R</span>
<span id="cb1-796"><a href="#cb1-796" aria-hidden="true" tabindex="-1"></a>    trafo_translate <span class="op">=</span> centroid1 <span class="op">-</span> trafo_matrix<span class="op">@</span>centroid2</span>
<span id="cb1-797"><a href="#cb1-797" aria-hidden="true" tabindex="-1"></a>    trafo_affine <span class="op">=</span> package_affine_transformation(trafo_matrix, trafo_translate)</span>
<span id="cb1-798"><a href="#cb1-798" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trafo_affine, aligned, disparity</span>
<span id="cb1-799"><a href="#cb1-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-800"><a href="#cb1-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-801"><a href="#cb1-801" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> icp(source, target, initial<span class="op">=</span><span class="va">None</span>, threshold<span class="op">=</span><span class="fl">1e-4</span>, max_iterations<span class="op">=</span><span class="dv">20</span>, scale<span class="op">=</span><span class="va">True</span>, n_samples<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb1-802"><a href="#cb1-802" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-803"><a href="#cb1-803" aria-hidden="true" tabindex="-1"></a><span class="co">    Apply the iterative closest point algorithm to align point cloud a with</span></span>
<span id="cb1-804"><a href="#cb1-804" aria-hidden="true" tabindex="-1"></a><span class="co">    point cloud b. Will only produce reasonable results if the</span></span>
<span id="cb1-805"><a href="#cb1-805" aria-hidden="true" tabindex="-1"></a><span class="co">    initial transformation is roughly correct. Initial transformation can be</span></span>
<span id="cb1-806"><a href="#cb1-806" aria-hidden="true" tabindex="-1"></a><span class="co">    found by applying Procrustes' analysis to a suitable set of landmark</span></span>
<span id="cb1-807"><a href="#cb1-807" aria-hidden="true" tabindex="-1"></a><span class="co">    points (often picked manually), or by inertia+centroid based alignment,</span></span>
<span id="cb1-808"><a href="#cb1-808" aria-hidden="true" tabindex="-1"></a><span class="co">    implemented in align_by_centroid_and_intertia.</span></span>
<span id="cb1-809"><a href="#cb1-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-810"><a href="#cb1-810" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-811"><a href="#cb1-811" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-812"><a href="#cb1-812" aria-hidden="true" tabindex="-1"></a><span class="co">    source : (n,3) float</span></span>
<span id="cb1-813"><a href="#cb1-813" aria-hidden="true" tabindex="-1"></a><span class="co">      Source points in space.</span></span>
<span id="cb1-814"><a href="#cb1-814" aria-hidden="true" tabindex="-1"></a><span class="co">    target : (m,3) float or Trimesh</span></span>
<span id="cb1-815"><a href="#cb1-815" aria-hidden="true" tabindex="-1"></a><span class="co">      Target points in space or mesh.</span></span>
<span id="cb1-816"><a href="#cb1-816" aria-hidden="true" tabindex="-1"></a><span class="co">    initial : (4,4) float</span></span>
<span id="cb1-817"><a href="#cb1-817" aria-hidden="true" tabindex="-1"></a><span class="co">      Initial transformation.</span></span>
<span id="cb1-818"><a href="#cb1-818" aria-hidden="true" tabindex="-1"></a><span class="co">    threshold : float</span></span>
<span id="cb1-819"><a href="#cb1-819" aria-hidden="true" tabindex="-1"></a><span class="co">      Stop when change in cost is less than threshold</span></span>
<span id="cb1-820"><a href="#cb1-820" aria-hidden="true" tabindex="-1"></a><span class="co">    max_iterations : int</span></span>
<span id="cb1-821"><a href="#cb1-821" aria-hidden="true" tabindex="-1"></a><span class="co">      Maximum number of iterations</span></span>
<span id="cb1-822"><a href="#cb1-822" aria-hidden="true" tabindex="-1"></a><span class="co">    scale : bool, optional</span></span>
<span id="cb1-823"><a href="#cb1-823" aria-hidden="true" tabindex="-1"></a><span class="co">      Whether to allow dilations. If False, orthogonal procrustes is used</span></span>
<span id="cb1-824"><a href="#cb1-824" aria-hidden="true" tabindex="-1"></a><span class="co">    n_samples : int or None</span></span>
<span id="cb1-825"><a href="#cb1-825" aria-hidden="true" tabindex="-1"></a><span class="co">        If not None, n_samples sample points are randomly chosen from source array for distance computation</span></span>
<span id="cb1-826"><a href="#cb1-826" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-827"><a href="#cb1-827" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-828"><a href="#cb1-828" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-829"><a href="#cb1-829" aria-hidden="true" tabindex="-1"></a><span class="co">    matrix : (4,4) float</span></span>
<span id="cb1-830"><a href="#cb1-830" aria-hidden="true" tabindex="-1"></a><span class="co">      The transformation matrix sending a to b</span></span>
<span id="cb1-831"><a href="#cb1-831" aria-hidden="true" tabindex="-1"></a><span class="co">    transformed : (n,3) float</span></span>
<span id="cb1-832"><a href="#cb1-832" aria-hidden="true" tabindex="-1"></a><span class="co">      The image of a under the transformation</span></span>
<span id="cb1-833"><a href="#cb1-833" aria-hidden="true" tabindex="-1"></a><span class="co">    cost : float</span></span>
<span id="cb1-834"><a href="#cb1-834" aria-hidden="true" tabindex="-1"></a><span class="co">      The cost of the transformation</span></span>
<span id="cb1-835"><a href="#cb1-835" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-836"><a href="#cb1-836" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize transform matrix</span></span>
<span id="cb1-837"><a href="#cb1-837" aria-hidden="true" tabindex="-1"></a>    total_matrix <span class="op">=</span> np.eye(<span class="dv">4</span>) <span class="cf">if</span> initial <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> initial</span>
<span id="cb1-838"><a href="#cb1-838" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> spatial.cKDTree(target)</span>
<span id="cb1-839"><a href="#cb1-839" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subsample and apply initial transformation</span></span>
<span id="cb1-840"><a href="#cb1-840" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> (source[np.random.randint(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span>source.shape[<span class="dv">0</span>],</span>
<span id="cb1-841"><a href="#cb1-841" aria-hidden="true" tabindex="-1"></a>                                        size<span class="op">=</span><span class="bu">min</span>([n_samples, source.shape[<span class="dv">0</span>]])),:]</span>
<span id="cb1-842"><a href="#cb1-842" aria-hidden="true" tabindex="-1"></a>               <span class="cf">if</span> n_samples <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> source[:])</span>
<span id="cb1-843"><a href="#cb1-843" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> samples<span class="op">@</span>total_matrix[:<span class="dv">3</span>,:<span class="dv">3</span>].T <span class="op">+</span> total_matrix[:<span class="dv">3</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-844"><a href="#cb1-844" aria-hidden="true" tabindex="-1"></a>    <span class="co"># start with infinite cost</span></span>
<span id="cb1-845"><a href="#cb1-845" aria-hidden="true" tabindex="-1"></a>    old_cost <span class="op">=</span> np.inf</span>
<span id="cb1-846"><a href="#cb1-846" aria-hidden="true" tabindex="-1"></a>    <span class="co"># avoid looping forever by capping iterations</span></span>
<span id="cb1-847"><a href="#cb1-847" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(max_iterations):</span>
<span id="cb1-848"><a href="#cb1-848" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'iteration'</span>, i, <span class="st">'cost'</span>, old_cost) </span>
<span id="cb1-849"><a href="#cb1-849" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find closest point in target to each point in sample and align</span></span>
<span id="cb1-850"><a href="#cb1-850" aria-hidden="true" tabindex="-1"></a>        closest <span class="op">=</span> target[tree.query(samples, <span class="dv">1</span>)[<span class="dv">1</span>]]</span>
<span id="cb1-851"><a href="#cb1-851" aria-hidden="true" tabindex="-1"></a>        matrix, samples, cost <span class="op">=</span> procrustes(samples, closest, scale<span class="op">=</span>scale)</span>
<span id="cb1-852"><a href="#cb1-852" aria-hidden="true" tabindex="-1"></a>        <span class="co"># update a with our new transformed points</span></span>
<span id="cb1-853"><a href="#cb1-853" aria-hidden="true" tabindex="-1"></a>        total_matrix <span class="op">=</span> np.dot(matrix, total_matrix)</span>
<span id="cb1-854"><a href="#cb1-854" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> old_cost <span class="op">-</span> cost <span class="op">&lt;</span> threshold:</span>
<span id="cb1-855"><a href="#cb1-855" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb1-856"><a href="#cb1-856" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-857"><a href="#cb1-857" aria-hidden="true" tabindex="-1"></a>            old_cost <span class="op">=</span> cost</span>
<span id="cb1-858"><a href="#cb1-858" aria-hidden="true" tabindex="-1"></a>    aligned <span class="op">=</span> source<span class="op">@</span>total_matrix[:<span class="dv">3</span>,:<span class="dv">3</span>].T <span class="op">+</span> total_matrix[:<span class="dv">3</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-859"><a href="#cb1-859" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_matrix, aligned, cost</span>
<span id="cb1-860"><a href="#cb1-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-861"><a href="#cb1-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-862"><a href="#cb1-862" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combined_alignment(source, target, pre_align<span class="op">=</span><span class="va">True</span>, shear<span class="op">=</span><span class="va">False</span>, iterations<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb1-863"><a href="#cb1-863" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Align source to target by combination of moment-of-intertia based aligment + ICP"""</span></span>
<span id="cb1-864"><a href="#cb1-864" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pre_align:</span>
<span id="cb1-865"><a href="#cb1-865" aria-hidden="true" tabindex="-1"></a>        trafo_initial, _ <span class="op">=</span> align_by_centroid_and_intertia(source, target,</span>
<span id="cb1-866"><a href="#cb1-866" aria-hidden="true" tabindex="-1"></a>                                                          scale<span class="op">=</span><span class="va">True</span>, shear<span class="op">=</span>shear, improper<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-867"><a href="#cb1-867" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-868"><a href="#cb1-868" aria-hidden="true" tabindex="-1"></a>        trafo_initial <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-869"><a href="#cb1-869" aria-hidden="true" tabindex="-1"></a>    trafo_icp, _, _ <span class="op">=</span> icp(source, target, initial<span class="op">=</span>trafo_initial,</span>
<span id="cb1-870"><a href="#cb1-870" aria-hidden="true" tabindex="-1"></a>                          threshold<span class="op">=</span><span class="fl">1e-4</span>, max_iterations<span class="op">=</span>iterations,</span>
<span id="cb1-871"><a href="#cb1-871" aria-hidden="true" tabindex="-1"></a>                          scale<span class="op">=</span><span class="va">True</span>, n_samples<span class="op">=</span><span class="dv">5000</span>)</span>
<span id="cb1-872"><a href="#cb1-872" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trafo_icp</span>
<span id="cb1-873"><a href="#cb1-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-874"><a href="#cb1-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-875"><a href="#cb1-875" aria-hidden="true" tabindex="-1"></a><span class="co">### Shrink-wrapping</span></span>
<span id="cb1-876"><a href="#cb1-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-877"><a href="#cb1-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-878"><a href="#cb1-878" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shrinkwrap_and_smooth(source_obj, target_obj, corrective_smooth_iter<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb1-879"><a href="#cb1-879" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-880"><a href="#cb1-880" aria-hidden="true" tabindex="-1"></a><span class="co">    Applies a shrinkwrap modifier with target_obj to source_obj, </span></span>
<span id="cb1-881"><a href="#cb1-881" aria-hidden="true" tabindex="-1"></a><span class="co">    optionally adds a corrective smooth modifier, and applies all modifiers.</span></span>
<span id="cb1-882"><a href="#cb1-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-883"><a href="#cb1-883" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-884"><a href="#cb1-884" aria-hidden="true" tabindex="-1"></a><span class="co">    - source_obj: The source mesh object to be modified.</span></span>
<span id="cb1-885"><a href="#cb1-885" aria-hidden="true" tabindex="-1"></a><span class="co">    - target_obj: The target mesh object for the shrinkwrap modifier.</span></span>
<span id="cb1-886"><a href="#cb1-886" aria-hidden="true" tabindex="-1"></a><span class="co">    - corrective_smooth_iter: (Optional) Number of iterations for the corrective smooth modifier. </span></span>
<span id="cb1-887"><a href="#cb1-887" aria-hidden="true" tabindex="-1"></a><span class="co">      If 0, no corrective smooth is applied.</span></span>
<span id="cb1-888"><a href="#cb1-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-889"><a href="#cb1-889" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-890"><a href="#cb1-890" aria-hidden="true" tabindex="-1"></a><span class="co">    - bpy.types.Object: The new modified mesh object.</span></span>
<span id="cb1-891"><a href="#cb1-891" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-892"><a href="#cb1-892" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure the objects are valid</span></span>
<span id="cb1-893"><a href="#cb1-893" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> source_obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span> <span class="kw">or</span> target_obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-894"><a href="#cb1-894" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Both source_obj and target_obj must be mesh objects."</span>)</span>
<span id="cb1-895"><a href="#cb1-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-896"><a href="#cb1-896" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the currently active object</span></span>
<span id="cb1-897"><a href="#cb1-897" aria-hidden="true" tabindex="-1"></a>    original_active_obj <span class="op">=</span> bpy.context.view_layer.objects.active</span>
<span id="cb1-898"><a href="#cb1-898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-899"><a href="#cb1-899" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the first shrinkwrap modifier</span></span>
<span id="cb1-900"><a href="#cb1-900" aria-hidden="true" tabindex="-1"></a>    shrinkwrap_1 <span class="op">=</span> source_obj.modifiers.new(name<span class="op">=</span><span class="st">"Shrinkwrap"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">'SHRINKWRAP'</span>)</span>
<span id="cb1-901"><a href="#cb1-901" aria-hidden="true" tabindex="-1"></a>    shrinkwrap_1.target <span class="op">=</span> target_obj</span>
<span id="cb1-902"><a href="#cb1-902" aria-hidden="true" tabindex="-1"></a>    shrinkwrap_1.wrap_method <span class="op">=</span> <span class="st">'TARGET_PROJECT'</span></span>
<span id="cb1-903"><a href="#cb1-903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-904"><a href="#cb1-904" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add a corrective smooth modifier if requested</span></span>
<span id="cb1-905"><a href="#cb1-905" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, corrective_smooth_iter):</span>
<span id="cb1-906"><a href="#cb1-906" aria-hidden="true" tabindex="-1"></a>        corrective_smooth <span class="op">=</span> source_obj.modifiers.new(name<span class="op">=</span><span class="ss">f"Corrective Smooth </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">'CORRECTIVE_SMOOTH'</span>)</span>
<span id="cb1-907"><a href="#cb1-907" aria-hidden="true" tabindex="-1"></a>        corrective_smooth.iterations <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb1-908"><a href="#cb1-908" aria-hidden="true" tabindex="-1"></a>        corrective_smooth.scale <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-909"><a href="#cb1-909" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add a second shrinkwrap modifier after the corrective smooth</span></span>
<span id="cb1-910"><a href="#cb1-910" aria-hidden="true" tabindex="-1"></a>        shrinkwrap_2 <span class="op">=</span> source_obj.modifiers.new(name<span class="op">=</span><span class="ss">f"Shrinkwrap </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">'SHRINKWRAP'</span>)</span>
<span id="cb1-911"><a href="#cb1-911" aria-hidden="true" tabindex="-1"></a>        shrinkwrap_2.target <span class="op">=</span> target_obj</span>
<span id="cb1-912"><a href="#cb1-912" aria-hidden="true" tabindex="-1"></a>        shrinkwrap_2.wrap_method <span class="op">=</span> <span class="st">'TARGET_PROJECT'</span></span>
<span id="cb1-913"><a href="#cb1-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-914"><a href="#cb1-914" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply all modifiers</span></span>
<span id="cb1-915"><a href="#cb1-915" aria-hidden="true" tabindex="-1"></a>    bpy.context.view_layer.objects.active <span class="op">=</span> source_obj</span>
<span id="cb1-916"><a href="#cb1-916" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> modifier <span class="kw">in</span> source_obj.modifiers:</span>
<span id="cb1-917"><a href="#cb1-917" aria-hidden="true" tabindex="-1"></a>        bpy.ops.<span class="bu">object</span>.modifier_apply(modifier<span class="op">=</span>modifier.name)</span>
<span id="cb1-918"><a href="#cb1-918" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Restore the original active object</span></span>
<span id="cb1-919"><a href="#cb1-919" aria-hidden="true" tabindex="-1"></a>    bpy.context.view_layer.objects.active <span class="op">=</span> original_active_obj</span>
<span id="cb1-920"><a href="#cb1-920" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> source_obj</span>
<span id="cb1-921"><a href="#cb1-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-922"><a href="#cb1-922" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-923"><a href="#cb1-923" aria-hidden="true" tabindex="-1"></a><span class="co">### Handling of mesh-associated array-data</span></span>
<span id="cb1-924"><a href="#cb1-924" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-925"><a href="#cb1-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-926"><a href="#cb1-926" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_numpy_attribute(mesh, name, array):</span>
<span id="cb1-927"><a href="#cb1-927" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Sets mesh[name] = array.</span></span>
<span id="cb1-928"><a href="#cb1-928" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-929"><a href="#cb1-929" aria-hidden="true" tabindex="-1"></a><span class="co">    Since Blender does not support adding arbitrary objects as attributes to meshes,</span></span>
<span id="cb1-930"><a href="#cb1-930" aria-hidden="true" tabindex="-1"></a><span class="co">    the array is flattened, converted to a binary buffer, and saved as a tuple together with its shape.</span></span>
<span id="cb1-931"><a href="#cb1-931" aria-hidden="true" tabindex="-1"></a><span class="co">    All arrays are converted to np.float32.</span></span>
<span id="cb1-932"><a href="#cb1-932" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-933"><a href="#cb1-933" aria-hidden="true" tabindex="-1"></a>    <span class="bu">bytes</span>, shape <span class="op">=</span> (array.astype(np.float32).flatten().tobytes(), array.shape)</span>
<span id="cb1-934"><a href="#cb1-934" aria-hidden="true" tabindex="-1"></a>    mesh[name] <span class="op">=</span> (<span class="bu">bytes</span>, shape)</span>
<span id="cb1-935"><a href="#cb1-935" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-936"><a href="#cb1-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-937"><a href="#cb1-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-938"><a href="#cb1-938" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_numpy_attribute(mesh, name):</span>
<span id="cb1-939"><a href="#cb1-939" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Get array = mesh[name].</span></span>
<span id="cb1-940"><a href="#cb1-940" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-941"><a href="#cb1-941" aria-hidden="true" tabindex="-1"></a><span class="co">    Since Blender does not support adding arbitrary objects as attributes to meshes,</span></span>
<span id="cb1-942"><a href="#cb1-942" aria-hidden="true" tabindex="-1"></a><span class="co">    the array is flattened, converted to a binary buffer, and saved as a tuple together with its shape.</span></span>
<span id="cb1-943"><a href="#cb1-943" aria-hidden="true" tabindex="-1"></a><span class="co">    All arrays are converted to np.float32.</span></span>
<span id="cb1-944"><a href="#cb1-944" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-945"><a href="#cb1-945" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> name <span class="kw">in</span> mesh, <span class="st">"Attribute not found"</span></span>
<span id="cb1-946"><a href="#cb1-946" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.frombuffer(mesh[name][<span class="dv">0</span>], dtype<span class="op">=</span>np.float32).reshape(mesh[name][<span class="dv">1</span>])</span>
<span id="cb1-947"><a href="#cb1-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-948"><a href="#cb1-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-949"><a href="#cb1-949" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> separate_selected_into_mesh_and_box(<span class="va">self</span>, context):</span>
<span id="cb1-950"><a href="#cb1-950" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-951"><a href="#cb1-951" aria-hidden="true" tabindex="-1"></a><span class="co">    Separate selected objects into mesh and box, representing 3D image data.</span></span>
<span id="cb1-952"><a href="#cb1-952" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-953"><a href="#cb1-953" aria-hidden="true" tabindex="-1"></a><span class="co">    If not exactly one mesh and one box (with attribute "3D_data") are selected,</span></span>
<span id="cb1-954"><a href="#cb1-954" aria-hidden="true" tabindex="-1"></a><span class="co">    an error is raised.</span></span>
<span id="cb1-955"><a href="#cb1-955" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-956"><a href="#cb1-956" aria-hidden="true" tabindex="-1"></a>    n_data_selected <span class="op">=</span> <span class="bu">len</span>([x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="st">"3D_data"</span> <span class="kw">in</span> x])</span>
<span id="cb1-957"><a href="#cb1-957" aria-hidden="true" tabindex="-1"></a>    n_mesh_selected <span class="op">=</span> <span class="bu">len</span>([x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="kw">not</span> <span class="st">"3D_data"</span> <span class="kw">in</span> x])</span>
<span id="cb1-958"><a href="#cb1-958" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> ((n_data_selected<span class="op">==</span><span class="dv">1</span>) <span class="kw">and</span> (n_mesh_selected<span class="op">==</span><span class="dv">1</span>)):</span>
<span id="cb1-959"><a href="#cb1-959" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Select exactly one mesh and one 3D image (BoundingBox)!"</span>)</span>
<span id="cb1-960"><a href="#cb1-960" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb1-961"><a href="#cb1-961" aria-hidden="true" tabindex="-1"></a>    box <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="st">"3D_data"</span> <span class="kw">in</span> x][<span class="dv">0</span>]</span>
<span id="cb1-962"><a href="#cb1-962" aria-hidden="true" tabindex="-1"></a>    obj <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="kw">not</span> <span class="st">"3D_data"</span> <span class="kw">in</span> x][<span class="dv">0</span>]</span>
<span id="cb1-963"><a href="#cb1-963" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obj <span class="kw">or</span> obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-964"><a href="#cb1-964" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"No mesh object selected!"</span>)</span>
<span id="cb1-965"><a href="#cb1-965" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb1-966"><a href="#cb1-966" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> box, obj</span>
<span id="cb1-967"><a href="#cb1-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-968"><a href="#cb1-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-969"><a href="#cb1-969" aria-hidden="true" tabindex="-1"></a><span class="co">### Operators defining the user interface of the add-on</span></span>
<span id="cb1-970"><a href="#cb1-970" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-971"><a href="#cb1-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-972"><a href="#cb1-972" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LoadTIFFOperator(Operator):</span>
<span id="cb1-973"><a href="#cb1-973" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Load .tif file and resolution. Also creates a bounding box object."""</span></span>
<span id="cb1-974"><a href="#cb1-974" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.load_tiff"</span></span>
<span id="cb1-975"><a href="#cb1-975" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Load TIFF File"</span></span>
<span id="cb1-976"><a href="#cb1-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-977"><a href="#cb1-977" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-978"><a href="#cb1-978" aria-hidden="true" tabindex="-1"></a>        file_path <span class="op">=</span> bpy.path.abspath(context.scene.tissue_cartography_file)</span>
<span id="cb1-979"><a href="#cb1-979" aria-hidden="true" tabindex="-1"></a>        resolution <span class="op">=</span> np.array(context.scene.tissue_cartography_resolution)</span>
<span id="cb1-980"><a href="#cb1-980" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Resolution loaded: </span><span class="sc">{</span>resolution<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-981"><a href="#cb1-981" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-982"><a href="#cb1-982" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load TIFF file as a NumPy array</span></span>
<span id="cb1-983"><a href="#cb1-983" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (file_path.lower().endswith(<span class="st">".tiff"</span>) <span class="kw">or</span> file_path.lower().endswith(<span class="st">".tif"</span>)):</span>
<span id="cb1-984"><a href="#cb1-984" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected file is not a TIFF"</span>)</span>
<span id="cb1-985"><a href="#cb1-985" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-986"><a href="#cb1-986" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-987"><a href="#cb1-987" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> tifffile.imread(file_path)</span>
<span id="cb1-988"><a href="#cb1-988" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(data.shape) <span class="kw">in</span> [<span class="dv">3</span>,<span class="dv">4</span>]:</span>
<span id="cb1-989"><a href="#cb1-989" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected TIFF must have 3 or 4 axes."</span>)</span>
<span id="cb1-990"><a href="#cb1-990" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-991"><a href="#cb1-991" aria-hidden="true" tabindex="-1"></a>            <span class="co"># sort out axis order</span></span>
<span id="cb1-992"><a href="#cb1-992" aria-hidden="true" tabindex="-1"></a>            axis_order_string <span class="op">=</span> context.scene.tissue_cartography_axis_order</span>
<span id="cb1-993"><a href="#cb1-993" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="st">''</span>.join(<span class="bu">sorted</span>(axis_order_string)) <span class="kw">in</span> [<span class="st">''</span>, <span class="st">'xyz'</span>, <span class="st">'cxyz'</span>]:</span>
<span id="cb1-994"><a href="#cb1-994" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Must be empty, xyz, cxyz, or permutation thereof"</span>)</span>
<span id="cb1-995"><a href="#cb1-995" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-996"><a href="#cb1-996" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(axis_order_string) <span class="kw">in</span> [<span class="dv">0</span>, <span class="bu">len</span>(data.shape)]:</span>
<span id="cb1-997"><a href="#cb1-997" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Number of axes in axis order does not match tiff data."</span>)</span>
<span id="cb1-998"><a href="#cb1-998" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-999"><a href="#cb1-999" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-1000"><a href="#cb1-1000" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> axis_order_string <span class="op">==</span> <span class="st">''</span> <span class="kw">and</span> <span class="bu">len</span>(data.shape) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb1-1001"><a href="#cb1-1001" aria-hidden="true" tabindex="-1"></a>                <span class="co"># ensure channel axis (assumed shortest axis) is 1st if no axis order provided.</span></span>
<span id="cb1-1002"><a href="#cb1-1002" aria-hidden="true" tabindex="-1"></a>                channel_axis <span class="op">=</span> np.argmin(data.shape)</span>
<span id="cb1-1003"><a href="#cb1-1003" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> np.moveaxis(data, channel_axis, <span class="dv">0</span>)</span>
<span id="cb1-1004"><a href="#cb1-1004" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> axis_order_string <span class="op">!=</span> <span class="st">''</span>:</span>
<span id="cb1-1005"><a href="#cb1-1005" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data.transpose(axis_order_to_transpose(axis_order_string))</span>
<span id="cb1-1006"><a href="#cb1-1006" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(data.shape) <span class="op">==</span> <span class="dv">3</span>: <span class="co"># add singleton channel axis to single channel-data </span></span>
<span id="cb1-1007"><a href="#cb1-1007" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data[np.newaxis]</span>
<span id="cb1-1008"><a href="#cb1-1008" aria-hidden="true" tabindex="-1"></a>            <span class="co"># display image shape in add-on</span></span>
<span id="cb1-1009"><a href="#cb1-1009" aria-hidden="true" tabindex="-1"></a>            context.scene.tissue_cartography_image_shape <span class="op">=</span> <span class="bu">str</span>(data.shape[<span class="dv">1</span>:])</span>
<span id="cb1-1010"><a href="#cb1-1010" aria-hidden="true" tabindex="-1"></a>            context.scene.tissue_cartography_image_channels <span class="op">=</span> data.shape[<span class="dv">0</span>]</span>
<span id="cb1-1011"><a href="#cb1-1011" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"TIFF file loaded with shape </span><span class="sc">{</span>data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1012"><a href="#cb1-1012" aria-hidden="true" tabindex="-1"></a>            <span class="co"># create a bounding box mesh to represent the data</span></span>
<span id="cb1-1013"><a href="#cb1-1013" aria-hidden="true" tabindex="-1"></a>            box <span class="op">=</span> create_box(<span class="op">*</span>(np.array(data.shape[<span class="dv">1</span>:])<span class="op">*</span>resolution),</span>
<span id="cb1-1014"><a href="#cb1-1014" aria-hidden="true" tabindex="-1"></a>                             name<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>Path(file_path)<span class="sc">.</span>stem<span class="sc">}</span><span class="ss">_BoundingBox"</span>,</span>
<span id="cb1-1015"><a href="#cb1-1015" aria-hidden="true" tabindex="-1"></a>                             hide<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-1016"><a href="#cb1-1016" aria-hidden="true" tabindex="-1"></a>            box.display_type <span class="op">=</span> <span class="st">'WIRE'</span></span>
<span id="cb1-1017"><a href="#cb1-1017" aria-hidden="true" tabindex="-1"></a>            <span class="co"># attach the data to the box</span></span>
<span id="cb1-1018"><a href="#cb1-1018" aria-hidden="true" tabindex="-1"></a>            set_numpy_attribute(box, <span class="st">"resolution"</span>, resolution)</span>
<span id="cb1-1019"><a href="#cb1-1019" aria-hidden="true" tabindex="-1"></a>            set_numpy_attribute(box, <span class="st">"3D_data"</span>, data)</span>
<span id="cb1-1020"><a href="#cb1-1020" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-1021"><a href="#cb1-1021" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-1022"><a href="#cb1-1022" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Failed to load TIFF file: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1023"><a href="#cb1-1023" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1024"><a href="#cb1-1024" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1025"><a href="#cb1-1025" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1026"><a href="#cb1-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1027"><a href="#cb1-1027" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1028"><a href="#cb1-1028" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LoadSegmentationTIFFOperator(Operator):</span>
<span id="cb1-1029"><a href="#cb1-1029" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-1030"><a href="#cb1-1030" aria-hidden="true" tabindex="-1"></a><span class="co">    Load segmentation .tif file and resolution, and create a mesh from binary segmentation.</span></span>
<span id="cb1-1031"><a href="#cb1-1031" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-1032"><a href="#cb1-1032" aria-hidden="true" tabindex="-1"></a><span class="co">    Selecting a folder instead of a file batch processes all files in folder.</span></span>
<span id="cb1-1033"><a href="#cb1-1033" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-1034"><a href="#cb1-1034" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.load_segmentation"</span></span>
<span id="cb1-1035"><a href="#cb1-1035" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Load Segmentation TIFF File"</span></span>
<span id="cb1-1036"><a href="#cb1-1036" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1037"><a href="#cb1-1037" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1038"><a href="#cb1-1038" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load resolution as a NumPy array</span></span>
<span id="cb1-1039"><a href="#cb1-1039" aria-hidden="true" tabindex="-1"></a>        resolution_array <span class="op">=</span> np.array(context.scene.tissue_cartography_segmentation_resolution)</span>
<span id="cb1-1040"><a href="#cb1-1040" aria-hidden="true" tabindex="-1"></a>        input_path <span class="op">=</span> Path(bpy.path.abspath(context.scene.tissue_cartography_segmentation_file))</span>
<span id="cb1-1041"><a href="#cb1-1041" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> input_path.is_dir():</span>
<span id="cb1-1042"><a href="#cb1-1042" aria-hidden="true" tabindex="-1"></a>            files_to_process <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> input_path.iterdir() <span class="cf">if</span> f.is_file() <span class="kw">and</span> f.suffix <span class="kw">in</span> [<span class="st">".tif"</span>, <span class="st">".tiff"</span>]]</span>
<span id="cb1-1043"><a href="#cb1-1043" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> input_path.is_file():</span>
<span id="cb1-1044"><a href="#cb1-1044" aria-hidden="true" tabindex="-1"></a>            files_to_process <span class="op">=</span> [input_path]</span>
<span id="cb1-1045"><a href="#cb1-1045" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-1046"><a href="#cb1-1046" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Select a valid file or directory"</span>)</span>
<span id="cb1-1047"><a href="#cb1-1047" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1048"><a href="#cb1-1048" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> file_path <span class="kw">in</span> files_to_process:</span>
<span id="cb1-1049"><a href="#cb1-1049" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> file_path.suffix <span class="kw">in</span> [<span class="st">".tif"</span>, <span class="st">".tiff"</span>]:</span>
<span id="cb1-1050"><a href="#cb1-1050" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected file is not a TIFF"</span>)</span>
<span id="cb1-1051"><a href="#cb1-1051" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1052"><a href="#cb1-1052" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb1-1053"><a href="#cb1-1053" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> tifffile.imread(file_path)</span>
<span id="cb1-1054"><a href="#cb1-1054" aria-hidden="true" tabindex="-1"></a>                <span class="co"># sort out axis order</span></span>
<span id="cb1-1055"><a href="#cb1-1055" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(data.shape) <span class="kw">in</span> [<span class="dv">3</span>,<span class="dv">4</span>]:</span>
<span id="cb1-1056"><a href="#cb1-1056" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected TIFF must have 3 or 4 axes."</span>)</span>
<span id="cb1-1057"><a href="#cb1-1057" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1058"><a href="#cb1-1058" aria-hidden="true" tabindex="-1"></a>                axis_order_string <span class="op">=</span> context.scene.tissue_cartography_segmentation_axis_order</span>
<span id="cb1-1059"><a href="#cb1-1059" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="st">''</span>.join(<span class="bu">sorted</span>(axis_order_string)) <span class="kw">in</span> [<span class="st">''</span>, <span class="st">'xyz'</span>, <span class="st">'cxyz'</span>]:</span>
<span id="cb1-1060"><a href="#cb1-1060" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Must be empty, xyz, cxyz, or permutation thereof"</span>)</span>
<span id="cb1-1061"><a href="#cb1-1061" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1062"><a href="#cb1-1062" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(axis_order_string) <span class="kw">in</span> [<span class="dv">0</span>, <span class="bu">len</span>(data.shape)]:</span>
<span id="cb1-1063"><a href="#cb1-1063" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Number of axes in axis order does not match tiff data."</span>)</span>
<span id="cb1-1064"><a href="#cb1-1064" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1065"><a href="#cb1-1065" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> axis_order_string <span class="op">==</span> <span class="st">''</span> <span class="kw">and</span> <span class="bu">len</span>(data.shape) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb1-1066"><a href="#cb1-1066" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># ensure channel axis (assumed shortest axis) is 1st if no axis order provided.</span></span>
<span id="cb1-1067"><a href="#cb1-1067" aria-hidden="true" tabindex="-1"></a>                    channel_axis <span class="op">=</span> np.argmin(data.shape)</span>
<span id="cb1-1068"><a href="#cb1-1068" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> np.moveaxis(data, channel_axis, <span class="dv">0</span>)</span>
<span id="cb1-1069"><a href="#cb1-1069" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> axis_order_string <span class="op">!=</span> <span class="st">''</span>:</span>
<span id="cb1-1070"><a href="#cb1-1070" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> data.transpose(axis_order_to_transpose(axis_order_string))</span>
<span id="cb1-1071"><a href="#cb1-1071" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(data.shape) <span class="op">==</span> <span class="dv">3</span>: <span class="co"># add singleton channel axis to single channel-data </span></span>
<span id="cb1-1072"><a href="#cb1-1072" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> data[np.newaxis]</span>
<span id="cb1-1073"><a href="#cb1-1073" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"TIFF file loaded with shape </span><span class="sc">{</span>data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1074"><a href="#cb1-1074" aria-hidden="true" tabindex="-1"></a>                context.scene.tissue_cartography_segmentation_shape <span class="op">=</span> <span class="bu">str</span>(data.shape[<span class="dv">1</span>:])</span>
<span id="cb1-1075"><a href="#cb1-1075" aria-hidden="true" tabindex="-1"></a>                context.scene.tissue_cartography_segmentation_channels <span class="op">=</span> data.shape[<span class="dv">0</span>]</span>
<span id="cb1-1076"><a href="#cb1-1076" aria-hidden="true" tabindex="-1"></a>                <span class="co"># iterate over channels. each channel is one label</span></span>
<span id="cb1-1077"><a href="#cb1-1077" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> ic, channel <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb1-1078"><a href="#cb1-1078" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># smooth and normalize the segmentation</span></span>
<span id="cb1-1079"><a href="#cb1-1079" aria-hidden="true" tabindex="-1"></a>                    channel <span class="op">=</span> (channel<span class="op">-</span>channel.<span class="bu">min</span>())<span class="op">/</span>(channel.<span class="bu">max</span>()<span class="op">-</span>channel.<span class="bu">min</span>())</span>
<span id="cb1-1080"><a href="#cb1-1080" aria-hidden="true" tabindex="-1"></a>                    sigma <span class="op">=</span> context.scene.tissue_cartography_segmentation_sigma</span>
<span id="cb1-1081"><a href="#cb1-1081" aria-hidden="true" tabindex="-1"></a>                    channel <span class="op">=</span> ndimage.gaussian_filter(channel, sigma<span class="op">=</span>sigma<span class="op">/</span>resolution_array)</span>
<span id="cb1-1082"><a href="#cb1-1082" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># compute mesh using marching cubes, and convert to mesh</span></span>
<span id="cb1-1083"><a href="#cb1-1083" aria-hidden="true" tabindex="-1"></a>                    verts, faces, _, _ <span class="op">=</span> measure.marching_cubes(channel, level<span class="op">=</span><span class="fl">0.5</span>, spacing<span class="op">=</span>(<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>))</span>
<span id="cb1-1084"><a href="#cb1-1084" aria-hidden="true" tabindex="-1"></a>                    verts <span class="op">=</span> verts <span class="op">*</span> resolution_array</span>
<span id="cb1-1085"><a href="#cb1-1085" aria-hidden="true" tabindex="-1"></a>                    create_mesh_from_numpy(<span class="ss">f"</span><span class="sc">{</span>Path(file_path)<span class="sc">.</span>stem<span class="sc">}</span><span class="ss">_c</span><span class="sc">{</span>ic<span class="sc">}</span><span class="ss">"</span>, verts, faces)</span>
<span id="cb1-1086"><a href="#cb1-1086" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb1-1087"><a href="#cb1-1087" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-1088"><a href="#cb1-1088" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Failed to load segmentation: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1089"><a href="#cb1-1089" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1090"><a href="#cb1-1090" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1091"><a href="#cb1-1091" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1092"><a href="#cb1-1092" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1093"><a href="#cb1-1093" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CreateProjectionOperator(Operator):</span>
<span id="cb1-1094"><a href="#cb1-1094" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-1095"><a href="#cb1-1095" aria-hidden="true" tabindex="-1"></a><span class="co">    Create a cartographic projection.</span></span>
<span id="cb1-1096"><a href="#cb1-1096" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-1097"><a href="#cb1-1097" aria-hidden="true" tabindex="-1"></a><span class="co">    Select one mesh and one 3d-image ([...]_BoundingBox) to project 3d image data</span></span>
<span id="cb1-1098"><a href="#cb1-1098" aria-hidden="true" tabindex="-1"></a><span class="co">    onto mesh surface.</span></span>
<span id="cb1-1099"><a href="#cb1-1099" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-1100"><a href="#cb1-1100" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.create_projection"</span></span>
<span id="cb1-1101"><a href="#cb1-1101" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Create Projection"</span></span>
<span id="cb1-1102"><a href="#cb1-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1103"><a href="#cb1-1103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1104"><a href="#cb1-1104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Validate selected object and UV map</span></span>
<span id="cb1-1105"><a href="#cb1-1105" aria-hidden="true" tabindex="-1"></a>        box, obj <span class="op">=</span> separate_selected_into_mesh_and_box(<span class="va">self</span>, context)</span>
<span id="cb1-1106"><a href="#cb1-1106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> box <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> obj <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-1107"><a href="#cb1-1107" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1108"><a href="#cb1-1108" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure the object has a UV map</span></span>
<span id="cb1-1109"><a href="#cb1-1109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> obj.data.uv_layers:</span>
<span id="cb1-1110"><a href="#cb1-1110" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"The selected mesh does not have a UV map!"</span>)</span>
<span id="cb1-1111"><a href="#cb1-1111" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1112"><a href="#cb1-1112" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parse offsets into a NumPy array</span></span>
<span id="cb1-1113"><a href="#cb1-1113" aria-hidden="true" tabindex="-1"></a>        offsets_str <span class="op">=</span> context.scene.tissue_cartography_offsets</span>
<span id="cb1-1114"><a href="#cb1-1114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-1115"><a href="#cb1-1115" aria-hidden="true" tabindex="-1"></a>            offsets_array <span class="op">=</span> np.array([<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> offsets_str.split(<span class="st">","</span>) <span class="cf">if</span> x.strip()])</span>
<span id="cb1-1116"><a href="#cb1-1116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> offsets_array.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-1117"><a href="#cb1-1117" aria-hidden="true" tabindex="-1"></a>                offsets_array <span class="op">=</span> np.array([<span class="dv">0</span>])</span>
<span id="cb1-1118"><a href="#cb1-1118" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Offsets loaded: </span><span class="sc">{</span>offsets_array<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1119"><a href="#cb1-1119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb1-1120"><a href="#cb1-1120" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Invalid offsets input: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1121"><a href="#cb1-1121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1122"><a href="#cb1-1122" aria-hidden="true" tabindex="-1"></a>        <span class="co"># set offsets as property</span></span>
<span id="cb1-1123"><a href="#cb1-1123" aria-hidden="true" tabindex="-1"></a>        set_numpy_attribute(obj, <span class="st">"projection_offsets"</span>, offsets_array)</span>
<span id="cb1-1124"><a href="#cb1-1124" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1125"><a href="#cb1-1125" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parse projection resolution</span></span>
<span id="cb1-1126"><a href="#cb1-1126" aria-hidden="true" tabindex="-1"></a>        projection_resolution <span class="op">=</span> context.scene.tissue_cartography_projection_resolution</span>
<span id="cb1-1127"><a href="#cb1-1127" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Using projection resolution: </span><span class="sc">{</span>projection_resolution<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1128"><a href="#cb1-1128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1129"><a href="#cb1-1129" aria-hidden="true" tabindex="-1"></a>        <span class="co"># texture bake normals and world positions</span></span>
<span id="cb1-1130"><a href="#cb1-1130" aria-hidden="true" tabindex="-1"></a>        loop_uvs, loop_normals, loop_world_positions <span class="op">=</span> get_uv_normal_world_per_loop(obj, filter_unique<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-1131"><a href="#cb1-1131" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1132"><a href="#cb1-1132" aria-hidden="true" tabindex="-1"></a>        baked_normals <span class="op">=</span> bake_per_loop_values_to_uv(loop_uvs, loop_normals, </span>
<span id="cb1-1133"><a href="#cb1-1133" aria-hidden="true" tabindex="-1"></a>                                                   image_resolution<span class="op">=</span>projection_resolution)</span>
<span id="cb1-1134"><a href="#cb1-1134" aria-hidden="true" tabindex="-1"></a>        baked_normals <span class="op">=</span> (baked_normals.T<span class="op">/</span>np.linalg.norm(baked_normals.T, axis<span class="op">=</span><span class="dv">0</span>)).T</span>
<span id="cb1-1135"><a href="#cb1-1135" aria-hidden="true" tabindex="-1"></a>        baked_world_positions <span class="op">=</span> bake_per_loop_values_to_uv(loop_uvs, loop_world_positions,</span>
<span id="cb1-1136"><a href="#cb1-1136" aria-hidden="true" tabindex="-1"></a>                                                           image_resolution<span class="op">=</span>projection_resolution)</span>
<span id="cb1-1137"><a href="#cb1-1137" aria-hidden="true" tabindex="-1"></a>        <span class="co"># obtain UV layout and use it to get a mask</span></span>
<span id="cb1-1138"><a href="#cb1-1138" aria-hidden="true" tabindex="-1"></a>        uv_layout_path <span class="op">=</span> <span class="bu">str</span>(Path(bpy.path.abspath(<span class="st">"//"</span>)).joinpath(<span class="ss">f'</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_UV_layout.png'</span>))</span>
<span id="cb1-1139"><a href="#cb1-1139" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> get_uv_layout(obj, uv_layout_path, projection_resolution)</span>
<span id="cb1-1140"><a href="#cb1-1140" aria-hidden="true" tabindex="-1"></a>        baked_normals[<span class="op">~</span>mask] <span class="op">=</span> np.nan</span>
<span id="cb1-1141"><a href="#cb1-1141" aria-hidden="true" tabindex="-1"></a>        baked_world_positions[<span class="op">~</span>mask] <span class="op">=</span> np.nan</span>
<span id="cb1-1142"><a href="#cb1-1142" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1143"><a href="#cb1-1143" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create a pullback</span></span>
<span id="cb1-1144"><a href="#cb1-1144" aria-hidden="true" tabindex="-1"></a>        box_world_inv <span class="op">=</span> np.linalg.inv(np.array(box.matrix_world))</span>
<span id="cb1-1145"><a href="#cb1-1145" aria-hidden="true" tabindex="-1"></a>        baked_data <span class="op">=</span> bake_volumetric_data_to_uv(get_numpy_attribute(box, <span class="st">"3D_data"</span>),</span>
<span id="cb1-1146"><a href="#cb1-1146" aria-hidden="true" tabindex="-1"></a>                                                baked_world_positions, </span>
<span id="cb1-1147"><a href="#cb1-1147" aria-hidden="true" tabindex="-1"></a>                                                get_numpy_attribute(box, <span class="st">"resolution"</span>),</span>
<span id="cb1-1148"><a href="#cb1-1148" aria-hidden="true" tabindex="-1"></a>                                                baked_normals, normal_offsets<span class="op">=</span>offsets_array,</span>
<span id="cb1-1149"><a href="#cb1-1149" aria-hidden="true" tabindex="-1"></a>                                                affine_matrix<span class="op">=</span>box_world_inv)</span>
<span id="cb1-1150"><a href="#cb1-1150" aria-hidden="true" tabindex="-1"></a>        <span class="co"># set results as attributes of the mesh</span></span>
<span id="cb1-1151"><a href="#cb1-1151" aria-hidden="true" tabindex="-1"></a>        set_numpy_attribute(obj, <span class="st">"baked_data"</span>, baked_data)</span>
<span id="cb1-1152"><a href="#cb1-1152" aria-hidden="true" tabindex="-1"></a>        set_numpy_attribute(obj, <span class="st">"baked_normals"</span>, baked_normals)</span>
<span id="cb1-1153"><a href="#cb1-1153" aria-hidden="true" tabindex="-1"></a>        set_numpy_attribute(obj, <span class="st">"baked_world_positions"</span>, baked_world_positions)</span>
<span id="cb1-1154"><a href="#cb1-1154" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create texture</span></span>
<span id="cb1-1155"><a href="#cb1-1155" aria-hidden="true" tabindex="-1"></a>        create_material_from_multilayer_array(obj, baked_data, material_name<span class="op">=</span><span class="ss">f"ProjectedMaterial_</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1156"><a href="#cb1-1156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1157"><a href="#cb1-1157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1158"><a href="#cb1-1158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1159"><a href="#cb1-1159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1160"><a href="#cb1-1160" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SaveProjectionOperator(Operator):</span>
<span id="cb1-1161"><a href="#cb1-1161" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Save cartographic projection to disk"""</span></span>
<span id="cb1-1162"><a href="#cb1-1162" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.save_projection"</span></span>
<span id="cb1-1163"><a href="#cb1-1163" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Save Projection"</span></span>
<span id="cb1-1164"><a href="#cb1-1164" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1165"><a href="#cb1-1165" aria-hidden="true" tabindex="-1"></a>    filepath: bpy.props.StringProperty(subtype<span class="op">=</span><span class="st">"FILE_PATH"</span>)</span>
<span id="cb1-1166"><a href="#cb1-1166" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1167"><a href="#cb1-1167" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> invoke(<span class="va">self</span>, context, event):</span>
<span id="cb1-1168"><a href="#cb1-1168" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Open file browser to choose the save location</span></span>
<span id="cb1-1169"><a href="#cb1-1169" aria-hidden="true" tabindex="-1"></a>        context.window_manager.fileselect_add(<span class="va">self</span>)</span>
<span id="cb1-1170"><a href="#cb1-1170" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'RUNNING_MODAL'</span>}</span>
<span id="cb1-1171"><a href="#cb1-1171" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1172"><a href="#cb1-1172" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1173"><a href="#cb1-1173" aria-hidden="true" tabindex="-1"></a>        obj <span class="op">=</span> context.active_object</span>
<span id="cb1-1174"><a href="#cb1-1174" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> obj <span class="kw">or</span> <span class="st">"baked_data"</span> <span class="kw">not</span> <span class="kw">in</span> obj:</span>
<span id="cb1-1175"><a href="#cb1-1175" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"No baked data found on the active object!"</span>)</span>
<span id="cb1-1176"><a href="#cb1-1176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1177"><a href="#cb1-1177" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1178"><a href="#cb1-1178" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the baked data</span></span>
<span id="cb1-1179"><a href="#cb1-1179" aria-hidden="true" tabindex="-1"></a>        baked_data <span class="op">=</span> get_numpy_attribute(obj, <span class="st">"baked_data"</span>)</span>
<span id="cb1-1180"><a href="#cb1-1180" aria-hidden="true" tabindex="-1"></a>        baked_normals <span class="op">=</span> get_numpy_attribute(obj, <span class="st">"baked_normals"</span>)</span>
<span id="cb1-1181"><a href="#cb1-1181" aria-hidden="true" tabindex="-1"></a>        baked_world_positions <span class="op">=</span> get_numpy_attribute(obj, <span class="st">"baked_world_positions"</span>)</span>
<span id="cb1-1182"><a href="#cb1-1182" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save the data to the chosen filepath</span></span>
<span id="cb1-1183"><a href="#cb1-1183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-1184"><a href="#cb1-1184" aria-hidden="true" tabindex="-1"></a>            tifffile.imwrite(<span class="va">self</span>.filepath <span class="op">+</span> <span class="st">"_BakedNormals.tif"</span>, baked_normals)</span>
<span id="cb1-1185"><a href="#cb1-1185" aria-hidden="true" tabindex="-1"></a>            tifffile.imwrite(<span class="va">self</span>.filepath <span class="op">+</span> <span class="st">"_BakedPositions.tif"</span>, baked_world_positions)</span>
<span id="cb1-1186"><a href="#cb1-1186" aria-hidden="true" tabindex="-1"></a>            tifffile.imwrite(<span class="va">self</span>.filepath <span class="op">+</span> <span class="st">"_BakedData.tif"</span>, baked_data.astype(np.float32),</span>
<span id="cb1-1187"><a href="#cb1-1187" aria-hidden="true" tabindex="-1"></a>                             metadata<span class="op">=</span>{<span class="st">'axes'</span>: <span class="st">'ZCYX'</span>}, imagej<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-1188"><a href="#cb1-1188" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Cartographic projection saved to </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>filepath<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1189"><a href="#cb1-1189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-1190"><a href="#cb1-1190" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Failed to save data: </span><span class="sc">{</span><span class="bu">str</span>(e)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1191"><a href="#cb1-1191" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1192"><a href="#cb1-1192" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1193"><a href="#cb1-1193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1194"><a href="#cb1-1194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1195"><a href="#cb1-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1196"><a href="#cb1-1196" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BatchProjectionOperator(Operator):</span>
<span id="cb1-1197"><a href="#cb1-1197" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-1198"><a href="#cb1-1198" aria-hidden="true" tabindex="-1"></a><span class="co">    Batch-process cartographic projections.</span></span>
<span id="cb1-1199"><a href="#cb1-1199" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-1200"><a href="#cb1-1200" aria-hidden="true" tabindex="-1"></a><span class="co">    Select all meshes to process (in blender) and one 3d-image ([...]_BoundingBox)</span></span>
<span id="cb1-1201"><a href="#cb1-1201" aria-hidden="true" tabindex="-1"></a><span class="co">    for resolution and relative position information. Further 3d .tiff files are read from</span></span>
<span id="cb1-1202"><a href="#cb1-1202" aria-hidden="true" tabindex="-1"></a><span class="co">    Batch Process Input directory. Mesh names should match .tiff file names.</span></span>
<span id="cb1-1203"><a href="#cb1-1203" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-1204"><a href="#cb1-1204" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-1205"><a href="#cb1-1205" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.batch_projection"</span></span>
<span id="cb1-1206"><a href="#cb1-1206" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Create Projections (Batch Mode)"</span></span>
<span id="cb1-1207"><a href="#cb1-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1208"><a href="#cb1-1208" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1209"><a href="#cb1-1209" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-1210"><a href="#cb1-1210" aria-hidden="true" tabindex="-1"></a>            box <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="st">"3D_data"</span> <span class="kw">in</span> x][<span class="dv">0</span>]</span>
<span id="cb1-1211"><a href="#cb1-1211" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">IndexError</span>:</span>
<span id="cb1-1212"><a href="#cb1-1212" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Select one 3D image (BoundingBox) for resolution and position information!"</span>)</span>
<span id="cb1-1213"><a href="#cb1-1213" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-1214"><a href="#cb1-1214" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get list of files</span></span>
<span id="cb1-1215"><a href="#cb1-1215" aria-hidden="true" tabindex="-1"></a>        batch_path <span class="op">=</span> Path(bpy.path.abspath(context.scene.tissue_cartography_batch_directory))</span>
<span id="cb1-1216"><a href="#cb1-1216" aria-hidden="true" tabindex="-1"></a>        batch_out_path <span class="op">=</span> Path(bpy.path.abspath(context.scene.tissue_cartography_batch_output_directory))</span>
<span id="cb1-1217"><a href="#cb1-1217" aria-hidden="true" tabindex="-1"></a>        batch_files <span class="op">=</span> {f.stem: f <span class="cf">for</span> f <span class="kw">in</span> <span class="bu">list</span>(batch_path.iterdir()) <span class="cf">if</span> ((f.suffix <span class="kw">in</span> [<span class="st">".tif"</span>, <span class="st">".tiff"</span>]) <span class="kw">and</span> <span class="kw">not</span> <span class="st">"Baked"</span> <span class="kw">in</span> f.stem)}</span>
<span id="cb1-1218"><a href="#cb1-1218" aria-hidden="true" tabindex="-1"></a>        <span class="co"># match files to selected meshes</span></span>
<span id="cb1-1219"><a href="#cb1-1219" aria-hidden="true" tabindex="-1"></a>        meshes_to_process <span class="op">=</span> [obj <span class="cf">for</span> obj <span class="kw">in</span> context.selected_objects <span class="cf">if</span> obj <span class="op">!=</span> box]</span>
<span id="cb1-1220"><a href="#cb1-1220" aria-hidden="true" tabindex="-1"></a>        mesh_names <span class="op">=</span> [obj.name <span class="cf">for</span> obj <span class="kw">in</span> meshes_to_process]</span>
<span id="cb1-1221"><a href="#cb1-1221" aria-hidden="true" tabindex="-1"></a>        matched <span class="op">=</span> {obj.name: difflib.get_close_matches(obj.name, batch_files.keys(), n<span class="op">=</span><span class="dv">1</span>, cutoff<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb1-1222"><a href="#cb1-1222" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">for</span> obj <span class="kw">in</span> context.selected_objects <span class="cf">if</span> obj <span class="op">!=</span> box}</span>
<span id="cb1-1223"><a href="#cb1-1223" aria-hidden="true" tabindex="-1"></a>        <span class="co"># parse axis order</span></span>
<span id="cb1-1224"><a href="#cb1-1224" aria-hidden="true" tabindex="-1"></a>        axis_order <span class="op">=</span> <span class="bu">list</span>(context.scene.tissue_cartography_axis_order)</span>
<span id="cb1-1225"><a href="#cb1-1225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">sorted</span>(axis_order) <span class="op">==</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]:</span>
<span id="cb1-1226"><a href="#cb1-1226" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Axis order must be a permutation of [0,1,2,3] (e.g. [3,0,1,2])"</span>)</span>
<span id="cb1-1227"><a href="#cb1-1227" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1228"><a href="#cb1-1228" aria-hidden="true" tabindex="-1"></a>        <span class="co"># parse offsets into a NumPy array</span></span>
<span id="cb1-1229"><a href="#cb1-1229" aria-hidden="true" tabindex="-1"></a>        offsets_str <span class="op">=</span> context.scene.tissue_cartography_offsets</span>
<span id="cb1-1230"><a href="#cb1-1230" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-1231"><a href="#cb1-1231" aria-hidden="true" tabindex="-1"></a>            offsets_array <span class="op">=</span> np.array([<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> offsets_str.split(<span class="st">","</span>) <span class="cf">if</span> x.strip()])</span>
<span id="cb1-1232"><a href="#cb1-1232" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> offsets_array.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-1233"><a href="#cb1-1233" aria-hidden="true" tabindex="-1"></a>                offsets_array <span class="op">=</span> np.array([<span class="dv">0</span>])</span>
<span id="cb1-1234"><a href="#cb1-1234" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Offsets loaded: </span><span class="sc">{</span>offsets_array<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1235"><a href="#cb1-1235" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb1-1236"><a href="#cb1-1236" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Invalid offsets input: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1237"><a href="#cb1-1237" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1238"><a href="#cb1-1238" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parse projection resolution</span></span>
<span id="cb1-1239"><a href="#cb1-1239" aria-hidden="true" tabindex="-1"></a>        projection_resolution <span class="op">=</span> context.scene.tissue_cartography_projection_resolution</span>
<span id="cb1-1240"><a href="#cb1-1240" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Using projection resolution: </span><span class="sc">{</span>projection_resolution<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1241"><a href="#cb1-1241" aria-hidden="true" tabindex="-1"></a>        <span class="co"># find box for position and resolution info</span></span>
<span id="cb1-1242"><a href="#cb1-1242" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1243"><a href="#cb1-1243" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iobj, obj <span class="kw">in</span> <span class="bu">enumerate</span>(meshes_to_process):</span>
<span id="cb1-1244"><a href="#cb1-1244" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Processing </span><span class="sc">{</span>iobj<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="bu">len</span>(meshes_to_process)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1245"><a href="#cb1-1245" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> obj.data.uv_layers:</span>
<span id="cb1-1246"><a href="#cb1-1246" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Mesh </span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss"> does not have a UV map!"</span>)</span>
<span id="cb1-1247"><a href="#cb1-1247" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1248"><a href="#cb1-1248" aria-hidden="true" tabindex="-1"></a>            <span class="co"># set offsets as property</span></span>
<span id="cb1-1249"><a href="#cb1-1249" aria-hidden="true" tabindex="-1"></a>            set_numpy_attribute(obj, <span class="st">"projection_offsets"</span>, offsets_array)</span>
<span id="cb1-1250"><a href="#cb1-1250" aria-hidden="true" tabindex="-1"></a>            <span class="co"># find the matching file</span></span>
<span id="cb1-1251"><a href="#cb1-1251" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(matched[obj.name]) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-1252"><a href="#cb1-1252" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"No matching file found for </span><span class="sc">{obj.name}</span><span class="st">!"</span>)</span>
<span id="cb1-1253"><a href="#cb1-1253" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1254"><a href="#cb1-1254" aria-hidden="true" tabindex="-1"></a>            file_path <span class="op">=</span> batch_files[matched[obj.name][<span class="dv">0</span>]]</span>
<span id="cb1-1255"><a href="#cb1-1255" aria-hidden="true" tabindex="-1"></a>            <span class="co"># load the 3D data</span></span>
<span id="cb1-1256"><a href="#cb1-1256" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb1-1257"><a href="#cb1-1257" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> tifffile.imread(file_path)</span>
<span id="cb1-1258"><a href="#cb1-1258" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">len</span>(data.shape) <span class="kw">in</span> [<span class="dv">3</span>,<span class="dv">4</span>]:</span>
<span id="cb1-1259"><a href="#cb1-1259" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Selected TIFF for </span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss"> must have 3 or 4 axes."</span>)</span>
<span id="cb1-1260"><a href="#cb1-1260" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1261"><a href="#cb1-1261" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(data.shape) <span class="op">==</span> <span class="dv">3</span>: <span class="co"># add singleton channel axis to single channel-data </span></span>
<span id="cb1-1262"><a href="#cb1-1262" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> data[np.newaxis]</span>
<span id="cb1-1263"><a href="#cb1-1263" aria-hidden="true" tabindex="-1"></a>                <span class="co"># ensure channel axis (assumed shortest axis) is 1st</span></span>
<span id="cb1-1264"><a href="#cb1-1264" aria-hidden="true" tabindex="-1"></a>                channel_axis <span class="op">=</span> np.argmin(data.shape)</span>
<span id="cb1-1265"><a href="#cb1-1265" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> np.moveaxis(data, channel_axis, <span class="dv">0</span>)</span>
<span id="cb1-1266"><a href="#cb1-1266" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data.transpose(axis_order)</span>
<span id="cb1-1267"><a href="#cb1-1267" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span>:</span>
<span id="cb1-1268"><a href="#cb1-1268" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Failed loading TIFF for </span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1269"><a href="#cb1-1269" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1270"><a href="#cb1-1270" aria-hidden="true" tabindex="-1"></a>            <span class="co"># texture bake normals and world positions</span></span>
<span id="cb1-1271"><a href="#cb1-1271" aria-hidden="true" tabindex="-1"></a>            loop_uvs, loop_normals, loop_world_positions <span class="op">=</span> get_uv_normal_world_per_loop(obj, filter_unique<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-1272"><a href="#cb1-1272" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-1273"><a href="#cb1-1273" aria-hidden="true" tabindex="-1"></a>            baked_normals <span class="op">=</span> bake_per_loop_values_to_uv(loop_uvs, loop_normals, </span>
<span id="cb1-1274"><a href="#cb1-1274" aria-hidden="true" tabindex="-1"></a>                                                       image_resolution<span class="op">=</span>projection_resolution)</span>
<span id="cb1-1275"><a href="#cb1-1275" aria-hidden="true" tabindex="-1"></a>            baked_normals <span class="op">=</span> (baked_normals.T<span class="op">/</span>np.linalg.norm(baked_normals.T, axis<span class="op">=</span><span class="dv">0</span>)).T</span>
<span id="cb1-1276"><a href="#cb1-1276" aria-hidden="true" tabindex="-1"></a>            baked_world_positions <span class="op">=</span> bake_per_loop_values_to_uv(loop_uvs, loop_world_positions,</span>
<span id="cb1-1277"><a href="#cb1-1277" aria-hidden="true" tabindex="-1"></a>                                                               image_resolution<span class="op">=</span>projection_resolution)</span>
<span id="cb1-1278"><a href="#cb1-1278" aria-hidden="true" tabindex="-1"></a>            <span class="co"># obtain UV layout and use it to get a mask</span></span>
<span id="cb1-1279"><a href="#cb1-1279" aria-hidden="true" tabindex="-1"></a>            uv_layout_path <span class="op">=</span> <span class="bu">str</span>(Path(batch_out_path).joinpath(<span class="ss">f'</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_UV_layout.png'</span>))</span>
<span id="cb1-1280"><a href="#cb1-1280" aria-hidden="true" tabindex="-1"></a>            mask <span class="op">=</span> get_uv_layout(obj, uv_layout_path, projection_resolution)</span>
<span id="cb1-1281"><a href="#cb1-1281" aria-hidden="true" tabindex="-1"></a>            baked_normals[<span class="op">~</span>mask] <span class="op">=</span> np.nan</span>
<span id="cb1-1282"><a href="#cb1-1282" aria-hidden="true" tabindex="-1"></a>            baked_world_positions[<span class="op">~</span>mask] <span class="op">=</span> np.nan</span>
<span id="cb1-1283"><a href="#cb1-1283" aria-hidden="true" tabindex="-1"></a>            <span class="co"># create a pullback</span></span>
<span id="cb1-1284"><a href="#cb1-1284" aria-hidden="true" tabindex="-1"></a>            box_world_inv <span class="op">=</span> np.linalg.inv(np.array(box.matrix_world))</span>
<span id="cb1-1285"><a href="#cb1-1285" aria-hidden="true" tabindex="-1"></a>            baked_data <span class="op">=</span> bake_volumetric_data_to_uv(data,</span>
<span id="cb1-1286"><a href="#cb1-1286" aria-hidden="true" tabindex="-1"></a>                                                    baked_world_positions, </span>
<span id="cb1-1287"><a href="#cb1-1287" aria-hidden="true" tabindex="-1"></a>                                                    get_numpy_attribute(box, <span class="st">"resolution"</span>),</span>
<span id="cb1-1288"><a href="#cb1-1288" aria-hidden="true" tabindex="-1"></a>                                                    baked_normals, normal_offsets<span class="op">=</span>offsets_array,</span>
<span id="cb1-1289"><a href="#cb1-1289" aria-hidden="true" tabindex="-1"></a>                                                    affine_matrix<span class="op">=</span>box_world_inv)</span>
<span id="cb1-1290"><a href="#cb1-1290" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Save the data to the chosen filepath</span></span>
<span id="cb1-1291"><a href="#cb1-1291" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb1-1292"><a href="#cb1-1292" aria-hidden="true" tabindex="-1"></a>                tifffile.imwrite(batch_out_path.joinpath(<span class="ss">f"</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_BakedNormals.tif"</span>), baked_normals)</span>
<span id="cb1-1293"><a href="#cb1-1293" aria-hidden="true" tabindex="-1"></a>                tifffile.imwrite(batch_out_path.joinpath(<span class="ss">f"</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_BakedPositions.tif"</span>), baked_world_positions)</span>
<span id="cb1-1294"><a href="#cb1-1294" aria-hidden="true" tabindex="-1"></a>                tifffile.imwrite(batch_out_path.joinpath(<span class="ss">f"</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_BakedData.tif"</span>), baked_data.astype(np.float32),</span>
<span id="cb1-1295"><a href="#cb1-1295" aria-hidden="true" tabindex="-1"></a>                                 metadata<span class="op">=</span>{<span class="st">'axes'</span>: <span class="st">'ZCYX'</span>}, imagej<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-1296"><a href="#cb1-1296" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Cartographic projection saved for </span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1297"><a href="#cb1-1297" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-1298"><a href="#cb1-1298" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Failed to save data for </span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">str</span>(e)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1299"><a href="#cb1-1299" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1300"><a href="#cb1-1300" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> bpy.context.scene.tissue_cartography_batch_create_materials:</span>
<span id="cb1-1301"><a href="#cb1-1301" aria-hidden="true" tabindex="-1"></a>                <span class="co"># set results as attributes of the mesh</span></span>
<span id="cb1-1302"><a href="#cb1-1302" aria-hidden="true" tabindex="-1"></a>                set_numpy_attribute(obj, <span class="st">"baked_data"</span>, baked_data)</span>
<span id="cb1-1303"><a href="#cb1-1303" aria-hidden="true" tabindex="-1"></a>                set_numpy_attribute(obj, <span class="st">"baked_normals"</span>, baked_normals)</span>
<span id="cb1-1304"><a href="#cb1-1304" aria-hidden="true" tabindex="-1"></a>                set_numpy_attribute(obj, <span class="st">"baked_world_positions"</span>, baked_world_positions)</span>
<span id="cb1-1305"><a href="#cb1-1305" aria-hidden="true" tabindex="-1"></a>                <span class="co"># create texture</span></span>
<span id="cb1-1306"><a href="#cb1-1306" aria-hidden="true" tabindex="-1"></a>                create_material_from_multilayer_array(obj, baked_data, material_name<span class="op">=</span><span class="ss">f"ProjectedMaterial_</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1307"><a href="#cb1-1307" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1308"><a href="#cb1-1308" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1309"><a href="#cb1-1309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1310"><a href="#cb1-1310" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SlicePlaneOperator(Operator):</span>
<span id="cb1-1311"><a href="#cb1-1311" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a slice plane along the selected axis with texture from 3D data"""</span></span>
<span id="cb1-1312"><a href="#cb1-1312" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.create_slice_plane"</span></span>
<span id="cb1-1313"><a href="#cb1-1313" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Create Slice Plane"</span></span>
<span id="cb1-1314"><a href="#cb1-1314" aria-hidden="true" tabindex="-1"></a>    bl_options <span class="op">=</span> {<span class="st">'REGISTER'</span>, <span class="st">'UNDO'</span>}</span>
<span id="cb1-1315"><a href="#cb1-1315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1316"><a href="#cb1-1316" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1317"><a href="#cb1-1317" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the 3D data array from the selected box</span></span>
<span id="cb1-1318"><a href="#cb1-1318" aria-hidden="true" tabindex="-1"></a>        box <span class="op">=</span> context.active_object</span>
<span id="cb1-1319"><a href="#cb1-1319" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> box <span class="kw">or</span> <span class="kw">not</span> <span class="st">"3D_data"</span> <span class="kw">in</span> box:</span>
<span id="cb1-1320"><a href="#cb1-1320" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Select exactly a 3D image (BoundingBox)!"</span>)</span>
<span id="cb1-1321"><a href="#cb1-1321" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1322"><a href="#cb1-1322" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> get_numpy_attribute(box, <span class="st">"3D_data"</span>)</span>
<span id="cb1-1323"><a href="#cb1-1323" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1324"><a href="#cb1-1324" aria-hidden="true" tabindex="-1"></a>        resolution <span class="op">=</span> get_numpy_attribute(box, <span class="st">"resolution"</span>)</span>
<span id="cb1-1325"><a href="#cb1-1325" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(data, np.ndarray) <span class="kw">or</span> data.ndim <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb1-1326"><a href="#cb1-1326" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Invalid 3D data array."</span>)</span>
<span id="cb1-1327"><a href="#cb1-1327" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1328"><a href="#cb1-1328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> context.scene.tissue_cartography_slice_channel <span class="op">&gt;=</span> data.shape[<span class="dv">0</span>]:</span>
<span id="cb1-1329"><a href="#cb1-1329" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Channel </span><span class="sc">{</span>context<span class="sc">.</span>scene<span class="sc">.</span>tissue_cartography_slice_channel<span class="sc">}</span><span class="ss"> is out of bounds for the data array."</span>)</span>
<span id="cb1-1330"><a href="#cb1-1330" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1331"><a href="#cb1-1331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1332"><a href="#cb1-1332" aria-hidden="true" tabindex="-1"></a>        length, width, height <span class="op">=</span> (np.array(data.shape[<span class="dv">1</span>:]) <span class="op">*</span> resolution)</span>
<span id="cb1-1333"><a href="#cb1-1333" aria-hidden="true" tabindex="-1"></a>        slice_plane <span class="op">=</span> create_slice_plane(length, width, height, axis<span class="op">=</span>context.scene.tissue_cartography_slice_axis,</span>
<span id="cb1-1334"><a href="#cb1-1334" aria-hidden="true" tabindex="-1"></a>                                         position<span class="op">=</span>context.scene.tissue_cartography_slice_position)</span>
<span id="cb1-1335"><a href="#cb1-1335" aria-hidden="true" tabindex="-1"></a>        slice_plane.name <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>slice_plane<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>box<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb1-1336"><a href="#cb1-1336" aria-hidden="true" tabindex="-1"></a>        <span class="co"># set matrix world</span></span>
<span id="cb1-1337"><a href="#cb1-1337" aria-hidden="true" tabindex="-1"></a>        slice_plane.matrix_world <span class="op">=</span> box.matrix_world</span>
<span id="cb1-1338"><a href="#cb1-1338" aria-hidden="true" tabindex="-1"></a>                                         </span>
<span id="cb1-1339"><a href="#cb1-1339" aria-hidden="true" tabindex="-1"></a>        slice_img <span class="op">=</span> get_slice_image(data, resolution, axis<span class="op">=</span>context.scene.tissue_cartography_slice_axis,</span>
<span id="cb1-1340"><a href="#cb1-1340" aria-hidden="true" tabindex="-1"></a>                                    position<span class="op">=</span>context.scene.tissue_cartography_slice_position)</span>
<span id="cb1-1341"><a href="#cb1-1341" aria-hidden="true" tabindex="-1"></a>        slice_img <span class="op">=</span> normalize_quantiles(slice_img, quantiles<span class="op">=</span>(<span class="fl">0.01</span>, <span class="fl">0.99</span>),</span>
<span id="cb1-1342"><a href="#cb1-1342" aria-hidden="true" tabindex="-1"></a>                                        channel_axis<span class="op">=</span><span class="dv">0</span>, clip<span class="op">=</span><span class="va">True</span>, data_type<span class="op">=</span><span class="va">None</span>)     </span>
<span id="cb1-1343"><a href="#cb1-1343" aria-hidden="true" tabindex="-1"></a>        create_material_from_array(slice_plane, slice_img[context.scene.tissue_cartography_slice_channel], material_name<span class="op">=</span><span class="ss">f"SliceMaterial_</span><span class="sc">{</span>box<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>context<span class="sc">.</span>scene<span class="sc">.</span>tissue_cartography_slice_axis<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>context<span class="sc">.</span>scene<span class="sc">.</span>tissue_cartography_slice_position<span class="sc">}</span><span class="ss">"</span>)  </span>
<span id="cb1-1344"><a href="#cb1-1344" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1345"><a href="#cb1-1345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1346"><a href="#cb1-1346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1347"><a href="#cb1-1347" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VertexShaderInitializeOperator(Operator):</span>
<span id="cb1-1348"><a href="#cb1-1348" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Initialize vertex shader for a selected mesh. Colors mesh vertices according to </span></span>
<span id="cb1-1349"><a href="#cb1-1349" aria-hidden="true" tabindex="-1"></a><span class="co">    3D image intensity from selected BoundingBox."""</span></span>
<span id="cb1-1350"><a href="#cb1-1350" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.initialize_vertex_shader"</span></span>
<span id="cb1-1351"><a href="#cb1-1351" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Initialize Vertex Shader"</span></span>
<span id="cb1-1352"><a href="#cb1-1352" aria-hidden="true" tabindex="-1"></a>    bl_options <span class="op">=</span> {<span class="st">'REGISTER'</span>, <span class="st">'UNDO'</span>}</span>
<span id="cb1-1353"><a href="#cb1-1353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1354"><a href="#cb1-1354" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1355"><a href="#cb1-1355" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create global dict to hold interpolator objects</span></span>
<span id="cb1-1356"><a href="#cb1-1356" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(bpy.types.Scene, <span class="st">"tissue_cartography_interpolators"</span>):</span>
<span id="cb1-1357"><a href="#cb1-1357" aria-hidden="true" tabindex="-1"></a>            bpy.types.Scene.tissue_cartography_interpolators <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb1-1358"><a href="#cb1-1358" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get the selected mesh and bounding box</span></span>
<span id="cb1-1359"><a href="#cb1-1359" aria-hidden="true" tabindex="-1"></a>        box, obj <span class="op">=</span> separate_selected_into_mesh_and_box(<span class="va">self</span>, context)</span>
<span id="cb1-1360"><a href="#cb1-1360" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> box <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> obj <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-1361"><a href="#cb1-1361" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1362"><a href="#cb1-1362" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the 3D data array from the box object</span></span>
<span id="cb1-1363"><a href="#cb1-1363" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> get_numpy_attribute(box, <span class="st">"3D_data"</span>)</span>
<span id="cb1-1364"><a href="#cb1-1364" aria-hidden="true" tabindex="-1"></a>        resolution <span class="op">=</span> get_numpy_attribute(box, <span class="st">"resolution"</span>)</span>
<span id="cb1-1365"><a href="#cb1-1365" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb1-1366"><a href="#cb1-1366" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(data, np.ndarray) <span class="kw">or</span> data.ndim <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb1-1367"><a href="#cb1-1367" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Invalid 3D data array."</span>)</span>
<span id="cb1-1368"><a href="#cb1-1368" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1369"><a href="#cb1-1369" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> obj <span class="kw">or</span> obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-1370"><a href="#cb1-1370" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"No mesh object selected!"</span>)</span>
<span id="cb1-1371"><a href="#cb1-1371" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1372"><a href="#cb1-1372" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> context.scene.tissue_cartography_vertex_shader_channel <span class="op">&gt;=</span> data.shape[<span class="dv">0</span>]:</span>
<span id="cb1-1373"><a href="#cb1-1373" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Channel </span><span class="sc">{</span>context<span class="sc">.</span>scene<span class="sc">.</span>tissue_cartography_vertex_shader_channel<span class="sc">}</span><span class="ss"> is out of bounds for the data array."</span>)</span>
<span id="cb1-1374"><a href="#cb1-1374" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1375"><a href="#cb1-1375" aria-hidden="true" tabindex="-1"></a>        <span class="co"># need to compute coordinates relative to matrix_world of box I think</span></span>
<span id="cb1-1376"><a href="#cb1-1376" aria-hidden="true" tabindex="-1"></a>        set_numpy_attribute(obj, <span class="st">"box_world_inv_vertex_shader"</span>,</span>
<span id="cb1-1377"><a href="#cb1-1377" aria-hidden="true" tabindex="-1"></a>                            np.array(box.matrix_world.inverted()))</span>
<span id="cb1-1378"><a href="#cb1-1378" aria-hidden="true" tabindex="-1"></a>        bpy.types.Scene.tissue_cartography_interpolators[obj.name] <span class="op">=</span> get_image_to_vertex_interpolator(obj, data, resolution)</span>
<span id="cb1-1379"><a href="#cb1-1379" aria-hidden="true" tabindex="-1"></a>        box_inv <span class="op">=</span> mathutils.Matrix(get_numpy_attribute(obj, </span>
<span id="cb1-1380"><a href="#cb1-1380" aria-hidden="true" tabindex="-1"></a>                                   <span class="st">"box_world_inv_vertex_shader"</span>))</span>
<span id="cb1-1381"><a href="#cb1-1381" aria-hidden="true" tabindex="-1"></a>        positions <span class="op">=</span> np.array([box_inv<span class="op">@</span>obj.matrix_world<span class="op">@</span>(v.co <span class="op">+</span> context.scene.tissue_cartography_vertex_shader_offset<span class="op">*</span>v.normal)</span>
<span id="cb1-1382"><a href="#cb1-1382" aria-hidden="true" tabindex="-1"></a>                              <span class="cf">for</span> v <span class="kw">in</span> obj.data.vertices])</span>
<span id="cb1-1383"><a href="#cb1-1383" aria-hidden="true" tabindex="-1"></a>        intensities <span class="op">=</span> bpy.types.Scene.tissue_cartography_interpolators[obj.name][context.scene.tissue_cartography_vertex_shader_channel](positions)</span>
<span id="cb1-1384"><a href="#cb1-1384" aria-hidden="true" tabindex="-1"></a>        colors <span class="op">=</span> np.stack(<span class="dv">3</span><span class="op">*</span>[intensities,], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-1385"><a href="#cb1-1385" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1386"><a href="#cb1-1386" aria-hidden="true" tabindex="-1"></a>        assign_vertex_colors(obj, colors)</span>
<span id="cb1-1387"><a href="#cb1-1387" aria-hidden="true" tabindex="-1"></a>        create_vertex_color_material(obj, material_name<span class="op">=</span><span class="ss">f"VertexColorMaterial_</span><span class="sc">{</span>obj<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1388"><a href="#cb1-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1389"><a href="#cb1-1389" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1390"><a href="#cb1-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1391"><a href="#cb1-1391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1392"><a href="#cb1-1392" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VertexShaderRefreshOperator(Operator):</span>
<span id="cb1-1393"><a href="#cb1-1393" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Refresh vertex colors for a selected mesh. Colors mesh vertices according to </span></span>
<span id="cb1-1394"><a href="#cb1-1394" aria-hidden="true" tabindex="-1"></a><span class="co">    3D image intensity."""</span></span>
<span id="cb1-1395"><a href="#cb1-1395" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.refresh_vertex_shader"</span></span>
<span id="cb1-1396"><a href="#cb1-1396" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Refresh Vertex Shader"</span></span>
<span id="cb1-1397"><a href="#cb1-1397" aria-hidden="true" tabindex="-1"></a>    bl_options <span class="op">=</span> {<span class="st">'REGISTER'</span>, <span class="st">'UNDO'</span>}</span>
<span id="cb1-1398"><a href="#cb1-1398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1399"><a href="#cb1-1399" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1400"><a href="#cb1-1400" aria-hidden="true" tabindex="-1"></a>        obj <span class="op">=</span> context.active_object</span>
<span id="cb1-1401"><a href="#cb1-1401" aria-hidden="true" tabindex="-1"></a>        interpolator_dict <span class="op">=</span> <span class="bu">getattr</span>(context.scene, <span class="st">"tissue_cartography_interpolators"</span>)</span>
<span id="cb1-1402"><a href="#cb1-1402" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> obj <span class="kw">or</span> obj.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-1403"><a href="#cb1-1403" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"No mesh object selected!"</span>)</span>
<span id="cb1-1404"><a href="#cb1-1404" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1405"><a href="#cb1-1405" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> interpolator_dict <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> obj.name <span class="kw">not</span> <span class="kw">in</span> interpolator_dict:</span>
<span id="cb1-1406"><a href="#cb1-1406" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Vertex shader not initialized."</span>)</span>
<span id="cb1-1407"><a href="#cb1-1407" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1408"><a href="#cb1-1408" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> context.scene.tissue_cartography_vertex_shader_channel <span class="op">&gt;=</span> <span class="bu">len</span>(interpolator_dict[obj.name]):</span>
<span id="cb1-1409"><a href="#cb1-1409" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="ss">f"Channel </span><span class="sc">{</span>context<span class="sc">.</span>scene<span class="sc">.</span>tissue_cartography_vertex_shader_channel<span class="sc">}</span><span class="ss"> is out of bounds for the data array."</span>)</span>
<span id="cb1-1410"><a href="#cb1-1410" aria-hidden="true" tabindex="-1"></a>        box_inv <span class="op">=</span> mathutils.Matrix(get_numpy_attribute(obj, <span class="st">"box_world_inv_vertex_shader"</span>))</span>
<span id="cb1-1411"><a href="#cb1-1411" aria-hidden="true" tabindex="-1"></a>        positions <span class="op">=</span> np.array([box_inv<span class="op">@</span>obj.matrix_world<span class="op">@</span>(v.co <span class="op">+</span> context.scene.tissue_cartography_vertex_shader_offset<span class="op">*</span>v.normal)</span>
<span id="cb1-1412"><a href="#cb1-1412" aria-hidden="true" tabindex="-1"></a>                              <span class="cf">for</span> v <span class="kw">in</span> obj.data.vertices])</span>
<span id="cb1-1413"><a href="#cb1-1413" aria-hidden="true" tabindex="-1"></a>        intensities <span class="op">=</span> interpolator_dict[obj.name][context.scene.tissue_cartography_vertex_shader_channel](positions)</span>
<span id="cb1-1414"><a href="#cb1-1414" aria-hidden="true" tabindex="-1"></a>        colors <span class="op">=</span> np.stack(<span class="dv">3</span><span class="op">*</span>[intensities,], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-1415"><a href="#cb1-1415" aria-hidden="true" tabindex="-1"></a>        assign_vertex_colors(obj, colors)</span>
<span id="cb1-1416"><a href="#cb1-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1417"><a href="#cb1-1417" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1418"><a href="#cb1-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1419"><a href="#cb1-1419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1420"><a href="#cb1-1420" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AlignOperator(Operator):</span>
<span id="cb1-1421"><a href="#cb1-1421" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Align active and selected meshes by rotation, translation, and scaling."""</span></span>
<span id="cb1-1422"><a href="#cb1-1422" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.align"</span></span>
<span id="cb1-1423"><a href="#cb1-1423" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Align Selected To Active Mesh"</span></span>
<span id="cb1-1424"><a href="#cb1-1424" aria-hidden="true" tabindex="-1"></a>    bl_options <span class="op">=</span> {<span class="st">'REGISTER'</span>, <span class="st">'UNDO'</span>}</span>
<span id="cb1-1425"><a href="#cb1-1425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1426"><a href="#cb1-1426" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1427"><a href="#cb1-1427" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1428"><a href="#cb1-1428" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> context.scene.tissue_cartography_align_type <span class="op">==</span> <span class="st">"selected"</span>:</span>
<span id="cb1-1429"><a href="#cb1-1429" aria-hidden="true" tabindex="-1"></a>            target_mesh <span class="op">=</span> context.active_object</span>
<span id="cb1-1430"><a href="#cb1-1430" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> source_mesh <span class="kw">in</span> [x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="kw">not</span> x<span class="op">==</span>target_mesh]:</span>
<span id="cb1-1431"><a href="#cb1-1431" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Aligning: </span><span class="sc">{</span>source_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss"> to </span><span class="sc">{</span>target_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1432"><a href="#cb1-1432" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>  <span class="kw">or</span> source_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-1433"><a href="#cb1-1433" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected object(s) is not a mesh."</span>)</span>
<span id="cb1-1434"><a href="#cb1-1434" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1435"><a href="#cb1-1435" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get the 3D coordinates from the meshes</span></span>
<span id="cb1-1436"><a href="#cb1-1436" aria-hidden="true" tabindex="-1"></a>                target <span class="op">=</span> np.array([target_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> target_mesh.data.vertices])</span>
<span id="cb1-1437"><a href="#cb1-1437" aria-hidden="true" tabindex="-1"></a>                source <span class="op">=</span> np.array([source_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> source_mesh.data.vertices])</span>
<span id="cb1-1438"><a href="#cb1-1438" aria-hidden="true" tabindex="-1"></a>                trafo_matrix <span class="op">=</span> combined_alignment(source, target,</span>
<span id="cb1-1439"><a href="#cb1-1439" aria-hidden="true" tabindex="-1"></a>                                                  pre_align<span class="op">=</span>context.scene.tissue_cartography_prealign,</span>
<span id="cb1-1440"><a href="#cb1-1440" aria-hidden="true" tabindex="-1"></a>                                                  shear<span class="op">=</span>context.scene.tissue_cartography_prealign_shear,</span>
<span id="cb1-1441"><a href="#cb1-1441" aria-hidden="true" tabindex="-1"></a>                                                  iterations<span class="op">=</span>context.scene.tissue_cartography_align_iter)</span>
<span id="cb1-1442"><a href="#cb1-1442" aria-hidden="true" tabindex="-1"></a>                source_mesh.matrix_world <span class="op">=</span> mathutils.Matrix(trafo_matrix)<span class="op">@</span> source_mesh.matrix_world</span>
<span id="cb1-1443"><a href="#cb1-1443" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> context.scene.tissue_cartography_align_type <span class="op">==</span> <span class="st">"active"</span>:</span>
<span id="cb1-1444"><a href="#cb1-1444" aria-hidden="true" tabindex="-1"></a>            source_mesh <span class="op">=</span> context.active_object</span>
<span id="cb1-1445"><a href="#cb1-1445" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> target_mesh <span class="kw">in</span> [x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="kw">not</span> x<span class="op">==</span>source_mesh]:</span>
<span id="cb1-1446"><a href="#cb1-1446" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Aligning: </span><span class="sc">{</span>source_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss"> to </span><span class="sc">{</span>target_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1447"><a href="#cb1-1447" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>  <span class="kw">or</span> source_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-1448"><a href="#cb1-1448" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected object(s) is not a mesh."</span>)</span>
<span id="cb1-1449"><a href="#cb1-1449" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1450"><a href="#cb1-1450" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get the 3D coordinates from the meshes and compute alignment</span></span>
<span id="cb1-1451"><a href="#cb1-1451" aria-hidden="true" tabindex="-1"></a>                target <span class="op">=</span> np.array([target_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> target_mesh.data.vertices])</span>
<span id="cb1-1452"><a href="#cb1-1452" aria-hidden="true" tabindex="-1"></a>                source <span class="op">=</span> np.array([source_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> source_mesh.data.vertices])</span>
<span id="cb1-1453"><a href="#cb1-1453" aria-hidden="true" tabindex="-1"></a>                trafo_matrix <span class="op">=</span> combined_alignment(source, target,</span>
<span id="cb1-1454"><a href="#cb1-1454" aria-hidden="true" tabindex="-1"></a>                                                  pre_align<span class="op">=</span>context.scene.tissue_cartography_prealign,</span>
<span id="cb1-1455"><a href="#cb1-1455" aria-hidden="true" tabindex="-1"></a>                                                  shear<span class="op">=</span>context.scene.tissue_cartography_prealign_shear,</span>
<span id="cb1-1456"><a href="#cb1-1456" aria-hidden="true" tabindex="-1"></a>                                                  iterations<span class="op">=</span>context.scene.tissue_cartography_align_iter)</span>
<span id="cb1-1457"><a href="#cb1-1457" aria-hidden="true" tabindex="-1"></a>                <span class="co"># copy source mesh</span></span>
<span id="cb1-1458"><a href="#cb1-1458" aria-hidden="true" tabindex="-1"></a>                source_mesh_copied <span class="op">=</span> source_mesh.copy()</span>
<span id="cb1-1459"><a href="#cb1-1459" aria-hidden="true" tabindex="-1"></a>                source_mesh_copied.data <span class="op">=</span> source_mesh.data.copy()</span>
<span id="cb1-1460"><a href="#cb1-1460" aria-hidden="true" tabindex="-1"></a>                bpy.context.collection.objects.link(source_mesh_copied)</span>
<span id="cb1-1461"><a href="#cb1-1461" aria-hidden="true" tabindex="-1"></a>                source_mesh_copied.name <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>target_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_aligned"</span> </span>
<span id="cb1-1462"><a href="#cb1-1462" aria-hidden="true" tabindex="-1"></a>                source_mesh_copied.matrix_world <span class="op">=</span> mathutils.Matrix(trafo_matrix)<span class="op">@</span> source_mesh.matrix_world</span>
<span id="cb1-1463"><a href="#cb1-1463" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1464"><a href="#cb1-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1465"><a href="#cb1-1465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1466"><a href="#cb1-1466" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ShrinkwrapOperator(Operator):</span>
<span id="cb1-1467"><a href="#cb1-1467" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Copy and shrink-wrap active mesh to selected meshes."""</span></span>
<span id="cb1-1468"><a href="#cb1-1468" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.shrinkwrap"</span></span>
<span id="cb1-1469"><a href="#cb1-1469" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Shrink-Wrap Active to Selected"</span></span>
<span id="cb1-1470"><a href="#cb1-1470" aria-hidden="true" tabindex="-1"></a>    bl_options <span class="op">=</span> {<span class="st">'REGISTER'</span>, <span class="st">'UNDO'</span>}</span>
<span id="cb1-1471"><a href="#cb1-1471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1472"><a href="#cb1-1472" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1473"><a href="#cb1-1473" aria-hidden="true" tabindex="-1"></a>        mode <span class="op">=</span> context.scene.tissue_cartography_shrinkwarp_iterative</span>
<span id="cb1-1474"><a href="#cb1-1474" aria-hidden="true" tabindex="-1"></a>        source_mesh <span class="op">=</span> context.active_object</span>
<span id="cb1-1475"><a href="#cb1-1475" aria-hidden="true" tabindex="-1"></a>        targets <span class="op">=</span> <span class="bu">sorted</span>([x <span class="cf">for</span> x <span class="kw">in</span> context.selected_objects <span class="cf">if</span> <span class="kw">not</span> x<span class="op">==</span>source_mesh], key<span class="op">=</span><span class="kw">lambda</span> x: x.name)</span>
<span id="cb1-1476"><a href="#cb1-1476" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mode <span class="op">==</span> <span class="st">"backward"</span>:</span>
<span id="cb1-1477"><a href="#cb1-1477" aria-hidden="true" tabindex="-1"></a>            targets <span class="op">=</span> targets[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-1478"><a href="#cb1-1478" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> target_mesh <span class="kw">in</span> targets:</span>
<span id="cb1-1479"><a href="#cb1-1479" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.report({<span class="st">'INFO'</span>}, <span class="ss">f"Aligning: </span><span class="sc">{</span>source_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss"> to </span><span class="sc">{</span>target_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1480"><a href="#cb1-1480" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> target_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>  <span class="kw">or</span> source_mesh.<span class="bu">type</span> <span class="op">!=</span> <span class="st">'MESH'</span>:</span>
<span id="cb1-1481"><a href="#cb1-1481" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.report({<span class="st">'ERROR'</span>}, <span class="st">"Selected object(s) is not a mesh."</span>)</span>
<span id="cb1-1482"><a href="#cb1-1482" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> {<span class="st">'CANCELLED'</span>}</span>
<span id="cb1-1483"><a href="#cb1-1483" aria-hidden="true" tabindex="-1"></a>            <span class="co"># rigid alignment</span></span>
<span id="cb1-1484"><a href="#cb1-1484" aria-hidden="true" tabindex="-1"></a>            target <span class="op">=</span> np.array([target_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> target_mesh.data.vertices])</span>
<span id="cb1-1485"><a href="#cb1-1485" aria-hidden="true" tabindex="-1"></a>            source <span class="op">=</span> np.array([source_mesh.matrix_world<span class="op">@</span>v.co <span class="cf">for</span> v <span class="kw">in</span> source_mesh.data.vertices])</span>
<span id="cb1-1486"><a href="#cb1-1486" aria-hidden="true" tabindex="-1"></a>            trafo_matrix <span class="op">=</span> combined_alignment(source, target,</span>
<span id="cb1-1487"><a href="#cb1-1487" aria-hidden="true" tabindex="-1"></a>                                              pre_align<span class="op">=</span>context.scene.tissue_cartography_prealign,</span>
<span id="cb1-1488"><a href="#cb1-1488" aria-hidden="true" tabindex="-1"></a>                                              shear<span class="op">=</span>context.scene.tissue_cartography_prealign_shear,</span>
<span id="cb1-1489"><a href="#cb1-1489" aria-hidden="true" tabindex="-1"></a>                                              iterations<span class="op">=</span>context.scene.tissue_cartography_align_iter)</span>
<span id="cb1-1490"><a href="#cb1-1490" aria-hidden="true" tabindex="-1"></a>            <span class="co"># copy source mesh</span></span>
<span id="cb1-1491"><a href="#cb1-1491" aria-hidden="true" tabindex="-1"></a>            source_mesh_copied <span class="op">=</span> source_mesh.copy()</span>
<span id="cb1-1492"><a href="#cb1-1492" aria-hidden="true" tabindex="-1"></a>            source_mesh_copied.data <span class="op">=</span> source_mesh.data.copy()</span>
<span id="cb1-1493"><a href="#cb1-1493" aria-hidden="true" tabindex="-1"></a>            bpy.context.collection.objects.link(source_mesh_copied)</span>
<span id="cb1-1494"><a href="#cb1-1494" aria-hidden="true" tabindex="-1"></a>            source_mesh_copied.matrix_world <span class="op">=</span> mathutils.Matrix(trafo_matrix)<span class="op">@</span> source_mesh.matrix_world</span>
<span id="cb1-1495"><a href="#cb1-1495" aria-hidden="true" tabindex="-1"></a>            source_mesh_copied.name <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>target_mesh<span class="sc">.</span>name<span class="sc">}</span><span class="ss">_wrapped"</span> </span>
<span id="cb1-1496"><a href="#cb1-1496" aria-hidden="true" tabindex="-1"></a>            <span class="co"># shrink-wrap</span></span>
<span id="cb1-1497"><a href="#cb1-1497" aria-hidden="true" tabindex="-1"></a>            shrinkwrap_and_smooth(source_mesh_copied, target_mesh,</span>
<span id="cb1-1498"><a href="#cb1-1498" aria-hidden="true" tabindex="-1"></a>                                  corrective_smooth_iter<span class="op">=</span>context.scene.tissue_cartography_shrinkwarp_smooth)</span>
<span id="cb1-1499"><a href="#cb1-1499" aria-hidden="true" tabindex="-1"></a>            <span class="co"># data transfer modifier to copy UV map from wrapped to target</span></span>
<span id="cb1-1500"><a href="#cb1-1500" aria-hidden="true" tabindex="-1"></a>            data_transfer <span class="op">=</span> target_mesh.modifiers.new(name<span class="op">=</span><span class="st">"DataTransfer"</span>, <span class="bu">type</span><span class="op">=</span><span class="st">'DATA_TRANSFER'</span>)</span>
<span id="cb1-1501"><a href="#cb1-1501" aria-hidden="true" tabindex="-1"></a>            data_transfer.<span class="bu">object</span> <span class="op">=</span> source_mesh_copied</span>
<span id="cb1-1502"><a href="#cb1-1502" aria-hidden="true" tabindex="-1"></a>            data_transfer.use_loop_data <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-1503"><a href="#cb1-1503" aria-hidden="true" tabindex="-1"></a>            data_transfer.data_types_loops <span class="op">=</span> {<span class="st">'UV'</span>}</span>
<span id="cb1-1504"><a href="#cb1-1504" aria-hidden="true" tabindex="-1"></a>            data_transfer.loop_mapping <span class="op">=</span> <span class="st">'POLYINTERP_NEAREST'</span></span>
<span id="cb1-1505"><a href="#cb1-1505" aria-hidden="true" tabindex="-1"></a>            <span class="co"># apply</span></span>
<span id="cb1-1506"><a href="#cb1-1506" aria-hidden="true" tabindex="-1"></a>            original_active_obj <span class="op">=</span> bpy.context.view_layer.objects.active</span>
<span id="cb1-1507"><a href="#cb1-1507" aria-hidden="true" tabindex="-1"></a>            bpy.context.view_layer.objects.active <span class="op">=</span> target_mesh</span>
<span id="cb1-1508"><a href="#cb1-1508" aria-hidden="true" tabindex="-1"></a>            bpy.ops.<span class="bu">object</span>.datalayout_transfer(modifier<span class="op">=</span><span class="st">"DataTransfer"</span>)</span>
<span id="cb1-1509"><a href="#cb1-1509" aria-hidden="true" tabindex="-1"></a>            bpy.ops.<span class="bu">object</span>.modifier_apply(modifier<span class="op">=</span><span class="st">"DataTransfer"</span>)</span>
<span id="cb1-1510"><a href="#cb1-1510" aria-hidden="true" tabindex="-1"></a>            bpy.context.view_layer.objects.active <span class="op">=</span> original_active_obj</span>
<span id="cb1-1511"><a href="#cb1-1511" aria-hidden="true" tabindex="-1"></a>                                  </span>
<span id="cb1-1512"><a href="#cb1-1512" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> mode <span class="kw">in</span> [<span class="st">"forward"</span>, <span class="st">"backward"</span>]:</span>
<span id="cb1-1513"><a href="#cb1-1513" aria-hidden="true" tabindex="-1"></a>                source_mesh <span class="op">=</span> source_mesh_copied</span>
<span id="cb1-1514"><a href="#cb1-1514" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1515"><a href="#cb1-1515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1516"><a href="#cb1-1516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1517"><a href="#cb1-1517" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HelpPopupOperator(Operator):</span>
<span id="cb1-1518"><a href="#cb1-1518" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Open help window."""</span></span>
<span id="cb1-1519"><a href="#cb1-1519" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"scene.help_popup"</span></span>
<span id="cb1-1520"><a href="#cb1-1520" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Tissue Cartography Help"</span></span>
<span id="cb1-1521"><a href="#cb1-1521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1522"><a href="#cb1-1522" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, context):</span>
<span id="cb1-1523"><a href="#cb1-1523" aria-hidden="true" tabindex="-1"></a>        url <span class="op">=</span> <span class="st">"https://nikolas-claussen.github.io/blender-tissue-cartography/Tutorials/03_blender_addon_tutorial.html"</span></span>
<span id="cb1-1524"><a href="#cb1-1524" aria-hidden="true" tabindex="-1"></a>        bpy.ops.wm.url_open(url<span class="op">=</span>url)</span>
<span id="cb1-1525"><a href="#cb1-1525" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'FINISHED'</span>}</span>
<span id="cb1-1526"><a href="#cb1-1526" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1527"><a href="#cb1-1527" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1528"><a href="#cb1-1528" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TissueCartographyPanel(Panel):</span>
<span id="cb1-1529"><a href="#cb1-1529" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Class defining layout of user interface (buttons, inputs, etc.)"""</span></span>
<span id="cb1-1530"><a href="#cb1-1530" aria-hidden="true" tabindex="-1"></a>    bl_label <span class="op">=</span> <span class="st">"Tissue Cartography"</span></span>
<span id="cb1-1531"><a href="#cb1-1531" aria-hidden="true" tabindex="-1"></a>    bl_idname <span class="op">=</span> <span class="st">"SCENE_PT_tissue_cartography"</span></span>
<span id="cb1-1532"><a href="#cb1-1532" aria-hidden="true" tabindex="-1"></a>    bl_space_type <span class="op">=</span> <span class="st">'PROPERTIES'</span></span>
<span id="cb1-1533"><a href="#cb1-1533" aria-hidden="true" tabindex="-1"></a>    bl_region_type <span class="op">=</span> <span class="st">'WINDOW'</span></span>
<span id="cb1-1534"><a href="#cb1-1534" aria-hidden="true" tabindex="-1"></a>    bl_context <span class="op">=</span> <span class="st">"scene"</span></span>
<span id="cb1-1535"><a href="#cb1-1535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1536"><a href="#cb1-1536" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, context):</span>
<span id="cb1-1537"><a href="#cb1-1537" aria-hidden="true" tabindex="-1"></a>        layout <span class="op">=</span> <span class="va">self</span>.layout</span>
<span id="cb1-1538"><a href="#cb1-1538" aria-hidden="true" tabindex="-1"></a>        scene <span class="op">=</span> context.scene</span>
<span id="cb1-1539"><a href="#cb1-1539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1540"><a href="#cb1-1540" aria-hidden="true" tabindex="-1"></a>        layout.prop(scene, <span class="st">"tissue_cartography_file"</span>)</span>
<span id="cb1-1541"><a href="#cb1-1541" aria-hidden="true" tabindex="-1"></a>        row_tiff <span class="op">=</span> layout.row()</span>
<span id="cb1-1542"><a href="#cb1-1542" aria-hidden="true" tabindex="-1"></a>        row_tiff.prop(scene, <span class="st">"tissue_cartography_resolution"</span>)</span>
<span id="cb1-1543"><a href="#cb1-1543" aria-hidden="true" tabindex="-1"></a>        row_tiff.prop(scene, <span class="st">"tissue_cartography_axis_order"</span>)</span>
<span id="cb1-1544"><a href="#cb1-1544" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.load_tiff"</span>, text<span class="op">=</span><span class="st">"Load .tiff file"</span>)</span>
<span id="cb1-1545"><a href="#cb1-1545" aria-hidden="true" tabindex="-1"></a>        layout.label(text<span class="op">=</span><span class="ss">f"Loaded Image Shape: </span><span class="sc">{</span>scene<span class="sc">.</span>tissue_cartography_image_shape<span class="sc">}</span><span class="ss">. Loaded Image Channels: </span><span class="sc">{</span>scene<span class="sc">.</span>tissue_cartography_image_channels<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1546"><a href="#cb1-1546" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1547"><a href="#cb1-1547" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1548"><a href="#cb1-1548" aria-hidden="true" tabindex="-1"></a>        layout.prop(scene, <span class="st">"tissue_cartography_segmentation_file"</span>)</span>
<span id="cb1-1549"><a href="#cb1-1549" aria-hidden="true" tabindex="-1"></a>        row_segmentation <span class="op">=</span> layout.row()</span>
<span id="cb1-1550"><a href="#cb1-1550" aria-hidden="true" tabindex="-1"></a>        row_segmentation.prop(scene, <span class="st">"tissue_cartography_segmentation_resolution"</span>)</span>
<span id="cb1-1551"><a href="#cb1-1551" aria-hidden="true" tabindex="-1"></a>        row_segmentation.prop(scene, <span class="st">"tissue_cartography_segmentation_axis_order"</span>)</span>
<span id="cb1-1552"><a href="#cb1-1552" aria-hidden="true" tabindex="-1"></a>        row_segmentation.prop(scene, <span class="st">"tissue_cartography_segmentation_sigma"</span>)</span>
<span id="cb1-1553"><a href="#cb1-1553" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.load_segmentation"</span>, text<span class="op">=</span><span class="st">"Get mesh(es) from binary segmentation .tiff file(s)"</span>)</span>
<span id="cb1-1554"><a href="#cb1-1554" aria-hidden="true" tabindex="-1"></a>        layout.label(text<span class="op">=</span><span class="ss">f"Loaded Segmentation Shape: </span><span class="sc">{</span>scene<span class="sc">.</span>tissue_cartography_segmentation_shape<span class="sc">}</span><span class="ss">. Loaded Segmentation Channels: </span><span class="sc">{</span>scene<span class="sc">.</span>tissue_cartography_segmentation_channels<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-1555"><a href="#cb1-1555" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1556"><a href="#cb1-1556" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1557"><a href="#cb1-1557" aria-hidden="true" tabindex="-1"></a>        row_slice <span class="op">=</span> layout.row()</span>
<span id="cb1-1558"><a href="#cb1-1558" aria-hidden="true" tabindex="-1"></a>        row_slice.prop(scene, <span class="st">"tissue_cartography_slice_axis"</span>)</span>
<span id="cb1-1559"><a href="#cb1-1559" aria-hidden="true" tabindex="-1"></a>        row_slice.prop(scene, <span class="st">"tissue_cartography_slice_position"</span>)</span>
<span id="cb1-1560"><a href="#cb1-1560" aria-hidden="true" tabindex="-1"></a>        row_slice.prop(scene, <span class="st">"tissue_cartography_slice_channel"</span>)</span>
<span id="cb1-1561"><a href="#cb1-1561" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.create_slice_plane"</span>, text<span class="op">=</span><span class="st">"Create slice plane"</span>)</span>
<span id="cb1-1562"><a href="#cb1-1562" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1563"><a href="#cb1-1563" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1564"><a href="#cb1-1564" aria-hidden="true" tabindex="-1"></a>        row_vertex <span class="op">=</span> layout.row()</span>
<span id="cb1-1565"><a href="#cb1-1565" aria-hidden="true" tabindex="-1"></a>        row_vertex.prop(scene, <span class="st">"tissue_cartography_vertex_shader_offset"</span>)</span>
<span id="cb1-1566"><a href="#cb1-1566" aria-hidden="true" tabindex="-1"></a>        row_vertex.prop(scene, <span class="st">"tissue_cartography_vertex_shader_channel"</span>)</span>
<span id="cb1-1567"><a href="#cb1-1567" aria-hidden="true" tabindex="-1"></a>        row_vertex2 <span class="op">=</span> layout.row()</span>
<span id="cb1-1568"><a href="#cb1-1568" aria-hidden="true" tabindex="-1"></a>        row_vertex2.operator(<span class="st">"scene.initialize_vertex_shader"</span>, text<span class="op">=</span><span class="st">"Initialize vertex shading"</span>)</span>
<span id="cb1-1569"><a href="#cb1-1569" aria-hidden="true" tabindex="-1"></a>        row_vertex2.operator(<span class="st">"scene.refresh_vertex_shader"</span>, text<span class="op">=</span><span class="st">"Refresh vertex shading"</span>)</span>
<span id="cb1-1570"><a href="#cb1-1570" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1571"><a href="#cb1-1571" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1572"><a href="#cb1-1572" aria-hidden="true" tabindex="-1"></a>        row_projection <span class="op">=</span> layout.row()</span>
<span id="cb1-1573"><a href="#cb1-1573" aria-hidden="true" tabindex="-1"></a>        row_projection.prop(scene, <span class="st">"tissue_cartography_offsets"</span>)</span>
<span id="cb1-1574"><a href="#cb1-1574" aria-hidden="true" tabindex="-1"></a>        row_projection.prop(scene, <span class="st">"tissue_cartography_projection_resolution"</span>)</span>
<span id="cb1-1575"><a href="#cb1-1575" aria-hidden="true" tabindex="-1"></a>        row_projection2 <span class="op">=</span> layout.row()</span>
<span id="cb1-1576"><a href="#cb1-1576" aria-hidden="true" tabindex="-1"></a>        row_projection2.operator(<span class="st">"scene.create_projection"</span>, text<span class="op">=</span><span class="st">"Create Projection"</span>)</span>
<span id="cb1-1577"><a href="#cb1-1577" aria-hidden="true" tabindex="-1"></a>        row_projection2.operator(<span class="st">"scene.save_projection"</span>, text<span class="op">=</span><span class="st">"Save Projection"</span>)</span>
<span id="cb1-1578"><a href="#cb1-1578" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1579"><a href="#cb1-1579" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1580"><a href="#cb1-1580" aria-hidden="true" tabindex="-1"></a>        row_batch <span class="op">=</span> layout.row()</span>
<span id="cb1-1581"><a href="#cb1-1581" aria-hidden="true" tabindex="-1"></a>        row_batch.prop(scene, <span class="st">"tissue_cartography_batch_directory"</span>)</span>
<span id="cb1-1582"><a href="#cb1-1582" aria-hidden="true" tabindex="-1"></a>        row_batch.prop(scene, <span class="st">"tissue_cartography_batch_output_directory"</span>)</span>
<span id="cb1-1583"><a href="#cb1-1583" aria-hidden="true" tabindex="-1"></a>        row_batch.prop(scene, <span class="st">"tissue_cartography_batch_create_materials"</span>)</span>
<span id="cb1-1584"><a href="#cb1-1584" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.batch_projection"</span>, text<span class="op">=</span><span class="st">"Batch Process And Save"</span>)</span>
<span id="cb1-1585"><a href="#cb1-1585" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1586"><a href="#cb1-1586" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1587"><a href="#cb1-1587" aria-hidden="true" tabindex="-1"></a>        row_align <span class="op">=</span> layout.row()</span>
<span id="cb1-1588"><a href="#cb1-1588" aria-hidden="true" tabindex="-1"></a>        row_align.prop(scene, <span class="st">"tissue_cartography_prealign"</span>)</span>
<span id="cb1-1589"><a href="#cb1-1589" aria-hidden="true" tabindex="-1"></a>        row_align.prop(scene, <span class="st">"tissue_cartography_prealign_shear"</span>)</span>
<span id="cb1-1590"><a href="#cb1-1590" aria-hidden="true" tabindex="-1"></a>        row_align.prop(scene, <span class="st">"tissue_cartography_align_type"</span>)</span>
<span id="cb1-1591"><a href="#cb1-1591" aria-hidden="true" tabindex="-1"></a>        row_align.prop(scene, <span class="st">"tissue_cartography_align_iter"</span>)</span>
<span id="cb1-1592"><a href="#cb1-1592" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.align"</span>, text<span class="op">=</span><span class="st">"Align Meshes"</span>)</span>
<span id="cb1-1593"><a href="#cb1-1593" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1594"><a href="#cb1-1594" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1595"><a href="#cb1-1595" aria-hidden="true" tabindex="-1"></a>        row_shrinkwrap <span class="op">=</span> layout.row()</span>
<span id="cb1-1596"><a href="#cb1-1596" aria-hidden="true" tabindex="-1"></a>        row_shrinkwrap.prop(scene, <span class="st">"tissue_cartography_shrinkwarp_smooth"</span>)</span>
<span id="cb1-1597"><a href="#cb1-1597" aria-hidden="true" tabindex="-1"></a>        row_shrinkwrap.prop(scene, <span class="st">"tissue_cartography_shrinkwarp_iterative"</span>)</span>
<span id="cb1-1598"><a href="#cb1-1598" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.shrinkwrap"</span>, text<span class="op">=</span><span class="st">"Shrinkwrap Meshes (Active To Selected)"</span>)</span>
<span id="cb1-1599"><a href="#cb1-1599" aria-hidden="true" tabindex="-1"></a>        layout.separator()</span>
<span id="cb1-1600"><a href="#cb1-1600" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-1601"><a href="#cb1-1601" aria-hidden="true" tabindex="-1"></a>        layout.operator(<span class="st">"scene.help_popup"</span>, text<span class="op">=</span><span class="st">"Show help"</span>, icon<span class="op">=</span><span class="st">'HELP'</span>)</span>
<span id="cb1-1602"><a href="#cb1-1602" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1603"><a href="#cb1-1603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1604"><a href="#cb1-1604" aria-hidden="true" tabindex="-1"></a><span class="co">### Add the add-on to the user interface</span></span>
<span id="cb1-1605"><a href="#cb1-1605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1606"><a href="#cb1-1606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1607"><a href="#cb1-1607" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> register():</span>
<span id="cb1-1608"><a href="#cb1-1608" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Add the add-on to the blender user interface"""</span></span>
<span id="cb1-1609"><a href="#cb1-1609" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(TissueCartographyPanel)</span>
<span id="cb1-1610"><a href="#cb1-1610" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(LoadTIFFOperator)</span>
<span id="cb1-1611"><a href="#cb1-1611" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(LoadSegmentationTIFFOperator)</span>
<span id="cb1-1612"><a href="#cb1-1612" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(CreateProjectionOperator)</span>
<span id="cb1-1613"><a href="#cb1-1613" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(SaveProjectionOperator)</span>
<span id="cb1-1614"><a href="#cb1-1614" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(BatchProjectionOperator)</span>
<span id="cb1-1615"><a href="#cb1-1615" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(SlicePlaneOperator)</span>
<span id="cb1-1616"><a href="#cb1-1616" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(VertexShaderInitializeOperator)</span>
<span id="cb1-1617"><a href="#cb1-1617" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(VertexShaderRefreshOperator)</span>
<span id="cb1-1618"><a href="#cb1-1618" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(AlignOperator)</span>
<span id="cb1-1619"><a href="#cb1-1619" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(ShrinkwrapOperator)</span>
<span id="cb1-1620"><a href="#cb1-1620" aria-hidden="true" tabindex="-1"></a>    bpy.utils.register_class(HelpPopupOperator)</span>
<span id="cb1-1621"><a href="#cb1-1621" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1622"><a href="#cb1-1622" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_file <span class="op">=</span> StringProperty(</span>
<span id="cb1-1623"><a href="#cb1-1623" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"File Path"</span>,</span>
<span id="cb1-1624"><a href="#cb1-1624" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Path to the TIFF file"</span>,</span>
<span id="cb1-1625"><a href="#cb1-1625" aria-hidden="true" tabindex="-1"></a>        subtype<span class="op">=</span><span class="st">'FILE_PATH'</span>,</span>
<span id="cb1-1626"><a href="#cb1-1626" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1627"><a href="#cb1-1627" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_resolution <span class="op">=</span> FloatVectorProperty(</span>
<span id="cb1-1628"><a href="#cb1-1628" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"x/y/z Resolution (µm)"</span>,</span>
<span id="cb1-1629"><a href="#cb1-1629" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Resolution in microns along x, y, z axes"</span>,</span>
<span id="cb1-1630"><a href="#cb1-1630" aria-hidden="true" tabindex="-1"></a>        size<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb1-1631"><a href="#cb1-1631" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span>(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>),</span>
<span id="cb1-1632"><a href="#cb1-1632" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1633"><a href="#cb1-1633" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_axis_order<span class="op">=</span> StringProperty(</span>
<span id="cb1-1634"><a href="#cb1-1634" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Axis order"</span>,</span>
<span id="cb1-1635"><a href="#cb1-1635" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Axis order, either xyz + permutations or xyz + permutations (multichannel data). Dynamic data should be loaded as one .tiff per timepoint. If not provided, inferred automatically."</span>,</span>
<span id="cb1-1636"><a href="#cb1-1636" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">""</span>,</span>
<span id="cb1-1637"><a href="#cb1-1637" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1638"><a href="#cb1-1638" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_image_channels <span class="op">=</span> IntProperty(</span>
<span id="cb1-1639"><a href="#cb1-1639" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Image Channels"</span>,</span>
<span id="cb1-1640"><a href="#cb1-1640" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Channels of the loaded image (read-only)"</span>,</span>
<span id="cb1-1641"><a href="#cb1-1641" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1642"><a href="#cb1-1642" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1643"><a href="#cb1-1643" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1644"><a href="#cb1-1644" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_image_shape <span class="op">=</span> StringProperty(</span>
<span id="cb1-1645"><a href="#cb1-1645" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Image Shape"</span>,</span>
<span id="cb1-1646"><a href="#cb1-1646" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Shape of the loaded image (read-only)"</span>,</span>
<span id="cb1-1647"><a href="#cb1-1647" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">"Not loaded"</span></span>
<span id="cb1-1648"><a href="#cb1-1648" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1649"><a href="#cb1-1649" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_file <span class="op">=</span> StringProperty(</span>
<span id="cb1-1650"><a href="#cb1-1650" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Segmentation File Path"</span>,</span>
<span id="cb1-1651"><a href="#cb1-1651" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Path to the segmentation TIFF file. Should have values between 0-1. Selecting a folder instead of a single file will batch-process the full folder."</span>,</span>
<span id="cb1-1652"><a href="#cb1-1652" aria-hidden="true" tabindex="-1"></a>        subtype<span class="op">=</span><span class="st">'FILE_PATH'</span>,</span>
<span id="cb1-1653"><a href="#cb1-1653" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1654"><a href="#cb1-1654" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_resolution <span class="op">=</span> FloatVectorProperty(</span>
<span id="cb1-1655"><a href="#cb1-1655" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Segmentation x/y/z Resolution (µm)"</span>,</span>
<span id="cb1-1656"><a href="#cb1-1656" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Resolution of segmentation in microns along x, y, z axes"</span>,</span>
<span id="cb1-1657"><a href="#cb1-1657" aria-hidden="true" tabindex="-1"></a>        size<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb1-1658"><a href="#cb1-1658" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span>(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>),</span>
<span id="cb1-1659"><a href="#cb1-1659" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1660"><a href="#cb1-1660" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_axis_order<span class="op">=</span> StringProperty(</span>
<span id="cb1-1661"><a href="#cb1-1661" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Axis order segmentation"</span>,</span>
<span id="cb1-1662"><a href="#cb1-1662" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Axis order of segmentation, either xyz + permutations or cxyz + permutations (multichannel data). Different channels for a segmentation mean different labels. Dynamic data should be loaded as one .tiff per timepoint. If not provided, inferred automatically."</span>,</span>
<span id="cb1-1663"><a href="#cb1-1663" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">""</span>,</span>
<span id="cb1-1664"><a href="#cb1-1664" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1665"><a href="#cb1-1665" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_sigma <span class="op">=</span> FloatProperty(</span>
<span id="cb1-1666"><a href="#cb1-1666" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Smoothing (µm)"</span>,</span>
<span id="cb1-1667"><a href="#cb1-1667" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Smothing kernel for extracting mesh from segmentation, in µm"</span>,</span>
<span id="cb1-1668"><a href="#cb1-1668" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1669"><a href="#cb1-1669" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span></span>
<span id="cb1-1670"><a href="#cb1-1670" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1671"><a href="#cb1-1671" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_channels <span class="op">=</span> IntProperty(</span>
<span id="cb1-1672"><a href="#cb1-1672" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Segmentation Channels"</span>,</span>
<span id="cb1-1673"><a href="#cb1-1673" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Channels of the segmentation (read-only)"</span>,</span>
<span id="cb1-1674"><a href="#cb1-1674" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1675"><a href="#cb1-1675" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1676"><a href="#cb1-1676" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1677"><a href="#cb1-1677" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_segmentation_shape <span class="op">=</span> StringProperty(</span>
<span id="cb1-1678"><a href="#cb1-1678" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Segmentation Shape"</span>,</span>
<span id="cb1-1679"><a href="#cb1-1679" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Shape of the loaded segmentation (read-only)"</span>,</span>
<span id="cb1-1680"><a href="#cb1-1680" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">"Not loaded"</span></span>
<span id="cb1-1681"><a href="#cb1-1681" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1682"><a href="#cb1-1682" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_slice_axis <span class="op">=</span> EnumProperty(</span>
<span id="cb1-1683"><a href="#cb1-1683" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Slice Axis"</span>,</span>
<span id="cb1-1684"><a href="#cb1-1684" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Choose an axis"</span>,</span>
<span id="cb1-1685"><a href="#cb1-1685" aria-hidden="true" tabindex="-1"></a>        items<span class="op">=</span>[(<span class="st">'x'</span>, <span class="st">"X-Axis"</span>, <span class="st">"Align to the X axis"</span>),</span>
<span id="cb1-1686"><a href="#cb1-1686" aria-hidden="true" tabindex="-1"></a>               (<span class="st">'y'</span>, <span class="st">"Y-Axis"</span>, <span class="st">"Align to the Y axis"</span>),</span>
<span id="cb1-1687"><a href="#cb1-1687" aria-hidden="true" tabindex="-1"></a>               (<span class="st">'z'</span>, <span class="st">"Z-Axis"</span>, <span class="st">"Align to the Z axis"</span>)],</span>
<span id="cb1-1688"><a href="#cb1-1688" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">'x'</span></span>
<span id="cb1-1689"><a href="#cb1-1689" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1690"><a href="#cb1-1690" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_slice_position <span class="op">=</span> FloatProperty(</span>
<span id="cb1-1691"><a href="#cb1-1691" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Slice Position (µm)"</span>,</span>
<span id="cb1-1692"><a href="#cb1-1692" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Position along the selected axis in µm"</span>,</span>
<span id="cb1-1693"><a href="#cb1-1693" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span></span>
<span id="cb1-1694"><a href="#cb1-1694" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1695"><a href="#cb1-1695" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_slice_channel <span class="op">=</span> IntProperty(</span>
<span id="cb1-1696"><a href="#cb1-1696" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Slice Channel"</span>,</span>
<span id="cb1-1697"><a href="#cb1-1697" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Channel for slice plane"</span>,</span>
<span id="cb1-1698"><a href="#cb1-1698" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1699"><a href="#cb1-1699" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1700"><a href="#cb1-1700" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1701"><a href="#cb1-1701" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_vertex_shader_offset <span class="op">=</span> FloatProperty(</span>
<span id="cb1-1702"><a href="#cb1-1702" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Vertex Shader Normal Offset (µm)"</span>,</span>
<span id="cb1-1703"><a href="#cb1-1703" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Normal offse for vertex shading."</span>,</span>
<span id="cb1-1704"><a href="#cb1-1704" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1705"><a href="#cb1-1705" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1706"><a href="#cb1-1706" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_vertex_shader_channel <span class="op">=</span> IntProperty(</span>
<span id="cb1-1707"><a href="#cb1-1707" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Vertex Shader Channel"</span>,</span>
<span id="cb1-1708"><a href="#cb1-1708" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Channel for vertex shading."</span>,</span>
<span id="cb1-1709"><a href="#cb1-1709" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1710"><a href="#cb1-1710" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1711"><a href="#cb1-1711" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1712"><a href="#cb1-1712" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_offsets <span class="op">=</span> StringProperty(</span>
<span id="cb1-1713"><a href="#cb1-1713" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Normal Offsets (µm)"</span>,</span>
<span id="cb1-1714"><a href="#cb1-1714" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Comma-separated list of floats for multilayer projection offsets"</span>,</span>
<span id="cb1-1715"><a href="#cb1-1715" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">"0"</span>,</span>
<span id="cb1-1716"><a href="#cb1-1716" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1717"><a href="#cb1-1717" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_projection_resolution <span class="op">=</span> IntProperty(</span>
<span id="cb1-1718"><a href="#cb1-1718" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Projection Format (Pixels)"</span>,</span>
<span id="cb1-1719"><a href="#cb1-1719" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Resolution for the projection (e.g., 1024 for 1024x1024 pixels)"</span>,</span>
<span id="cb1-1720"><a href="#cb1-1720" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">1024</span>,</span>
<span id="cb1-1721"><a href="#cb1-1721" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb1-1722"><a href="#cb1-1722" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1723"><a href="#cb1-1723" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1724"><a href="#cb1-1724" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_batch_directory <span class="op">=</span> StringProperty(</span>
<span id="cb1-1725"><a href="#cb1-1725" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Batch Process Input Directory"</span>,</span>
<span id="cb1-1726"><a href="#cb1-1726" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Path to TIFF files directory"</span>,</span>
<span id="cb1-1727"><a href="#cb1-1727" aria-hidden="true" tabindex="-1"></a>        subtype<span class="op">=</span><span class="st">'DIR_PATH'</span>,</span>
<span id="cb1-1728"><a href="#cb1-1728" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1729"><a href="#cb1-1729" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_batch_output_directory <span class="op">=</span> StringProperty(</span>
<span id="cb1-1730"><a href="#cb1-1730" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Batch Process Output Directory"</span>,</span>
<span id="cb1-1731"><a href="#cb1-1731" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Path to TIFF files directory"</span>,</span>
<span id="cb1-1732"><a href="#cb1-1732" aria-hidden="true" tabindex="-1"></a>        subtype<span class="op">=</span><span class="st">'DIR_PATH'</span>,</span>
<span id="cb1-1733"><a href="#cb1-1733" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1734"><a href="#cb1-1734" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_batch_create_materials <span class="op">=</span> BoolProperty(</span>
<span id="cb1-1735"><a href="#cb1-1735" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Create materials"</span>,</span>
<span id="cb1-1736"><a href="#cb1-1736" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Enable or disable creating materials with projected texture in batch mode. Enabling can result in large .blend files."</span>,</span>
<span id="cb1-1737"><a href="#cb1-1737" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="va">True</span></span>
<span id="cb1-1738"><a href="#cb1-1738" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1739"><a href="#cb1-1739" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_prealign <span class="op">=</span> BoolProperty(</span>
<span id="cb1-1740"><a href="#cb1-1740" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Pre-align?"</span>,</span>
<span id="cb1-1741"><a href="#cb1-1741" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Enable or disable pre-alignment. Do not use if the two meshes are already closely aligned."</span>,</span>
<span id="cb1-1742"><a href="#cb1-1742" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="va">True</span></span>
<span id="cb1-1743"><a href="#cb1-1743" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1744"><a href="#cb1-1744" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_prealign_shear <span class="op">=</span> BoolProperty(</span>
<span id="cb1-1745"><a href="#cb1-1745" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Allow shear"</span>,</span>
<span id="cb1-1746"><a href="#cb1-1746" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Allow shear transformation during alignment."</span>,</span>
<span id="cb1-1747"><a href="#cb1-1747" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="va">True</span></span>
<span id="cb1-1748"><a href="#cb1-1748" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1749"><a href="#cb1-1749" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_align_type <span class="op">=</span> EnumProperty(</span>
<span id="cb1-1750"><a href="#cb1-1750" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Align Mode"</span>,</span>
<span id="cb1-1751"><a href="#cb1-1751" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Choose an axis"</span>,</span>
<span id="cb1-1752"><a href="#cb1-1752" aria-hidden="true" tabindex="-1"></a>        items<span class="op">=</span>[(<span class="st">'selected'</span>, <span class="st">"Selected to Active"</span>, <span class="st">"Align selected meshes to active mesh."</span>),</span>
<span id="cb1-1753"><a href="#cb1-1753" aria-hidden="true" tabindex="-1"></a>               (<span class="st">'active'</span>, <span class="st">"Active to Selected"</span>, <span class="st">"Align active mesh to selected meshe (creates copies of active mesh)."</span>)],</span>
<span id="cb1-1754"><a href="#cb1-1754" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">'selected'</span></span>
<span id="cb1-1755"><a href="#cb1-1755" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1756"><a href="#cb1-1756" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_align_iter <span class="op">=</span> IntProperty(</span>
<span id="cb1-1757"><a href="#cb1-1757" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Iterations"</span>,</span>
<span id="cb1-1758"><a href="#cb1-1758" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"ICP iterations during alignment."</span>,</span>
<span id="cb1-1759"><a href="#cb1-1759" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb1-1760"><a href="#cb1-1760" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb1-1761"><a href="#cb1-1761" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1762"><a href="#cb1-1762" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_shrinkwarp_smooth <span class="op">=</span> IntProperty(</span>
<span id="cb1-1763"><a href="#cb1-1763" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Shrinkwrap Corrective Smooth"</span>,</span>
<span id="cb1-1764"><a href="#cb1-1764" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Corrective smooth iterations during shrink-wrapping."</span>,</span>
<span id="cb1-1765"><a href="#cb1-1765" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb1-1766"><a href="#cb1-1766" aria-hidden="true" tabindex="-1"></a>        <span class="bu">min</span><span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-1767"><a href="#cb1-1767" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1768"><a href="#cb1-1768" aria-hidden="true" tabindex="-1"></a>    bpy.types.Scene.tissue_cartography_shrinkwarp_iterative <span class="op">=</span> EnumProperty(</span>
<span id="cb1-1769"><a href="#cb1-1769" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span><span class="st">"Shrinkwrap Mode"</span>,</span>
<span id="cb1-1770"><a href="#cb1-1770" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">"Choose an axis"</span>,</span>
<span id="cb1-1771"><a href="#cb1-1771" aria-hidden="true" tabindex="-1"></a>        items<span class="op">=</span>[(<span class="st">'one-to-all'</span>, <span class="st">"One-To-All"</span>, <span class="st">"Shrink-wrap active mesh to each selected individually"</span>),</span>
<span id="cb1-1772"><a href="#cb1-1772" aria-hidden="true" tabindex="-1"></a>               (<span class="st">'forward'</span>, <span class="st">"Iterative Forward"</span>, <span class="st">"Shrink-wrap active mesh to selected meshes iteratively, starting with alpha-numerically first"</span>),</span>
<span id="cb1-1773"><a href="#cb1-1773" aria-hidden="true" tabindex="-1"></a>               (<span class="st">'backward'</span>, <span class="st">"Iterative Backward"</span>, <span class="st">"Shrink-wrap active mesh to selected meshes iteratively, starting with alpha-numerically last"</span>)],</span>
<span id="cb1-1774"><a href="#cb1-1774" aria-hidden="true" tabindex="-1"></a>        default<span class="op">=</span><span class="st">'one-to-all'</span></span>
<span id="cb1-1775"><a href="#cb1-1775" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-1776"><a href="#cb1-1776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1777"><a href="#cb1-1777" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unregister():</span>
<span id="cb1-1778"><a href="#cb1-1778" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(TissueCartographyPanel)</span>
<span id="cb1-1779"><a href="#cb1-1779" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(LoadTIFFOperator)</span>
<span id="cb1-1780"><a href="#cb1-1780" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(LoadSegmentationTIFFOperator)</span>
<span id="cb1-1781"><a href="#cb1-1781" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(CreateProjectionOperator)</span>
<span id="cb1-1782"><a href="#cb1-1782" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(BatchProjectionOperator)</span>
<span id="cb1-1783"><a href="#cb1-1783" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(SaveProjectionOperator)</span>
<span id="cb1-1784"><a href="#cb1-1784" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(SlicePlaneOperator)</span>
<span id="cb1-1785"><a href="#cb1-1785" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(VertexShaderInitializeOperator)</span>
<span id="cb1-1786"><a href="#cb1-1786" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(VertexShaderRefreshOperator)</span>
<span id="cb1-1787"><a href="#cb1-1787" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(AlignOperator)</span>
<span id="cb1-1788"><a href="#cb1-1788" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(ShrinkwrapOperator)</span>
<span id="cb1-1789"><a href="#cb1-1789" aria-hidden="true" tabindex="-1"></a>    bpy.utils.unregister_class(HelpPopupOperator)</span>
<span id="cb1-1790"><a href="#cb1-1790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1791"><a href="#cb1-1791" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_file </span>
<span id="cb1-1792"><a href="#cb1-1792" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_resolution</span>
<span id="cb1-1793"><a href="#cb1-1793" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_axis_order</span>
<span id="cb1-1794"><a href="#cb1-1794" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_image_channels</span>
<span id="cb1-1795"><a href="#cb1-1795" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_image_shape</span>
<span id="cb1-1796"><a href="#cb1-1796" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_file</span>
<span id="cb1-1797"><a href="#cb1-1797" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_resolution</span>
<span id="cb1-1798"><a href="#cb1-1798" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_axis_order</span>
<span id="cb1-1799"><a href="#cb1-1799" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_sigma</span>
<span id="cb1-1800"><a href="#cb1-1800" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_channels</span>
<span id="cb1-1801"><a href="#cb1-1801" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_segmentation_shape</span>
<span id="cb1-1802"><a href="#cb1-1802" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_offsets </span>
<span id="cb1-1803"><a href="#cb1-1803" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_projection_resolution </span>
<span id="cb1-1804"><a href="#cb1-1804" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_slice_axis </span>
<span id="cb1-1805"><a href="#cb1-1805" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_slice_position </span>
<span id="cb1-1806"><a href="#cb1-1806" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_slice_channel </span>
<span id="cb1-1807"><a href="#cb1-1807" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_vertex_shader_offset </span>
<span id="cb1-1808"><a href="#cb1-1808" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_vertex_shader_channel</span>
<span id="cb1-1809"><a href="#cb1-1809" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_prealign </span>
<span id="cb1-1810"><a href="#cb1-1810" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_prealign_shear</span>
<span id="cb1-1811"><a href="#cb1-1811" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_align_iter</span>
<span id="cb1-1812"><a href="#cb1-1812" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_align_type</span>
<span id="cb1-1813"><a href="#cb1-1813" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_batch_directory</span>
<span id="cb1-1814"><a href="#cb1-1814" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_batch_output_directory</span>
<span id="cb1-1815"><a href="#cb1-1815" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_batch_create_materials</span>
<span id="cb1-1816"><a href="#cb1-1816" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_shrinkwarp_smooth</span>
<span id="cb1-1817"><a href="#cb1-1817" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> bpy.types.Scene.tissue_cartography_shrinkwarp_iterative</span>
<span id="cb1-1818"><a href="#cb1-1818" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-1819"><a href="#cb1-1819" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> bpy.types.Scene.tissue_cartography_interpolators <span class="kw">in</span> <span class="bu">globals</span>():</span>
<span id="cb1-1820"><a href="#cb1-1820" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> bpy.types.Scene.tissue_cartography_interpolators</span>
<span id="cb1-1821"><a href="#cb1-1821" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1822"><a href="#cb1-1822" aria-hidden="true" tabindex="-1"></a><span class="co">### Run the add-on</span></span>
<span id="cb1-1823"><a href="#cb1-1823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1824"><a href="#cb1-1824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1825"><a href="#cb1-1825" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb1-1826"><a href="#cb1-1826" aria-hidden="true" tabindex="-1"></a>    register()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nikolas-claussen\.github\.io\/blender-tissue-cartography");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/nikolas-claussen/blender-tissue-cartography/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>